---
phase: 05-message-history
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/actions/contact.ts
  - lib/data/send-logs.ts
  - components/history/status-badge.tsx
  - components/history/history-filters.tsx
autonomous: true

must_haves:
  truths:
    - "getSendLogs accepts query, status, dateFrom, dateTo parameters"
    - "StatusBadge displays all 7 status types with appropriate colors"
    - "Filters include search input, status dropdown, date range inputs"
  artifacts:
    - path: "lib/data/send-logs.ts"
      provides: "Extended getSendLogs function with filtering"
      exports: ["getSendLogs"]
      contains: "query.*status.*dateFrom.*dateTo"
    - path: "components/history/status-badge.tsx"
      provides: "Status display component"
      exports: ["StatusBadge"]
      min_lines: 25
    - path: "components/history/history-filters.tsx"
      provides: "Filter controls component"
      exports: ["HistoryFilters"]
      min_lines: 60
  key_links:
    - from: "lib/data/send-logs.ts"
      to: "supabase"
      via: "query builder with ilike and date filtering"
      pattern: "(ilike|gte|lte).*created_at"
---

<objective>
Create the data layer and reusable UI components for message history filtering.

Purpose: Enable server-side filtering of send logs by search term, status, and date range. Build the visual components (StatusBadge, HistoryFilters) that will be used in the history table.

Output: Extended getSendLogs function, StatusBadge component, HistoryFilters component
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-message-history/05-RESEARCH.md

# Existing patterns to follow
@lib/data/send-logs.ts
@lib/actions/contact.ts
@components/contacts/contact-filters.tsx
@lib/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Export escapeLikePattern and extend getSendLogs with filtering</name>
  <files>lib/actions/contact.ts, lib/data/send-logs.ts</files>
  <action>
**Step 1:** In `lib/actions/contact.ts`, add the `export` keyword to the existing `escapeLikePattern` function (line 12):

Change:
```typescript
function escapeLikePattern(str: string): string {
```
To:
```typescript
export function escapeLikePattern(str: string): string {
```

This makes the SQL injection protection utility available for reuse.

**Step 2:** Update `lib/data/send-logs.ts` to import and use the function. Add additional filter parameters to getSendLogs:

```typescript
import { escapeLikePattern } from '@/lib/actions/contact'

export async function getSendLogs(options?: {
  limit?: number
  offset?: number
  contactId?: string
  query?: string          // NEW: Search by contact name or email
  status?: string         // NEW: Filter by status (pending, sent, delivered, etc.)
  dateFrom?: string       // NEW: Filter by date range start (ISO string)
  dateTo?: string         // NEW: Filter by date range end (ISO string)
}): Promise<{ logs: SendLogWithContact[]; total: number }>
```

Implementation details:

1. **Search filter (query)**: Use Supabase's `or` filter with `referencedTable` option to search the joined contacts table:
```typescript
if (options?.query) {
  const escapedQuery = escapeLikePattern(options.query)
  query = query.or(`name.ilike.%${escapedQuery}%,email.ilike.%${escapedQuery}%`, {
    referencedTable: 'contacts'
  })
}
```

2. **Status filter**: Simple equality filter on status column:
```typescript
if (options?.status) {
  query = query.eq('status', options.status)
}
```

3. **Date range filter**: Use gte/lte on created_at (already indexed):
```typescript
if (options?.dateFrom) {
  query = query.gte('created_at', options.dateFrom)
}
if (options?.dateTo) {
  // Add time component to include the entire end day
  const endOfDay = new Date(options.dateTo)
  endOfDay.setHours(23, 59, 59, 999)
  query = query.lte('created_at', endOfDay.toISOString())
}
```

DO NOT change the existing function signature (keep it backward compatible). Just add optional parameters.
  </action>
  <verify>
Run `pnpm typecheck` - no type errors.
Manually verify the function signature includes all new optional parameters.
Verify `escapeLikePattern` is now exported from `lib/actions/contact.ts`.
  </verify>
  <done>
getSendLogs accepts query, status, dateFrom, dateTo parameters and properly applies them to the Supabase query. Search uses escaped pattern matching on contacts table. escapeLikePattern is exported and reusable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create StatusBadge component</name>
  <files>components/history/status-badge.tsx</files>
  <action>
Create a new directory `components/history/` and add `status-badge.tsx`.

This component displays email delivery status as colored badges. Reference the research for status colors:

```typescript
'use client'

import { Badge } from '@/components/ui/badge'
import { cn } from '@/lib/utils'

export type SendStatus = 'pending' | 'sent' | 'delivered' | 'bounced' | 'complained' | 'failed' | 'opened'

const statusConfig: Record<SendStatus, { label: string; className: string }> = {
  pending: { label: 'Pending', className: 'bg-gray-100 text-gray-800 hover:bg-gray-100' },
  sent: { label: 'Sent', className: 'bg-blue-100 text-blue-800 hover:bg-blue-100' },
  delivered: { label: 'Delivered', className: 'bg-green-100 text-green-800 hover:bg-green-100' },
  bounced: { label: 'Bounced', className: 'bg-red-100 text-red-800 hover:bg-red-100' },
  complained: { label: 'Complained', className: 'bg-orange-100 text-orange-800 hover:bg-orange-100' },
  failed: { label: 'Failed', className: 'bg-red-100 text-red-800 hover:bg-red-100' },
  opened: { label: 'Opened', className: 'bg-emerald-100 text-emerald-800 hover:bg-emerald-100' },
}

interface StatusBadgeProps {
  status: SendStatus
  className?: string
}

export function StatusBadge({ status, className }: StatusBadgeProps) {
  const config = statusConfig[status]

  return (
    <Badge
      variant="secondary"
      className={cn(config.className, className)}
    >
      {config.label}
    </Badge>
  )
}
```

Use 'secondary' variant as base and override with custom classes for each status color.
  </action>
  <verify>
Run `pnpm typecheck` - no type errors.
Verify file exists at `components/history/status-badge.tsx`.
  </verify>
  <done>
StatusBadge component renders all 7 status types with appropriate semantic colors (green for success states, red for failures, blue/gray for in-progress).
  </done>
</task>

<task type="auto">
  <name>Task 3: Create HistoryFilters component</name>
  <files>components/history/history-filters.tsx</files>
  <action>
Create `components/history/history-filters.tsx` following the pattern from contact-filters.tsx but with URL-based state management (per research recommendations).

The component receives current filter values from URL searchParams and updates them via router.replace().

**IMPORTANT:** Do NOT use `@/components/ui/select` - it does not exist. Instead, use a native HTML select element styled with Tailwind, following the project's existing patterns.

```typescript
'use client'

import { useSearchParams, usePathname, useRouter } from 'next/navigation'
import { useTransition, useRef, useEffect } from 'react'
import { Input } from '@/components/ui/input'
import { Button } from '@/components/ui/button'
import { Label } from '@/components/ui/label'
import { X, Search, Loader2 } from 'lucide-react'
import type { SendStatus } from './status-badge'

const STATUS_OPTIONS: { value: string; label: string }[] = [
  { value: 'all', label: 'All statuses' },
  { value: 'pending', label: 'Pending' },
  { value: 'sent', label: 'Sent' },
  { value: 'delivered', label: 'Delivered' },
  { value: 'bounced', label: 'Bounced' },
  { value: 'complained', label: 'Complained' },
  { value: 'failed', label: 'Failed' },
  { value: 'opened', label: 'Opened' },
]

export function HistoryFilters() {
  const searchParams = useSearchParams()
  const pathname = usePathname()
  const { replace } = useRouter()
  const [isPending, startTransition] = useTransition()
  const debounceRef = useRef<NodeJS.Timeout | null>(null)

  // Get current filter values from URL
  const query = searchParams.get('query') || ''
  const status = searchParams.get('status') || 'all'
  const dateFrom = searchParams.get('from') || ''
  const dateTo = searchParams.get('to') || ''

  const hasActiveFilters = query !== '' || status !== 'all' || dateFrom !== '' || dateTo !== ''

  // Update URL with new filter value
  function updateFilter(key: string, value: string) {
    const params = new URLSearchParams(searchParams)
    params.set('page', '1') // Reset pagination on filter change

    if (value && value !== 'all') {
      params.set(key, value)
    } else {
      params.delete(key)
    }

    startTransition(() => {
      replace(`${pathname}?${params.toString()}`)
    })
  }

  // Debounced search handler (300ms)
  function handleSearchChange(value: string) {
    if (debounceRef.current) {
      clearTimeout(debounceRef.current)
    }
    debounceRef.current = setTimeout(() => {
      updateFilter('query', value)
    }, 300)
  }

  // Cleanup debounce on unmount
  useEffect(() => {
    return () => {
      if (debounceRef.current) {
        clearTimeout(debounceRef.current)
      }
    }
  }, [])

  function clearFilters() {
    startTransition(() => {
      replace(pathname)
    })
  }

  return (
    <div className="space-y-4">
      {/* Search and status row */}
      <div className="flex flex-col sm:flex-row gap-4">
        {/* Search input */}
        <div className="relative flex-1">
          <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
          <Input
            placeholder="Search by name or email..."
            defaultValue={query}
            onChange={(e) => handleSearchChange(e.target.value)}
            className="pl-9"
          />
        </div>

        {/* Status filter - native HTML select styled with Tailwind */}
        <select
          value={status}
          onChange={(e) => updateFilter('status', e.target.value)}
          className="h-10 w-full sm:w-[180px] rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2"
        >
          {STATUS_OPTIONS.map((option) => (
            <option key={option.value} value={option.value}>
              {option.label}
            </option>
          ))}
        </select>
      </div>

      {/* Date range row */}
      <div className="flex flex-col sm:flex-row items-start sm:items-end gap-4">
        <div className="flex flex-col sm:flex-row gap-4">
          <div className="space-y-1.5">
            <Label htmlFor="date-from" className="text-sm text-muted-foreground">From</Label>
            <Input
              id="date-from"
              type="date"
              value={dateFrom}
              onChange={(e) => updateFilter('from', e.target.value)}
              className="w-full sm:w-[160px]"
            />
          </div>
          <div className="space-y-1.5">
            <Label htmlFor="date-to" className="text-sm text-muted-foreground">To</Label>
            <Input
              id="date-to"
              type="date"
              value={dateTo}
              onChange={(e) => updateFilter('to', e.target.value)}
              className="w-full sm:w-[160px]"
            />
          </div>
        </div>

        {/* Clear filters / Loading indicator */}
        <div className="flex items-center gap-2">
          {isPending && (
            <Loader2 className="h-4 w-4 animate-spin text-muted-foreground" />
          )}
          {hasActiveFilters && (
            <Button variant="ghost" size="sm" onClick={clearFilters}>
              <X className="mr-1 h-3 w-3" />
              Clear filters
            </Button>
          )}
        </div>
      </div>
    </div>
  )
}
```

Key differences from contact-filters:
- Uses URL searchParams (not props) for filter state
- Includes date range inputs (native HTML date)
- Uses native HTML select dropdown for status (NOT ui/select which doesn't exist)
- Debounced search with 300ms delay
- Shows loading indicator during transitions
  </action>
  <verify>
Run `pnpm typecheck` - no type errors.
Verify file exists at `components/history/history-filters.tsx`.
  </verify>
  <done>
HistoryFilters component manages filter state via URL searchParams, includes search input with 300ms debounce, status dropdown (native select), date range inputs, and clear filters button.
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes with no errors
2. `pnpm lint` passes
3. All files exist:
   - lib/actions/contact.ts (updated - escapeLikePattern now exported)
   - lib/data/send-logs.ts (updated)
   - components/history/status-badge.tsx (new)
   - components/history/history-filters.tsx (new)
4. getSendLogs function accepts query, status, dateFrom, dateTo parameters
5. StatusBadge handles all 7 status types
6. HistoryFilters uses URL-based state management with native HTML select
</verification>

<success_criteria>
- escapeLikePattern is exported from lib/actions/contact.ts for reuse
- getSendLogs function extended with filtering without breaking existing callers
- StatusBadge displays semantic colors for each status type
- HistoryFilters updates URL params and resets pagination on filter change
- All code follows existing codebase patterns (contact-filters, native select)
</success_criteria>

<output>
After completion, create `.planning/phases/05-message-history/05-01-SUMMARY.md`
</output>
