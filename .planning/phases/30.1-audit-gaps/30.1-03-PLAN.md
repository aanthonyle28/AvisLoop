---
phase: 30.1-audit-gaps
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - components/jobs/job-columns.tsx
  - components/jobs/job-table.tsx
  - components/jobs/job-detail-drawer.tsx
  - lib/data/campaign.ts
autonomous: true

must_haves:
  truths:
    - "Job table shows campaign enrollment preview for completed jobs"
    - "Preview shows campaign name and timing (e.g., 'HVAC Campaign in 24h')"
    - "Jobs not enrolled show 'Not enrolled' indicator"
    - "Job detail drawer shows enrollment status and campaign info"
  artifacts:
    - path: "components/jobs/job-columns.tsx"
      provides: "Enrollment preview column"
      contains: "enrollment"
    - path: "lib/data/campaign.ts"
      provides: "Function to get matching campaign for job"
      exports: ["getMatchingCampaignForJob"]
  key_links:
    - from: "components/jobs/job-columns.tsx"
      to: "campaign enrollment data"
      via: "row.original.enrollment or matching campaign lookup"
      pattern: "enrollment|campaign"
---

<objective>
Add campaign enrollment preview to job table and job detail drawer.

Purpose: V2 feedback loop - users see what automation will do when jobs are completed (UX V2 Debt from UX-AUDIT.md).

Output: Jobs show campaign enrollment preview ("Will enroll in HVAC Campaign in 24h" or enrollment status if already enrolled).
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/UX-AUDIT.md (V2 Debt: Campaign enrollment preview on jobs)
@.planning/V1-TO-V2-PHILOSOPHY.md

Job table: @components/jobs/job-table.tsx
Job columns: @components/jobs/job-columns.tsx
Campaign data: @lib/data/campaign.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getMatchingCampaignForJob function</name>
  <files>lib/data/campaign.ts</files>
  <action>
Add a function to find the campaign that would match a job (by service type or default campaign):

```tsx
/**
 * Get the campaign that would match a job based on service type
 * Returns matching campaign with timing info, or null if no active campaign
 */
export async function getMatchingCampaignForJob(
  businessId: string,
  serviceType: string
): Promise<{
  campaign: { id: string; name: string; service_type: string | null };
  firstTouchDelay: number;
} | null> {
  const supabase = await createClient()

  // First try to find campaign matching service type, then fall back to default (null service_type)
  const { data: campaigns } = await supabase
    .from('campaigns')
    .select('id, name, service_type, campaign_touches(delay_hours)')
    .eq('business_id', businessId)
    .eq('status', 'active')
    .in('service_type', [serviceType, null])
    .order('service_type', { ascending: false, nullsFirst: false }) // Specific service type first
    .limit(1)

  if (!campaigns || campaigns.length === 0) {
    return null
  }

  const campaign = campaigns[0]
  const firstTouch = campaign.campaign_touches?.[0]
  const firstTouchDelay = firstTouch?.delay_hours || 24

  return {
    campaign: {
      id: campaign.id,
      name: campaign.name,
      service_type: campaign.service_type,
    },
    firstTouchDelay,
  }
}
```

Also add a batch version for efficiency (job list needs multiple lookups):

```tsx
/**
 * Get matching campaigns for multiple jobs in one query
 */
export async function getMatchingCampaignsForJobs(
  businessId: string,
  serviceTypes: string[]
): Promise<Map<string, { campaignName: string; firstTouchDelay: number }>> {
  const supabase = await createClient()

  // Get all active campaigns for the business
  const { data: campaigns } = await supabase
    .from('campaigns')
    .select('id, name, service_type, campaign_touches(delay_hours)')
    .eq('business_id', businessId)
    .eq('status', 'active')

  if (!campaigns) return new Map()

  // Build map: serviceType -> campaign info
  const result = new Map<string, { campaignName: string; firstTouchDelay: number }>()

  // Find default campaign (null service_type)
  const defaultCampaign = campaigns.find(c => c.service_type === null)

  for (const st of serviceTypes) {
    // Try specific campaign first, then default
    const specific = campaigns.find(c => c.service_type === st)
    const campaign = specific || defaultCampaign

    if (campaign) {
      const firstTouch = campaign.campaign_touches?.[0]
      result.set(st, {
        campaignName: campaign.name,
        firstTouchDelay: firstTouch?.delay_hours || 24,
      })
    }
  }

  return result
}
```
  </action>
  <verify>grep "getMatchingCampaignForJob" lib/data/campaign.ts</verify>
  <done>Campaign matching functions exported from lib/data/campaign.ts</done>
</task>

<task type="auto">
  <name>Task 2: Add enrollment preview column to job table</name>
  <files>components/jobs/job-columns.tsx, components/jobs/job-table.tsx</files>
  <action>
**Update job-columns.tsx:**

Add a new column for campaign enrollment preview after the status column:

```tsx
import { Clock, CheckCircle, XCircle } from '@phosphor-icons/react'

// Add to columns array, after status column:
{
  accessorKey: 'enrollment',
  header: 'Campaign',
  cell: ({ row }) => {
    const job = row.original
    // enrollment data will be passed via row context or computed
    const enrollment = job.enrollment // if job has enrollment relation
    const matchingCampaign = job.matchingCampaign // computed by parent

    if (job.status === 'do_not_send') {
      return (
        <span className="text-xs text-muted-foreground flex items-center gap-1">
          <XCircle className="h-3.5 w-3.5" />
          Not enrolled
        </span>
      )
    }

    if (enrollment) {
      // Already enrolled
      return (
        <span className="text-xs text-green-600 dark:text-green-400 flex items-center gap-1">
          <CheckCircle className="h-3.5 w-3.5" />
          {enrollment.campaigns?.name || 'Enrolled'}
        </span>
      )
    }

    if (matchingCampaign && job.status === 'scheduled') {
      // Will enroll when completed
      const hours = matchingCampaign.firstTouchDelay
      const timeStr = hours < 24 ? `${hours}h` : `${Math.round(hours / 24)}d`
      return (
        <span className="text-xs text-muted-foreground flex items-center gap-1">
          <Clock className="h-3.5 w-3.5" />
          {matchingCampaign.campaignName} in {timeStr}
        </span>
      )
    }

    if (matchingCampaign && job.status === 'completed') {
      // Should be enrolled but isn't (edge case)
      return (
        <span className="text-xs text-amber-600 dark:text-amber-400 flex items-center gap-1">
          <Clock className="h-3.5 w-3.5" />
          Pending enrollment
        </span>
      )
    }

    return (
      <span className="text-xs text-muted-foreground">
        No campaign
      </span>
    )
  },
},
```

**Update job-table.tsx:**

1. Accept `campaignMap` prop: Map of service_type -> campaign info
2. Pass campaign info to rows via enhanced data

```tsx
interface JobTableProps {
  jobs: JobWithCustomer[]
  customers: Customer[]
  campaignMap?: Map<string, { campaignName: string; firstTouchDelay: number }>
}

// In component, enhance jobs with campaign info:
const enhancedJobs = useMemo(() => {
  return jobs.map(job => ({
    ...job,
    matchingCampaign: campaignMap?.get(job.service_type) || null,
  }))
}, [jobs, campaignMap])
```

Note: The parent page (jobs/page.tsx) will call getMatchingCampaignsForJobs and pass the map. This plan focuses on the table component changes.
  </action>
  <verify>
- grep "enrollment" components/jobs/job-columns.tsx
- grep "campaignMap" components/jobs/job-table.tsx
  </verify>
  <done>Job table shows campaign enrollment preview column</done>
</task>

<task type="auto">
  <name>Task 3: Update Jobs page to pass campaign data</name>
  <files>app/(dashboard)/jobs/page.tsx</files>
  <action>
Update the Jobs page to fetch campaign data and pass to JobTable:

1. Import getMatchingCampaignsForJobs from @/lib/data/campaign
2. Get unique service types from jobs
3. Fetch matching campaigns
4. Pass campaignMap to JobTable

```tsx
import { getMatchingCampaignsForJobs } from '@/lib/data/campaign'

// In the page component, after fetching jobs:
const serviceTypes = [...new Set(jobs.map(j => j.service_type))]
const campaignMap = await getMatchingCampaignsForJobs(business.id, serviceTypes)

// Pass to client component:
<JobsClient
  jobs={jobs}
  customers={customers}
  campaignMap={campaignMap}
/>
```

Note: If JobsClient exists, update its props. If jobs are rendered directly, update the JobTable call.

The campaignMap is serializable (can be converted to/from plain object for server/client boundary if needed).
  </action>
  <verify>grep "getMatchingCampaignsForJobs" app/(dashboard)/jobs/page.tsx</verify>
  <done>Jobs page fetches and passes campaign enrollment preview data</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes
2. `pnpm lint` passes
3. Job table shows "Campaign" column with enrollment preview
4. Scheduled jobs show "HVAC Campaign in 24h" style preview
5. Completed+enrolled jobs show green checkmark with campaign name
6. do_not_send jobs show "Not enrolled"
7. Jobs with no matching campaign show "No campaign"
</verification>

<success_criteria>
- getMatchingCampaignsForJobs function exists in lib/data/campaign.ts
- Job table has Campaign column showing enrollment preview
- Preview shows timing for scheduled jobs with matching campaign
- No TypeScript or lint errors
</success_criteria>

<output>
After completion, create `.planning/phases/30.1-audit-gaps/30.1-03-SUMMARY.md`
</output>
