---
phase: 30.1-audit-gaps
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - components/ui/table-skeleton.tsx
  - components/customers/customer-table.tsx
  - components/jobs/job-table.tsx
  - components/history/history-table.tsx
autonomous: true

must_haves:
  truths:
    - "All data tables show skeleton loader during data fetch"
    - "Skeleton matches table column structure"
    - "Loading state visible for minimum 200ms to avoid flash"
  artifacts:
    - path: "components/ui/table-skeleton.tsx"
      provides: "Reusable TableSkeleton component"
      exports: ["TableSkeleton"]
    - path: "components/customers/customer-table.tsx"
      provides: "Customer table with loading state"
      contains: "TableSkeleton"
    - path: "components/jobs/job-table.tsx"
      provides: "Job table with loading state"
      contains: "TableSkeleton"
    - path: "components/history/history-table.tsx"
      provides: "History table with loading state"
      contains: "TableSkeleton"
  key_links:
    - from: "components/customers/customer-table.tsx"
      to: "components/ui/table-skeleton.tsx"
      via: "import TableSkeleton"
      pattern: "import.*TableSkeleton.*table-skeleton"
---

<objective>
Create reusable table skeleton loader component and integrate it into Customer, Job, and History tables.

Purpose: Improve perceived performance by showing structured loading state during data fetch (UX Critical #3 from UX-AUDIT.md).

Output: TableSkeleton component, updated table components with loading prop.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/UX-AUDIT.md (Critical #3)

Existing skeleton component: @components/ui/skeleton.tsx
Tables to update:
- @components/customers/customer-table.tsx
- @components/jobs/job-table.tsx
- @components/history/history-table.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TableSkeleton component</name>
  <files>components/ui/table-skeleton.tsx</files>
  <action>
Create a reusable TableSkeleton component that:
1. Accepts props: `columns: number`, `rows?: number` (default 5), `className?: string`
2. Uses existing Skeleton component from @/components/ui/skeleton
3. Renders table structure with skeleton cells matching column count
4. Includes header row skeleton (slightly taller/bolder than body rows)
5. Uses same table structure as shadcn Table component for visual consistency

Pattern:
```tsx
interface TableSkeletonProps {
  columns: number
  rows?: number
  className?: string
}

export function TableSkeleton({ columns, rows = 5, className }: TableSkeletonProps) {
  return (
    <div className={cn("rounded-md border", className)}>
      <Table>
        <TableHeader>
          <TableRow>
            {Array.from({ length: columns }).map((_, i) => (
              <TableHead key={i}>
                <Skeleton className="h-4 w-[80%]" />
              </TableHead>
            ))}
          </TableRow>
        </TableHeader>
        <TableBody>
          {Array.from({ length: rows }).map((_, rowIdx) => (
            <TableRow key={rowIdx}>
              {Array.from({ length: columns }).map((_, colIdx) => (
                <TableCell key={colIdx}>
                  <Skeleton className="h-4 w-[60%]" />
                </TableCell>
              ))}
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  )
}
```
  </action>
  <verify>File exists at components/ui/table-skeleton.tsx, exports TableSkeleton</verify>
  <done>TableSkeleton component created with configurable columns and rows</done>
</task>

<task type="auto">
  <name>Task 2: Add skeleton to CustomerTable</name>
  <files>components/customers/customer-table.tsx</files>
  <action>
Update CustomerTable to support loading state:

1. Add `loading?: boolean` prop to CustomerTableProps interface
2. Import TableSkeleton from @/components/ui/table-skeleton
3. When loading=true, render TableSkeleton with columns={6} (checkbox, name, email, phone, tags, actions)
4. When loading=false, render existing table content

Update the component:
```tsx
interface CustomerTableProps {
  data: Customer[]
  loading?: boolean  // NEW
  onEdit: ...
}

export function CustomerTable({
  data,
  loading,  // NEW
  ...
}: CustomerTableProps) {
  // ... existing state ...

  if (loading) {
    return <TableSkeleton columns={6} rows={8} />
  }

  // ... existing table render ...
}
```

Note: The parent component (customers-client.tsx) will pass loading based on data fetch state.
  </action>
  <verify>CustomerTable accepts loading prop and renders TableSkeleton when loading=true</verify>
  <done>CustomerTable shows skeleton during data loading</done>
</task>

<task type="auto">
  <name>Task 3: Add skeleton to JobTable and HistoryTable</name>
  <files>components/jobs/job-table.tsx, components/history/history-table.tsx</files>
  <action>
Apply same pattern to JobTable and HistoryTable:

**JobTable (job-table.tsx):**
1. Add `loading?: boolean` prop to JobTableProps
2. Import TableSkeleton
3. When loading=true, render TableSkeleton with columns={5} (customer, service, status, completed, actions)
4. Otherwise render existing table

**HistoryTable (history-table.tsx):**
1. Add `loading?: boolean` prop to HistoryTableProps
2. Import TableSkeleton
3. When loading=true, render TableSkeleton with columns={5} (customer, subject, status, sent, actions)
4. Otherwise render existing table

Note: The parent page components will pass loading prop based on their data fetch state. This plan only adds the loading support - parent integration happens via natural React patterns.
  </action>
  <verify>
Both tables accept loading prop:
- grep "loading.*boolean" components/jobs/job-table.tsx
- grep "loading.*boolean" components/history/history-table.tsx
- grep "TableSkeleton" components/jobs/job-table.tsx
- grep "TableSkeleton" components/history/history-table.tsx
  </verify>
  <done>JobTable and HistoryTable show skeleton during data loading</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes
2. `pnpm lint` passes
3. TableSkeleton component exists and exports correctly
4. All three table components import and use TableSkeleton
5. Visual: Tables show animated skeleton rows during loading
</verification>

<success_criteria>
- TableSkeleton component created at components/ui/table-skeleton.tsx
- CustomerTable, JobTable, HistoryTable all accept loading prop
- When loading=true, skeleton with correct column count renders
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/30.1-audit-gaps/30.1-01-SUMMARY.md`
</output>
