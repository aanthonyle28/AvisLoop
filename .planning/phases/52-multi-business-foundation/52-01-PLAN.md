---
phase: 52-multi-business-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/data/active-business.ts
  - lib/actions/active-business.ts
autonomous: true

must_haves:
  truths:
    - "getActiveBusiness() returns the user's business when they have exactly one business"
    - "getActiveBusiness() returns the first business (by created_at) when the user has multiple businesses but no active_business_id cookie"
    - "getActiveBusiness() returns null when the user has zero businesses"
    - "getActiveBusiness() returns the cookie-referenced business when the cookie is valid and the user owns it"
    - "getActiveBusiness() falls back to the first business when the cookie references a business the user does not own"
    - "switchBusiness() sets an httpOnly cookie and calls revalidatePath"
    - "getUserBusinesses() returns an array of {id, name} for all businesses the user owns"
  artifacts:
    - path: "lib/data/active-business.ts"
      provides: "getActiveBusiness() resolver and getUserBusinesses() query"
      exports: ["getActiveBusiness", "getUserBusinesses"]
    - path: "lib/actions/active-business.ts"
      provides: "switchBusiness() server action"
      exports: ["switchBusiness"]
  key_links:
    - from: "lib/data/active-business.ts"
      to: "next/headers cookies()"
      via: "reads active_business_id cookie"
      pattern: "cookieStore\\.get\\(.*active_business_id"
    - from: "lib/data/active-business.ts"
      to: "supabase businesses table"
      via: "queries with .limit(1) fallback, NOT .single()"
      pattern: "\\.limit\\(1\\)"
    - from: "lib/actions/active-business.ts"
      to: "next/headers cookies()"
      via: "sets active_business_id cookie"
      pattern: "cookieStore\\.set"
    - from: "lib/actions/active-business.ts"
      to: "next/cache revalidatePath"
      via: "triggers full layout re-render on switch"
      pattern: "revalidatePath.*layout"
---

<objective>
Create the cookie-based business resolver, business switcher action, and multi-business query that form the single resolution point for "which business is active."

Purpose: All subsequent v3.0 phases depend on `getActiveBusiness()` as the canonical way to resolve the current business. Without this, adding a second business crashes the entire app (PGRST116 from `.single()` calls). This plan creates the new resolution path alongside the existing one without modifying any existing code.

Output: Two new files (`lib/data/active-business.ts` and `lib/actions/active-business.ts`) that downstream plans and phases will consume.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/52-multi-business-foundation/52-RESEARCH.md
@lib/supabase/server.ts
@lib/types/database.ts
@lib/data/business.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create getActiveBusiness() resolver and getUserBusinesses() query</name>
  <files>lib/data/active-business.ts</files>
  <action>
Create `lib/data/active-business.ts` with two exported async functions:

**`getActiveBusiness(): Promise<Business | null>`**
1. Read `active_business_id` from cookies via `await cookies()` from `next/headers`
2. Get authenticated user via `supabase.auth.getUser()` -- return `null` if no user
3. If cookie exists: query `businesses` table with `.eq('id', activeId).eq('user_id', user.id).single()` -- if found, return it
4. If cookie missing/invalid: fallback query `businesses` table with `.eq('user_id', user.id).order('created_at', { ascending: true }).limit(1)` and return `data?.[0] ?? null`

CRITICAL: The fallback query MUST use `.limit(1)` with array access `data?.[0]`, NOT `.single()`. The `.single()` method throws PGRST116 on zero rows AND on multiple rows. `.limit(1)` returns an empty array gracefully.

CRITICAL: Do NOT set the cookie inside this function. Server components cannot set cookies -- only server actions can. This function will be called from server components.

Define the cookie name as a module-level constant: `const ACTIVE_BUSINESS_COOKIE = 'active_business_id'` and export it so `switchBusiness()` can import it.

Import `Business` type from `@/lib/types/database`.
Import `createClient` from `@/lib/supabase/server`.

**`getUserBusinesses(): Promise<Array<{ id: string; name: string }>>`**
1. Get authenticated user -- return `[]` if no user
2. Query `businesses` table: `.select('id, name').eq('user_id', user.id).order('created_at', { ascending: true })`
3. Return `data ?? []`

This function is used by the layout to populate the provider's businesses list.

Do NOT add `'use server'` directive -- this file contains data-fetching functions, not server actions. It uses `cookies()` which works fine in server component context.
  </action>
  <verify>
Run `pnpm typecheck` -- must pass with zero errors.
Visually verify the file imports `cookies` from `next/headers`, `createClient` from `@/lib/supabase/server`, and `Business` from `@/lib/types/database`.
Verify the fallback query uses `.limit(1)` and NOT `.single()`.
Verify no cookie-setting code exists in this file.
  </verify>
  <done>
`lib/data/active-business.ts` exists with `getActiveBusiness()`, `getUserBusinesses()`, and `ACTIVE_BUSINESS_COOKIE` exported. The resolver reads the cookie, verifies ownership, falls back to first business, and returns `null` only for zero-business users. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create switchBusiness() server action</name>
  <files>lib/actions/active-business.ts</files>
  <action>
Create `lib/actions/active-business.ts` with `'use server'` directive at the top.

**`switchBusiness(businessId: string): Promise<{ error?: string }>`**
1. Get authenticated user via `supabase.auth.getUser()` -- return `{ error: 'Not authenticated' }` if no user
2. Verify ownership: query `businesses` table with `.select('id').eq('id', businessId).eq('user_id', user.id).single()` -- return `{ error: 'Business not found' }` if null
3. Set the cookie via `await cookies()`:
   ```
   cookieStore.set({
     name: ACTIVE_BUSINESS_COOKIE,
     value: businessId,
     httpOnly: true,
     path: '/',
     sameSite: 'lax',
     secure: process.env.NODE_ENV === 'production',
     maxAge: 60 * 60 * 24 * 365,  // 1 year
   })
   ```
4. Call `revalidatePath('/', 'layout')` to trigger full re-render of all pages
5. Return `{}` (empty object = success)

Import `ACTIVE_BUSINESS_COOKIE` from `@/lib/data/active-business` to avoid duplicating the constant.
Import `cookies` from `next/headers`.
Import `createClient` from `@/lib/supabase/server`.
Import `revalidatePath` from `next/cache`.

NOTE: Using `.single()` here is CORRECT -- we are querying by primary key `id` with an ownership check, which always returns 0 or 1 rows. The `.single()` error on 0 rows is the desired behavior (business not found).

NOTE: Do NOT set `domain` on the cookie. The business context cookie only needs to work on the app subdomain, and defaulting to the current host is correct. This differs from the Supabase auth cookie which uses `.avisloop.com` for cross-subdomain SSO.
  </action>
  <verify>
Run `pnpm typecheck` -- must pass with zero errors.
Verify the file has `'use server'` at the top.
Verify the cookie is set with `httpOnly: true`.
Verify `revalidatePath('/', 'layout')` is called after setting the cookie.
  </verify>
  <done>
`lib/actions/active-business.ts` exists with `switchBusiness()` exported. The action validates authentication, verifies business ownership, sets an httpOnly cookie, and triggers a full layout re-render. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes with zero errors
2. `pnpm lint` passes with zero errors
3. `lib/data/active-business.ts` exports `getActiveBusiness`, `getUserBusinesses`, and `ACTIVE_BUSINESS_COOKIE`
4. `lib/actions/active-business.ts` exports `switchBusiness` and has `'use server'` directive
5. No existing files were modified (this plan only creates new files)
6. No `.single()` used in the fallback query of `getActiveBusiness()`
</verification>

<success_criteria>
- Two new files exist with correct exports
- getActiveBusiness() handles: valid cookie, invalid cookie, missing cookie, zero businesses
- switchBusiness() validates ownership before setting cookie
- Fallback uses .limit(1) not .single()
- Lint and typecheck pass
</success_criteria>

<output>
After completion, create `.planning/phases/52-multi-business-foundation/52-01-SUMMARY.md`
</output>
