---
phase: 11-bulk-send-resend-integrations
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/crypto/api-key.ts
  - lib/actions/api-key.ts
  - lib/validations/webhook.ts
  - lib/rate-limit.ts
  - app/api/webhooks/contacts/route.ts
  - components/settings/integrations-section.tsx
  - app/dashboard/settings/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can generate an API key from Settings and sees it exactly once"
    - "User can regenerate an API key (replaces the old one)"
    - "Webhook endpoint accepts POST with contact data authenticated via x-api-key header"
    - "Webhook deduplicates contacts by email using upsert"
    - "Webhook is rate limited at 60 requests per minute per API key"
  artifacts:
    - path: "lib/crypto/api-key.ts"
      provides: "API key generation and verification utilities"
      exports: ["generateApiKey", "verifyApiKey"]
    - path: "lib/actions/api-key.ts"
      provides: "Server action for generating API keys"
      exports: ["generateApiKeyAction"]
    - path: "app/api/webhooks/contacts/route.ts"
      provides: "Webhook endpoint for contact creation"
      exports: ["POST"]
    - path: "components/settings/integrations-section.tsx"
      provides: "Settings UI for API key management and webhook URL"
    - path: "lib/rate-limit.ts"
      provides: "webhookRatelimit added alongside existing sendRatelimit"
      contains: "webhookRatelimit"
  key_links:
    - from: "app/api/webhooks/contacts/route.ts"
      to: "lib/crypto/api-key.ts"
      via: "verifyApiKey for request authentication"
      pattern: "verifyApiKey"
    - from: "app/api/webhooks/contacts/route.ts"
      to: "lib/rate-limit.ts"
      via: "webhookRatelimit for per-key rate limiting"
      pattern: "webhookRatelimit"
    - from: "components/settings/integrations-section.tsx"
      to: "lib/actions/api-key.ts"
      via: "generateApiKeyAction call on button click"
      pattern: "generateApiKeyAction"
---

<objective>
Build the webhook API endpoint with API key authentication, rate limiting, and the Settings UI for managing API keys.

Purpose: Enables external integrations (Zapier, Make, n8n) to push contacts into AvisLoop via authenticated webhook, and gives users a self-service way to generate API keys.

Output: Webhook route, API key crypto utilities, rate limiter extension, Settings integrations section.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-bulk-send-resend-integrations/11-RESEARCH.md

@lib/rate-limit.ts
@lib/actions/business.ts
@lib/supabase/server.ts
@app/dashboard/settings/page.tsx
@app/api/webhooks/stripe/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: API key crypto utilities, webhook validation, and rate limiter</name>
  <files>lib/crypto/api-key.ts, lib/validations/webhook.ts, lib/rate-limit.ts</files>
  <action>
1. Create `lib/crypto/api-key.ts` with two functions:

   `generateApiKey()`:
   - Use `crypto.randomBytes(32)` to generate 32 random bytes
   - Convert to hex string (64 chars)
   - Prefix with `sk_` for identification: `sk_${hex}`
   - Generate random salt: `crypto.randomBytes(16).toString('hex')`
   - Hash using `crypto.scrypt` (promisified): `scryptAsync(hex, salt, 64)` - note: hash the raw hex, not the sk_ prefix
   - Return `{ key: 'sk_...', hash: '${salt}:${hashHex}' }`
   - Import: `import { randomBytes, scrypt, timingSafeEqual } from 'crypto'` and `import { promisify } from 'util'`
   - `const scryptAsync = promisify(scrypt)`

   `verifyApiKey(providedKey: string, storedHash: string)`:
   - Strip `sk_` prefix from providedKey
   - Split storedHash by `:` to get [salt, hash]
   - Hash providedKey with same salt using scryptAsync
   - Use `timingSafeEqual` to compare Buffer.from(hash, 'hex') with computed hash
   - Wrap in try/catch, return false on any error
   - Return boolean

   Mark file with `// server-only` comment at top since crypto is server-only.

2. Create `lib/validations/webhook.ts`:
   - Define `webhookContactSchema` using Zod:
     - `name`: string, min 1, max 200, trimmed
     - `email`: string, email format, transformed to lowercase and trimmed
     - `phone`: string, max 50, optional
   - Export the schema and its inferred type

3. Update `lib/rate-limit.ts`:
   - Add `webhookRatelimit` alongside existing `sendRatelimit`:
     ```typescript
     export const webhookRatelimit = redis
       ? new Ratelimit({
           redis,
           limiter: Ratelimit.slidingWindow(60, '1 m'),
           prefix: 'ratelimit:webhook',
         })
       : null
     ```
   - Add `checkWebhookRateLimit(identifier: string)` function following same pattern as `checkSendRateLimit`:
     - Returns `{ success, remaining, limit, reset }` from Upstash
     - Returns `{ success: true, remaining: 999, limit: 60, reset: 0 }` if not configured
  </action>
  <verify>Run `pnpm typecheck` - no errors in new files</verify>
  <done>API key generation/verification utilities exist, webhook schema validates contact payload, webhook rate limiter configured at 60/min</done>
</task>

<task type="auto">
  <name>Task 2: Webhook route, API key server action, and Settings integrations UI</name>
  <files>lib/actions/api-key.ts, app/api/webhooks/contacts/route.ts, components/settings/integrations-section.tsx, app/dashboard/settings/page.tsx</files>
  <action>
1. Create `lib/actions/api-key.ts` (server action):
   - `generateApiKeyAction()`:
     - Authenticate user via supabase.auth.getUser()
     - Get user's business
     - Call `generateApiKey()` from crypto utility
     - Store hash in businesses table: `await supabase.from('businesses').update({ api_key_hash: hash }).eq('id', business.id)`
     - NOTE: The `api_key_hash` column needs to exist. Add a Supabase migration SQL comment at the top of the file documenting that `ALTER TABLE businesses ADD COLUMN api_key_hash TEXT;` must be run. For now, use the service role client or rely on the column being added manually.
     - Actually, use the regular authenticated client since RLS allows business owners to update their own business.
     - Return the plaintext key (shown to user ONCE): `{ success: true, key: 'sk_...' }`
     - Revalidate '/dashboard/settings'
   - `hasApiKey()`:
     - Authenticate user, get business
     - Check if `api_key_hash` is not null
     - Return boolean
   - Export types: `ApiKeyActionState = { success?: boolean; key?: string; error?: string }`

2. Create `app/api/webhooks/contacts/route.ts` (Next.js Route Handler):
   - Export async `POST(request: Request)` function
   - Step 1: Extract `x-api-key` header. Return 401 if missing.
   - Step 2: Rate limit using `checkWebhookRateLimit(apiKey)`. Return 429 with rate limit headers (X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset) if limited.
   - Step 3: Look up business by verifying API key:
     - Use service role Supabase client (webhook is unauthenticated by session)
     - Query all businesses that have api_key_hash not null
     - For each business, call `verifyApiKey(apiKey, business.api_key_hash)`
     - Return the matching business, or 401 if none match
     - NOTE: This is a linear scan but acceptable for MVP (small number of businesses). Optimize later with key prefix lookup if needed.
   - Step 4: Parse request body with `webhookContactSchema`
     - Return 400 with validation errors if invalid
   - Step 5: Upsert contact:
     - Use service role client
     - `.upsert({ business_id, name, email (lowercased by schema), phone, status: 'active' }, { onConflict: 'business_id,email', ignoreDuplicates: false })`
     - `.select().single()`
   - Step 6: Return 200 with `{ success: true, contact: { id, name, email } }`
   - Handle errors: Return 500 with generic error message (don't leak DB details)
   - Import createClient from `@supabase/supabase-js` directly (NOT from lib/supabase/server which is cookie-based). Use: `import { createClient } from '@supabase/supabase-js'` with `process.env.NEXT_PUBLIC_SUPABASE_URL!` and `process.env.SUPABASE_SERVICE_ROLE_KEY!`

3. Create `components/settings/integrations-section.tsx` (client component):
   - 'use client' at top
   - Props: `{ hasExistingKey: boolean }`
   - State: `apiKey` (string | null), `isGenerating` (boolean), `copied` (string - 'key' | 'url' | null for copy feedback)
   - Display webhook URL: `${window.location.origin}/api/webhooks/contacts` with copy button
   - Generate/Regenerate API key button:
     - If no existing key: "Generate API Key" button
     - If has existing key: "Regenerate API Key" button with warning text "This will invalidate your current key"
     - On click: call `generateApiKeyAction()`, set apiKey state to returned key
   - When apiKey is set (just generated):
     - Show key in a monospace code block with copy button
     - Yellow warning: "Copy this key now. It won't be shown again."
   - Show usage instructions:
     - "Send a POST request with header `x-api-key: YOUR_KEY`"
     - Example curl command in a code block
     - Mention Zapier/Make compatibility
   - Use lucide-react icons: Key, Copy, Check, RefreshCw
   - Use Sonner toast for copy confirmation

4. Update `app/dashboard/settings/page.tsx`:
   - Import IntegrationsSection component
   - In SettingsContent, after the Email Templates section, add:
     ```tsx
     <section className="border rounded-lg p-6 bg-white shadow-sm">
       <h2 className="text-xl font-semibold mb-4">Integrations</h2>
       <p className="text-gray-600 mb-4">
         Connect external tools like Zapier or Make to automatically add contacts.
       </p>
       <IntegrationsSection hasExistingKey={!!business?.api_key_hash} />
     </section>
     ```
   - The business query already selects `*` so api_key_hash will be included (once column exists)

IMPORTANT DATABASE NOTE: This plan requires adding `api_key_hash TEXT` column to the businesses table. Add a migration file at `supabase/migrations/YYYYMMDDHHMMSS_add_api_key_hash.sql` with:
```sql
ALTER TABLE businesses ADD COLUMN IF NOT EXISTS api_key_hash TEXT;
```
Also need a unique constraint for webhook dedup: Check if `business_id,email` unique constraint exists on contacts table. If not, add:
```sql
ALTER TABLE contacts ADD CONSTRAINT contacts_business_id_email_unique UNIQUE (business_id, email);
```
Create the migration file as part of this task.
  </action>
  <verify>
- `pnpm typecheck` passes
- `pnpm lint` passes
- Migration file exists at supabase/migrations/
- Settings page renders without errors (check with `pnpm build` or dev server)
  </verify>
  <done>
- Webhook endpoint at /api/webhooks/contacts accepts POST with x-api-key auth
- Webhook validates payload, deduplicates by email, rate limits at 60/min
- Settings page has Integrations section with generate/regenerate API key
- API key shown once on generation with copy button
- Migration file adds api_key_hash column to businesses
  </done>
</task>

</tasks>

<verification>
- `pnpm typecheck` passes
- `pnpm lint` passes
- Migration SQL file exists
- API key generation produces `sk_` prefixed key
- verifyApiKey correctly validates against stored hash
- Webhook route returns 401 without key, 429 when rate limited, 200 on success
- Settings page shows Integrations section
</verification>

<success_criteria>
- User can generate API key from Settings (shown once, hashed in DB)
- User can regenerate (replaces old key)
- Webhook POST /api/webhooks/contacts creates/updates contacts
- Webhook authenticates via x-api-key header
- Webhook rate limited at 60/min per key
- Webhook deduplicates by business_id + email
- Settings shows webhook URL with copy button and usage instructions
</success_criteria>

<output>
After completion, create `.planning/phases/11-bulk-send-resend-integrations/11-02-SUMMARY.md`
</output>
