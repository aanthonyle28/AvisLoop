---
phase: 24-multi-touch-campaign-engine
plan: 06
type: execute
wave: 3
depends_on: [24-02, 24-03, 24-04]
files_modified:
  - app/api/cron/process-campaign-touches/route.ts
  - vercel.json
  - lib/utils/quiet-hours.ts
autonomous: true

must_haves:
  truths:
    - "Cron job runs every minute and processes due campaign touches"
    - "Touches are claimed atomically using claim_due_campaign_touches RPC"
    - "Channel-specific rate limiting prevents spam (100/hour per business per channel)"
    - "Quiet hours delay SMS touches to 8am next day"
  artifacts:
    - path: "app/api/cron/process-campaign-touches/route.ts"
      provides: "Cron endpoint for touch processing"
      contains: "claim_due_campaign_touches"
    - path: "vercel.json"
      provides: "Cron schedule configuration"
      contains: "process-campaign-touches"
    - path: "lib/utils/quiet-hours.ts"
      provides: "Timezone-aware quiet hours utility"
      exports: ["adjustForQuietHours", "isInQuietHours"]
  key_links:
    - from: "app/api/cron/process-campaign-touches/route.ts"
      to: "claim_due_campaign_touches RPC"
      via: "supabase.rpc call"
      pattern: "rpc\\('claim_due_campaign_touches'"
    - from: "app/api/cron/process-campaign-touches/route.ts"
      to: "@upstash/ratelimit"
      via: "rate limiter check"
      pattern: "Ratelimit"
---

<objective>
Create cron job for processing campaign touches with rate limiting and quiet hours.

Purpose: The engine that actually sends campaign messages. Claims due touches atomically, applies channel-specific rate limits, respects quiet hours, and updates enrollment state.

Output: Cron route, Vercel config update, and quiet hours utility.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/24-multi-touch-campaign-engine/24-RESEARCH.md
@.planning/phases/24-multi-touch-campaign-engine/24-CONTEXT.md
@app/api/cron/process-scheduled-sends/route.ts
@vercel.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create quiet hours utility</name>
  <files>lib/utils/quiet-hours.ts</files>
  <action>
Create lib/utils/quiet-hours.ts:

```typescript
import { getHours, setHours, setMinutes, addDays } from 'date-fns'
import { toZonedTime, fromZonedTime } from 'date-fns-tz'
import { QUIET_HOURS } from '@/lib/constants/campaigns'

/**
 * Check if a given time is within quiet hours in the specified timezone.
 * Quiet hours: 9pm - 8am (configurable via constants)
 */
export function isInQuietHours(
  utcTime: Date,
  timezone: string = 'America/New_York'
): boolean {
  try {
    // Convert UTC to customer's local time
    const localTime = toZonedTime(utcTime, timezone)
    const hour = getHours(localTime)

    // Quiet hours: after 9pm OR before 8am
    return hour >= QUIET_HOURS.start || hour < QUIET_HOURS.end
  } catch {
    // On invalid timezone, assume not in quiet hours (send anyway)
    return false
  }
}

/**
 * Adjust a scheduled time to respect quiet hours.
 * If the time falls in quiet hours, delay to next 8am.
 *
 * @param scheduledAt - UTC time when touch was originally scheduled
 * @param timezone - Customer's IANA timezone
 * @returns Adjusted UTC time (same time if not in quiet hours, or next 8am if in quiet hours)
 */
export function adjustForQuietHours(
  scheduledAt: Date,
  timezone: string = 'America/New_York'
): Date {
  if (!isInQuietHours(scheduledAt, timezone)) {
    return scheduledAt
  }

  try {
    // Convert to local time
    const localTime = toZonedTime(scheduledAt, timezone)
    const hour = getHours(localTime)

    // Set to 8am
    let nextWindow = setMinutes(setHours(localTime, QUIET_HOURS.end), 0)

    // If currently after 9pm, add a day to get to next morning
    if (hour >= QUIET_HOURS.start) {
      nextWindow = addDays(nextWindow, 1)
    }

    // Convert back to UTC
    return fromZonedTime(nextWindow, timezone)
  } catch {
    // On error, return original time
    return scheduledAt
  }
}

/**
 * Get the next available send window in a timezone.
 * Useful for UI display ("Will send at 8am tomorrow").
 */
export function getNextSendWindow(timezone: string = 'America/New_York'): Date {
  const now = new Date()

  if (!isInQuietHours(now, timezone)) {
    return now
  }

  return adjustForQuietHours(now, timezone)
}
```
  </action>
  <verify>`pnpm typecheck` passes; `grep "export function adjustForQuietHours" lib/utils/quiet-hours.ts` returns match</verify>
  <done>Quiet hours utility handles timezone-aware send window calculations</done>
</task>

<task type="auto">
  <name>Task 2: Create campaign touch processing cron</name>
  <files>app/api/cron/process-campaign-touches/route.ts</files>
  <action>
Create app/api/cron/process-campaign-touches/route.ts following process-scheduled-sends pattern:

```typescript
import { NextResponse } from 'next/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { Ratelimit } from '@upstash/ratelimit'
import { Redis } from '@upstash/redis'
import { resend, RESEND_FROM_EMAIL } from '@/lib/email/resend'
import { ReviewRequestEmail } from '@/lib/email/templates/review-request'
import { render } from '@react-email/render'
import { adjustForQuietHours } from '@/lib/utils/quiet-hours'
import { DEFAULT_EMAIL_RATE_LIMIT, DEFAULT_SMS_RATE_LIMIT } from '@/lib/constants/campaigns'
import type { ClaimedCampaignTouch } from '@/lib/types/database'

// Initialize rate limiters (lazy - only if Redis env vars present)
let emailRateLimiter: Ratelimit | null = null
let smsRateLimiter: Ratelimit | null = null

function getEmailRateLimiter(): Ratelimit | null {
  if (!process.env.UPSTASH_REDIS_REST_URL) return null
  if (!emailRateLimiter) {
    const redis = Redis.fromEnv()
    emailRateLimiter = new Ratelimit({
      redis,
      limiter: Ratelimit.slidingWindow(DEFAULT_EMAIL_RATE_LIMIT, '1 h'),
      analytics: true,
      prefix: 'ratelimit:campaign:email',
    })
  }
  return emailRateLimiter
}

function getSmsRateLimiter(): Ratelimit | null {
  if (!process.env.UPSTASH_REDIS_REST_URL) return null
  if (!smsRateLimiter) {
    const redis = Redis.fromEnv()
    smsRateLimiter = new Ratelimit({
      redis,
      limiter: Ratelimit.slidingWindow(DEFAULT_SMS_RATE_LIMIT, '1 h'),
      analytics: true,
      prefix: 'ratelimit:campaign:sms',
    })
  }
  return smsRateLimiter
}

export async function GET(request: Request) {
  // === 1. Authenticate via CRON_SECRET ===
  const authHeader = request.headers.get('Authorization')
  const cronSecret = process.env.CRON_SECRET

  if (!cronSecret) {
    console.error('CRON_SECRET not set')
    return NextResponse.json({ ok: false, error: 'Server configuration error' }, { status: 500 })
  }

  if (!authHeader || authHeader !== `Bearer ${cronSecret}`) {
    return NextResponse.json({ ok: false, error: 'Unauthorized' }, { status: 401 })
  }

  try {
    const supabase = createServiceRoleClient()

    // === 2. Claim due campaign touches ===
    const { data: claimedTouches, error: claimError } = await supabase
      .rpc('claim_due_campaign_touches', { limit_count: 100 })

    if (claimError) {
      console.error('Failed to claim touches:', claimError)
      return NextResponse.json({ ok: false, error: 'Failed to claim touches' }, { status: 500 })
    }

    if (!claimedTouches || claimedTouches.length === 0) {
      return NextResponse.json({
        ok: true,
        timestamp: new Date().toISOString(),
        claimed: 0,
        results: { processed: 0, sent: 0, skipped: 0, failed: 0, deferred: 0 },
      })
    }

    // === 3. Process each claimed touch ===
    let processed = 0
    let sent = 0
    let skipped = 0
    let failed = 0
    let deferred = 0

    for (const touch of claimedTouches as ClaimedCampaignTouch[]) {
      processed++

      try {
        // Fetch business and customer
        const [{ data: business }, { data: customer }] = await Promise.all([
          supabase
            .from('businesses')
            .select('id, name, google_review_link, default_sender_name')
            .eq('id', touch.business_id)
            .single(),
          supabase
            .from('customers')
            .select('id, name, email, phone, timezone, opted_out, sms_consent_status')
            .eq('id', touch.customer_id)
            .single(),
        ])

        if (!business || !customer) {
          await markTouchFailed(supabase, touch, 'Business or customer not found')
          failed++
          continue
        }

        // === 4. Check channel-specific requirements ===
        if (touch.channel === 'email') {
          if (customer.opted_out) {
            await markTouchSkipped(supabase, touch, 'opted_out_email')
            skipped++
            continue
          }
        }

        if (touch.channel === 'sms') {
          if (customer.sms_consent_status !== 'opted_in') {
            await markTouchSkipped(supabase, touch, 'no_sms_consent')
            skipped++
            continue
          }
          if (!customer.phone) {
            await markTouchSkipped(supabase, touch, 'no_phone')
            skipped++
            continue
          }
        }

        // === 5. Check quiet hours ===
        const scheduledAt = new Date(touch.scheduled_at)
        const adjustedTime = adjustForQuietHours(scheduledAt, customer.timezone || 'America/New_York')

        if (adjustedTime > new Date()) {
          // In quiet hours, defer to adjusted time
          // Update enrollment with new scheduled time (will be claimed again later)
          await supabase
            .from('campaign_enrollments')
            .update({
              [`touch_${touch.touch_number}_scheduled_at`]: adjustedTime.toISOString(),
            })
            .eq('id', touch.enrollment_id)

          deferred++
          continue
        }

        // === 6. Check rate limit ===
        const limiter = touch.channel === 'email' ? getEmailRateLimiter() : getSmsRateLimiter()
        if (limiter) {
          const { success: withinLimit } = await limiter.limit(`${touch.channel}:${touch.business_id}`)
          if (!withinLimit) {
            // Rate limited, will retry next minute
            deferred++
            continue
          }
        }

        // === 7. Send message ===
        if (touch.channel === 'email') {
          const sendResult = await sendEmailTouch(supabase, touch, business, customer)
          if (sendResult.success) {
            sent++
          } else {
            failed++
          }
        } else {
          // SMS - TODO: Implement in Phase 21
          // For now, mark as skipped with reason
          await markTouchSkipped(supabase, touch, 'sms_not_implemented')
          skipped++
        }

      } catch (error) {
        console.error(`Error processing touch ${touch.enrollment_id}:`, error)
        await markTouchFailed(supabase, touch, error instanceof Error ? error.message : 'Unknown error')
        failed++
      }
    }

    return NextResponse.json({
      ok: true,
      timestamp: new Date().toISOString(),
      claimed: claimedTouches.length,
      results: { processed, sent, skipped, failed, deferred },
    })

  } catch (error) {
    console.error('Cron handler error:', error)
    return NextResponse.json({ ok: false, error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * Send email touch and update enrollment state.
 */
async function sendEmailTouch(
  supabase: ReturnType<typeof createServiceRoleClient>,
  touch: ClaimedCampaignTouch,
  business: { id: string; name: string; google_review_link: string | null; default_sender_name: string | null },
  customer: { id: string; name: string; email: string }
): Promise<{ success: boolean; error?: string }> {
  if (!business.google_review_link) {
    await markTouchFailed(supabase, touch, 'No review link configured')
    return { success: false, error: 'No review link' }
  }

  // Fetch template if specified
  let subject = `${business.name} would love your feedback!`
  let templateBody: string | null = null

  if (touch.template_id) {
    const { data: template } = await supabase
      .from('message_templates')
      .select('subject, body')
      .eq('id', touch.template_id)
      .single()

    if (template) {
      subject = template.subject || subject
      templateBody = template.body
    }
  }

  // Create send_log entry
  const { data: sendLog, error: logError } = await supabase
    .from('send_logs')
    .insert({
      business_id: touch.business_id,
      customer_id: touch.customer_id,
      template_id: touch.template_id,
      campaign_id: touch.campaign_id,
      campaign_enrollment_id: touch.enrollment_id,
      touch_number: touch.touch_number,
      channel: 'email',
      status: 'pending',
      subject,
    })
    .select('id')
    .single()

  if (logError || !sendLog) {
    await markTouchFailed(supabase, touch, 'Failed to create send log')
    return { success: false, error: 'Send log creation failed' }
  }

  // Render and send email
  const senderName = business.default_sender_name || business.name

  const html = await render(
    ReviewRequestEmail({
      customerName: customer.name,
      businessName: business.name,
      reviewLink: business.google_review_link,
      senderName,
    })
  )

  const { data: emailData, error: emailError } = await resend.emails.send(
    {
      from: `${senderName} <${RESEND_FROM_EMAIL}>`,
      to: customer.email,
      subject,
      html,
      tags: [
        { name: 'send_log_id', value: sendLog.id },
        { name: 'business_id', value: touch.business_id },
        { name: 'campaign_id', value: touch.campaign_id },
        { name: 'enrollment_id', value: touch.enrollment_id },
        { name: 'touch_number', value: String(touch.touch_number) },
      ],
    },
    { idempotencyKey: `campaign-touch-${touch.enrollment_id}-${touch.touch_number}` }
  )

  // Update send_log
  await supabase
    .from('send_logs')
    .update({
      status: emailError ? 'failed' : 'sent',
      provider_id: emailData?.id || null,
      error_message: emailError?.message || null,
    })
    .eq('id', sendLog.id)

  if (emailError) {
    await markTouchFailed(supabase, touch, emailError.message)
    return { success: false, error: emailError.message }
  }

  // Update enrollment - mark touch sent and schedule next
  await updateEnrollmentAfterSend(supabase, touch)

  // Update customer tracking
  await supabase
    .from('customers')
    .update({
      last_sent_at: new Date().toISOString(),
      send_count: customer.send_count || 0 + 1,
    })
    .eq('id', touch.customer_id)

  return { success: true }
}

/**
 * Mark a touch as sent and schedule next touch.
 */
async function updateEnrollmentAfterSend(
  supabase: ReturnType<typeof createServiceRoleClient>,
  touch: ClaimedCampaignTouch
): Promise<void> {
  const now = new Date().toISOString()

  // Get next touch delay
  const { data: nextTouch } = await supabase
    .from('campaign_touches')
    .select('delay_hours')
    .eq('campaign_id', touch.campaign_id)
    .eq('touch_number', touch.touch_number + 1)
    .single()

  const updateData: Record<string, unknown> = {
    [`touch_${touch.touch_number}_sent_at`]: now,
    [`touch_${touch.touch_number}_status`]: 'sent',
    current_touch: touch.touch_number + 1,
    updated_at: now,
  }

  if (nextTouch) {
    // Schedule next touch relative to THIS touch's scheduled time (not sent time)
    const nextScheduledAt = new Date(
      new Date(touch.scheduled_at).getTime() + nextTouch.delay_hours * 60 * 60 * 1000
    ).toISOString()
    updateData[`touch_${touch.touch_number + 1}_scheduled_at`] = nextScheduledAt
    updateData[`touch_${touch.touch_number + 1}_status`] = 'pending'
  } else {
    // No more touches, mark enrollment completed
    updateData.status = 'completed'
    updateData.completed_at = now
  }

  await supabase
    .from('campaign_enrollments')
    .update(updateData)
    .eq('id', touch.enrollment_id)
}

/**
 * Mark touch as skipped and advance to next.
 */
async function markTouchSkipped(
  supabase: ReturnType<typeof createServiceRoleClient>,
  touch: ClaimedCampaignTouch,
  reason: string
): Promise<void> {
  console.log(`Touch skipped: ${touch.enrollment_id}/${touch.touch_number} - ${reason}`)

  // Schedule next touch even if this one skipped
  await updateEnrollmentAfterSend(supabase, touch)

  // Override the status to 'skipped' instead of 'sent'
  await supabase
    .from('campaign_enrollments')
    .update({
      [`touch_${touch.touch_number}_status`]: 'skipped',
    })
    .eq('id', touch.enrollment_id)
}

/**
 * Mark touch as failed and advance to next.
 */
async function markTouchFailed(
  supabase: ReturnType<typeof createServiceRoleClient>,
  touch: ClaimedCampaignTouch,
  error: string
): Promise<void> {
  console.error(`Touch failed: ${touch.enrollment_id}/${touch.touch_number} - ${error}`)

  // Schedule next touch even if this one failed
  await updateEnrollmentAfterSend(supabase, touch)

  // Override the status to 'failed' instead of 'sent'
  await supabase
    .from('campaign_enrollments')
    .update({
      [`touch_${touch.touch_number}_status`]: 'failed',
    })
    .eq('id', touch.enrollment_id)
}
```
  </action>
  <verify>`pnpm typecheck` passes; cron route file exists with claim_due_campaign_touches call</verify>
  <done>Cron endpoint processes due touches with rate limiting, quiet hours, and proper state management</done>
</task>

<task type="auto">
  <name>Task 3: Update vercel.json with new cron</name>
  <files>vercel.json</files>
  <action>
Read existing vercel.json and add campaign touch processing cron.

Add to the `crons` array:
```json
{
  "path": "/api/cron/process-campaign-touches",
  "schedule": "* * * * *"
}
```

The file should have both crons:
```json
{
  "crons": [
    {
      "path": "/api/cron/process-scheduled-sends",
      "schedule": "* * * * *"
    },
    {
      "path": "/api/cron/process-campaign-touches",
      "schedule": "* * * * *"
    }
  ]
}
```

Keep any other existing configuration in vercel.json.
  </action>
  <verify>`grep "process-campaign-touches" vercel.json` returns match</verify>
  <done>Vercel cron configured to run touch processing every minute</done>
</task>

</tasks>

<verification>
Run after all tasks:
1. `pnpm typecheck` - All new imports compile
2. `pnpm lint` - No lint errors
3. vercel.json has both cron endpoints
4. Cron route authenticates with CRON_SECRET
5. Touch claiming uses RPC with FOR UPDATE SKIP LOCKED
6. Rate limiting checked per-business per-channel
7. Quiet hours utility correctly identifies 9pm-8am window
</verification>

<success_criteria>
- [ ] Quiet hours utility exports adjustForQuietHours and isInQuietHours
- [ ] Cron route authenticates with CRON_SECRET header
- [ ] Touches claimed atomically via claim_due_campaign_touches RPC
- [ ] Channel-specific rate limits (100/hour) enforced
- [ ] Quiet hours defer SMS touches to 8am next day
- [ ] Email sending creates send_log with campaign attribution
- [ ] Next touch scheduled relative to previous scheduled_at (not sent_at)
- [ ] vercel.json includes new cron endpoint
- [ ] `pnpm typecheck` passes
</success_criteria>

<output>
After completion, create `.planning/phases/24-multi-touch-campaign-engine/24-06-SUMMARY.md`
</output>
