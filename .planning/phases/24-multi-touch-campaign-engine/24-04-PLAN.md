---
phase: 24-multi-touch-campaign-engine
plan: 04
type: execute
wave: 2
depends_on: [24-01]
files_modified:
  - lib/data/campaign.ts
  - lib/actions/campaign.ts
autonomous: true

must_haves:
  truths:
    - "Campaign CRUD functions fetch and mutate campaign data with RLS"
    - "duplicateCampaign creates editable copy from preset"
    - "Campaign status toggle (pause/resume) stops all active enrollments"
    - "Delete validation prevents deletion with active enrollments"
  artifacts:
    - path: "lib/data/campaign.ts"
      provides: "Campaign data fetching functions"
      exports: ["getCampaigns", "getCampaign", "getCampaignPresets", "getCampaignEnrollments"]
    - path: "lib/actions/campaign.ts"
      provides: "Campaign server actions"
      exports: ["createCampaign", "updateCampaign", "deleteCampaign", "duplicateCampaign", "toggleCampaignStatus"]
  key_links:
    - from: "lib/actions/campaign.ts"
      to: "campaign_enrollments"
      via: "status update on pause"
      pattern: "stop_reason.*campaign_paused"
    - from: "lib/data/campaign.ts"
      to: "campaign_touches"
      via: "Supabase join"
      pattern: "campaign_touches\\("
---

<objective>
Create data functions and server actions for campaign CRUD operations.

Purpose: Enable campaign management UI to create, read, update, delete campaigns with proper business scoping and enrollment lifecycle management.

Output: Data fetching functions and server actions following established patterns from message-template.ts.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/24-multi-touch-campaign-engine/24-RESEARCH.md
@.planning/phases/24-multi-touch-campaign-engine/24-CONTEXT.md
@lib/actions/message-template.ts
@lib/data/message-template.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create campaign data functions</name>
  <files>lib/data/campaign.ts</files>
  <action>
Create lib/data/campaign.ts following message-template.ts patterns:

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import type {
  Campaign,
  CampaignWithTouches,
  CampaignEnrollment,
  CampaignEnrollmentWithDetails,
  ServiceType,
} from '@/lib/types/database'

/**
 * Get all campaigns for current user's business, optionally filtered by service type.
 * Includes system presets (is_preset=true) which have business_id=NULL.
 */
export async function getCampaigns(
  options?: { serviceType?: ServiceType | null; includePresets?: boolean }
): Promise<CampaignWithTouches[]> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return []

  const { data: business } = await supabase
    .from('businesses')
    .select('id')
    .eq('user_id', user.id)
    .single()

  if (!business) return []

  let query = supabase
    .from('campaigns')
    .select(`
      *,
      campaign_touches (*)
    `)
    .order('created_at', { ascending: false })

  // Filter: business campaigns OR presets (if requested)
  if (options?.includePresets !== false) {
    query = query.or(`business_id.eq.${business.id},is_preset.eq.true`)
  } else {
    query = query.eq('business_id', business.id)
  }

  // Optional service type filter
  if (options?.serviceType !== undefined) {
    if (options.serviceType === null) {
      query = query.is('service_type', null)
    } else {
      query = query.eq('service_type', options.serviceType)
    }
  }

  const { data } = await query

  // Sort touches by touch_number
  return (data || []).map(campaign => ({
    ...campaign,
    campaign_touches: (campaign.campaign_touches || []).sort(
      (a, b) => a.touch_number - b.touch_number
    ),
  })) as CampaignWithTouches[]
}

/**
 * Get single campaign by ID with touches.
 */
export async function getCampaign(campaignId: string): Promise<CampaignWithTouches | null> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return null

  const { data } = await supabase
    .from('campaigns')
    .select(`
      *,
      campaign_touches (*)
    `)
    .eq('id', campaignId)
    .single()

  if (!data) return null

  return {
    ...data,
    campaign_touches: (data.campaign_touches || []).sort(
      (a, b) => a.touch_number - b.touch_number
    ),
  } as CampaignWithTouches
}

/**
 * Get system preset campaigns only.
 */
export async function getCampaignPresets(): Promise<CampaignWithTouches[]> {
  const supabase = await createClient()

  const { data } = await supabase
    .from('campaigns')
    .select(`
      *,
      campaign_touches (*)
    `)
    .eq('is_preset', true)
    .order('name')

  return (data || []).map(campaign => ({
    ...campaign,
    campaign_touches: (campaign.campaign_touches || []).sort(
      (a, b) => a.touch_number - b.touch_number
    ),
  })) as CampaignWithTouches[]
}

/**
 * Get enrollments for a campaign with customer and job details.
 */
export async function getCampaignEnrollments(
  campaignId: string,
  options?: { status?: 'active' | 'completed' | 'stopped'; limit?: number }
): Promise<CampaignEnrollmentWithDetails[]> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return []

  let query = supabase
    .from('campaign_enrollments')
    .select(`
      *,
      customers:customer_id (id, name, email, phone),
      jobs:job_id (id, service_type, completed_at),
      campaigns:campaign_id (id, name)
    `)
    .eq('campaign_id', campaignId)
    .order('enrolled_at', { ascending: false })

  if (options?.status) {
    query = query.eq('status', options.status)
  }

  if (options?.limit) {
    query = query.limit(options.limit)
  }

  const { data } = await query

  return (data || []) as CampaignEnrollmentWithDetails[]
}

/**
 * Get enrollment counts by status for a campaign (for quick stats).
 */
export async function getCampaignEnrollmentCounts(campaignId: string): Promise<{
  active: number
  completed: number
  stopped: number
}> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return { active: 0, completed: 0, stopped: 0 }

  const [activeResult, completedResult, stoppedResult] = await Promise.all([
    supabase
      .from('campaign_enrollments')
      .select('*', { count: 'exact', head: true })
      .eq('campaign_id', campaignId)
      .eq('status', 'active'),
    supabase
      .from('campaign_enrollments')
      .select('*', { count: 'exact', head: true })
      .eq('campaign_id', campaignId)
      .eq('status', 'completed'),
    supabase
      .from('campaign_enrollments')
      .select('*', { count: 'exact', head: true })
      .eq('campaign_id', campaignId)
      .eq('status', 'stopped'),
  ])

  return {
    active: activeResult.count || 0,
    completed: completedResult.count || 0,
    stopped: stoppedResult.count || 0,
  }
}

/**
 * Check if business has any active campaign (for enrollment logic).
 */
export async function getActiveCampaignForJob(
  businessId: string,
  serviceType: ServiceType
): Promise<CampaignWithTouches | null> {
  const supabase = await createClient()

  // Try to find campaign matching service type first, then fall back to "all services"
  const { data } = await supabase
    .from('campaigns')
    .select(`
      *,
      campaign_touches (*)
    `)
    .eq('business_id', businessId)
    .eq('status', 'active')
    .or(`service_type.eq.${serviceType},service_type.is.null`)
    .order('service_type', { ascending: false, nullsFirst: false })  // Specific match first
    .limit(1)
    .single()

  if (!data) return null

  return {
    ...data,
    campaign_touches: (data.campaign_touches || []).sort(
      (a, b) => a.touch_number - b.touch_number
    ),
  } as CampaignWithTouches
}
```
  </action>
  <verify>`pnpm typecheck` passes; `grep "export async function getCampaigns" lib/data/campaign.ts` returns match</verify>
  <done>Campaign data functions fetch campaigns, presets, enrollments with proper business scoping</done>
</task>

<task type="auto">
  <name>Task 2: Create campaign server actions</name>
  <files>lib/actions/campaign.ts</files>
  <action>
Create lib/actions/campaign.ts following message-template.ts patterns:

```typescript
'use server'

import { revalidatePath } from 'next/cache'
import { createClient } from '@/lib/supabase/server'
import { campaignWithTouchesSchema } from '@/lib/validations/campaign'
import type { CampaignWithTouchesFormData } from '@/lib/validations/campaign'
import type { CampaignWithTouches } from '@/lib/types/database'

type ActionState = {
  error?: string
  fieldErrors?: Record<string, string[]>
  success?: boolean
  data?: { campaignId: string }
}

/**
 * Create a new campaign with touches.
 */
export async function createCampaign(
  formData: CampaignWithTouchesFormData
): Promise<ActionState> {
  const supabase = await createClient()

  // Validate auth
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return { error: 'Not authenticated' }

  // Get business
  const { data: business } = await supabase
    .from('businesses')
    .select('id')
    .eq('user_id', user.id)
    .single()

  if (!business) return { error: 'Business not found' }

  // Validate form data
  const parsed = campaignWithTouchesSchema.safeParse(formData)
  if (!parsed.success) {
    return {
      error: 'Validation failed',
      fieldErrors: parsed.error.flatten().fieldErrors as Record<string, string[]>,
    }
  }

  const { touches, ...campaignData } = parsed.data

  // Insert campaign
  const { data: campaign, error: campaignError } = await supabase
    .from('campaigns')
    .insert({
      business_id: business.id,
      name: campaignData.name,
      service_type: campaignData.service_type,
      status: campaignData.status,
      is_preset: false,
    })
    .select('id')
    .single()

  if (campaignError) {
    if (campaignError.code === '23505') {
      // Unique constraint violation
      return { error: 'A campaign for this service type already exists' }
    }
    return { error: `Failed to create campaign: ${campaignError.message}` }
  }

  // Insert touches
  const touchInserts = touches.map(touch => ({
    campaign_id: campaign.id,
    touch_number: touch.touch_number,
    channel: touch.channel,
    delay_hours: touch.delay_hours,
    template_id: touch.template_id,
  }))

  const { error: touchError } = await supabase
    .from('campaign_touches')
    .insert(touchInserts)

  if (touchError) {
    // Rollback campaign on touch insert failure
    await supabase.from('campaigns').delete().eq('id', campaign.id)
    return { error: `Failed to create touches: ${touchError.message}` }
  }

  revalidatePath('/campaigns')
  return { success: true, data: { campaignId: campaign.id } }
}

/**
 * Update an existing campaign and its touches.
 */
export async function updateCampaign(
  campaignId: string,
  formData: CampaignWithTouchesFormData
): Promise<ActionState> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return { error: 'Not authenticated' }

  // Verify ownership and not preset
  const { data: existing } = await supabase
    .from('campaigns')
    .select('business_id, is_preset')
    .eq('id', campaignId)
    .single()

  if (!existing) return { error: 'Campaign not found' }
  if (existing.is_preset) return { error: 'Cannot edit preset campaigns. Duplicate first.' }

  // Validate form data
  const parsed = campaignWithTouchesSchema.safeParse(formData)
  if (!parsed.success) {
    return {
      error: 'Validation failed',
      fieldErrors: parsed.error.flatten().fieldErrors as Record<string, string[]>,
    }
  }

  const { touches, ...campaignData } = parsed.data

  // Update campaign
  const { error: campaignError } = await supabase
    .from('campaigns')
    .update({
      name: campaignData.name,
      service_type: campaignData.service_type,
      status: campaignData.status,
    })
    .eq('id', campaignId)

  if (campaignError) {
    return { error: `Failed to update campaign: ${campaignError.message}` }
  }

  // Replace touches (delete all, insert new)
  await supabase.from('campaign_touches').delete().eq('campaign_id', campaignId)

  const touchInserts = touches.map(touch => ({
    campaign_id: campaignId,
    touch_number: touch.touch_number,
    channel: touch.channel,
    delay_hours: touch.delay_hours,
    template_id: touch.template_id,
  }))

  const { error: touchError } = await supabase
    .from('campaign_touches')
    .insert(touchInserts)

  if (touchError) {
    return { error: `Failed to update touches: ${touchError.message}` }
  }

  revalidatePath('/campaigns')
  revalidatePath(`/campaigns/${campaignId}`)
  return { success: true, data: { campaignId } }
}

/**
 * Delete a campaign (only if no active enrollments).
 */
export async function deleteCampaign(campaignId: string): Promise<ActionState> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return { error: 'Not authenticated' }

  // Check for active enrollments
  const { count } = await supabase
    .from('campaign_enrollments')
    .select('*', { count: 'exact', head: true })
    .eq('campaign_id', campaignId)
    .eq('status', 'active')

  if (count && count > 0) {
    return { error: `Cannot delete: ${count} active enrollments. Stop them first.` }
  }

  // Verify not preset
  const { data: campaign } = await supabase
    .from('campaigns')
    .select('is_preset')
    .eq('id', campaignId)
    .single()

  if (campaign?.is_preset) {
    return { error: 'Cannot delete preset campaigns' }
  }

  // Delete (touches will cascade)
  const { error } = await supabase
    .from('campaigns')
    .delete()
    .eq('id', campaignId)

  if (error) {
    return { error: `Failed to delete: ${error.message}` }
  }

  revalidatePath('/campaigns')
  return { success: true }
}

/**
 * Duplicate a campaign (typically from preset).
 */
export async function duplicateCampaign(
  sourceCampaignId: string,
  newName?: string
): Promise<ActionState> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return { error: 'Not authenticated' }

  const { data: business } = await supabase
    .from('businesses')
    .select('id')
    .eq('user_id', user.id)
    .single()

  if (!business) return { error: 'Business not found' }

  // Fetch source campaign with touches
  const { data: source } = await supabase
    .from('campaigns')
    .select(`
      *,
      campaign_touches (*)
    `)
    .eq('id', sourceCampaignId)
    .single()

  if (!source) return { error: 'Source campaign not found' }

  // Create copy
  const { data: newCampaign, error: createError } = await supabase
    .from('campaigns')
    .insert({
      business_id: business.id,
      name: newName || `${source.name} (Copy)`,
      service_type: source.service_type,
      status: 'active',
      is_preset: false,
    })
    .select('id')
    .single()

  if (createError) {
    return { error: `Failed to duplicate: ${createError.message}` }
  }

  // Copy touches
  if (source.campaign_touches?.length) {
    const touchCopies = source.campaign_touches.map((t: { touch_number: number; channel: string; delay_hours: number; template_id: string | null }) => ({
      campaign_id: newCampaign.id,
      touch_number: t.touch_number,
      channel: t.channel,
      delay_hours: t.delay_hours,
      template_id: t.template_id,  // May be NULL for presets
    }))

    await supabase.from('campaign_touches').insert(touchCopies)
  }

  revalidatePath('/campaigns')
  return { success: true, data: { campaignId: newCampaign.id } }
}

/**
 * Toggle campaign status (pause/resume). Pausing stops all active enrollments.
 */
export async function toggleCampaignStatus(campaignId: string): Promise<ActionState> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return { error: 'Not authenticated' }

  // Get current status
  const { data: campaign } = await supabase
    .from('campaigns')
    .select('status, is_preset')
    .eq('id', campaignId)
    .single()

  if (!campaign) return { error: 'Campaign not found' }
  if (campaign.is_preset) return { error: 'Cannot modify preset campaigns' }

  const newStatus = campaign.status === 'active' ? 'paused' : 'active'

  // Update campaign status
  const { error } = await supabase
    .from('campaigns')
    .update({ status: newStatus })
    .eq('id', campaignId)

  if (error) {
    return { error: `Failed to update status: ${error.message}` }
  }

  // If pausing, stop all active enrollments
  if (newStatus === 'paused') {
    await supabase
      .from('campaign_enrollments')
      .update({
        status: 'stopped',
        stop_reason: 'campaign_paused',
        stopped_at: new Date().toISOString(),
      })
      .eq('campaign_id', campaignId)
      .eq('status', 'active')
  }

  revalidatePath('/campaigns')
  revalidatePath(`/campaigns/${campaignId}`)
  return { success: true }
}

/**
 * Stop a single enrollment manually.
 */
export async function stopEnrollment(enrollmentId: string): Promise<ActionState> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return { error: 'Not authenticated' }

  const { error } = await supabase
    .from('campaign_enrollments')
    .update({
      status: 'stopped',
      stop_reason: 'owner_stopped',
      stopped_at: new Date().toISOString(),
    })
    .eq('id', enrollmentId)
    .eq('status', 'active')

  if (error) {
    return { error: `Failed to stop enrollment: ${error.message}` }
  }

  revalidatePath('/campaigns')
  return { success: true }
}
```
  </action>
  <verify>`pnpm typecheck` passes; `grep "export async function createCampaign" lib/actions/campaign.ts` returns match</verify>
  <done>Campaign server actions handle CRUD, duplication, status toggle with enrollment lifecycle management</done>
</task>

</tasks>

<verification>
Run after all tasks:
1. `pnpm typecheck` - All imports and types compile
2. `pnpm lint` - No lint errors
3. Data functions return properly typed results
4. Actions handle preset protection (cannot edit/delete presets)
5. Pause action stops active enrollments
6. Delete action checks for active enrollments before proceeding
</verification>

<success_criteria>
- [ ] getCampaigns returns business campaigns + presets with nested touches
- [ ] getCampaignPresets returns system presets only
- [ ] getActiveCampaignForJob prioritizes service-type match over "all services"
- [ ] createCampaign validates and inserts campaign + touches atomically
- [ ] updateCampaign replaces touches on update
- [ ] deleteCampaign blocks if active enrollments exist
- [ ] duplicateCampaign creates editable copy from preset
- [ ] toggleCampaignStatus stops enrollments when pausing
- [ ] `pnpm typecheck` passes
</success_criteria>

<output>
After completion, create `.planning/phases/24-multi-touch-campaign-engine/24-04-SUMMARY.md`
</output>
