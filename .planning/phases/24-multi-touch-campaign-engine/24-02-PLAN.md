---
phase: 24-multi-touch-campaign-engine
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260204_claim_due_campaign_touches.sql
  - supabase/migrations/20260204_seed_campaign_presets.sql
autonomous: true

must_haves:
  truths:
    - "claim_due_campaign_touches RPC atomically claims due touches with FOR UPDATE SKIP LOCKED"
    - "3 system campaign presets exist (conservative, standard, aggressive)"
    - "Each preset has correct touch configuration (channels, timing, templates)"
  artifacts:
    - path: "supabase/migrations/20260204_claim_due_campaign_touches.sql"
      provides: "Atomic touch claiming RPC"
      contains: "FOR UPDATE SKIP LOCKED"
    - path: "supabase/migrations/20260204_seed_campaign_presets.sql"
      provides: "System preset campaigns"
      contains: "INSERT INTO campaigns"
  key_links:
    - from: "claim_due_campaign_touches"
      to: "campaign_enrollments"
      via: "SELECT FOR UPDATE SKIP LOCKED"
      pattern: "FROM campaign_enrollments"
    - from: "seed_campaign_presets"
      to: "campaigns + campaign_touches"
      via: "INSERT statements"
      pattern: "is_preset.*true"
---

<objective>
Create atomic touch claiming RPC and seed system campaign presets.

Purpose: The RPC enables race-safe cron processing (multiple workers can't claim same touch). The presets give users out-of-box campaign options matching CONTEXT.md requirements.

Output: Two migration files - one for claim_due_campaign_touches() function, one seeding 3 preset campaigns with their touch configurations.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/24-multi-touch-campaign-engine/24-RESEARCH.md
@.planning/phases/24-multi-touch-campaign-engine/24-CONTEXT.md
@supabase/migrations/00010_claim_due_scheduled_sends.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create claim_due_campaign_touches RPC</name>
  <files>supabase/migrations/20260204_claim_due_campaign_touches.sql</files>
  <action>
Create RPC function following existing claim_due_scheduled_sends pattern:

```sql
CREATE OR REPLACE FUNCTION claim_due_campaign_touches(limit_count INT DEFAULT 100)
RETURNS TABLE (
  enrollment_id UUID,
  business_id UUID,
  campaign_id UUID,
  job_id UUID,
  customer_id UUID,
  touch_number INT,
  channel TEXT,
  template_id UUID,
  scheduled_at TIMESTAMPTZ
) AS $$
```

**Logic:**
For each touch (1, 2, 3, 4), SELECT enrollments where:
- status = 'active'
- current_touch = touch_number
- touch_N_scheduled_at <= NOW()
- touch_N_sent_at IS NULL
- For touches 2-4: Previous touch sent (touch_N-1_sent_at IS NOT NULL) as guardrail

JOIN with campaign_touches to get channel and template_id for that touch.

Use `FOR UPDATE OF e SKIP LOCKED` to prevent race conditions.

UNION ALL the four touch queries.

ORDER BY scheduled_at ASC, LIMIT limit_count.

**Recovery function:**
```sql
CREATE OR REPLACE FUNCTION recover_stuck_campaign_touches(stale_minutes INT DEFAULT 10)
```

Reset enrollments where touch_N_status = 'processing' and updated_at > stale_minutes ago back to pending.

Note: The enrollment table doesn't have a 'processing' status currently - we track via touch_N_status instead. Simplify: if touch_N_status = 'pending' and updated_at is stale, it means cron crashed mid-claim. The FOR UPDATE SKIP LOCKED pattern handles this automatically since we don't actually set processing status.

**Simplification:** Skip recovery function since FOR UPDATE SKIP LOCKED + enrollment state machine handles crashed workers. If cron crashes after claiming but before updating, the touch remains claimable (scheduled_at still in past, sent_at still NULL).
  </action>
  <verify>Migration file contains claim_due_campaign_touches function with FOR UPDATE SKIP LOCKED and UNION ALL for 4 touches</verify>
  <done>Atomic touch claiming RPC prevents race conditions between concurrent cron workers</done>
</task>

<task type="auto">
  <name>Task 2: Seed 3 campaign presets with touches</name>
  <files>supabase/migrations/20260204_seed_campaign_presets.sql</files>
  <action>
Seed 3 system preset campaigns (business_id = NULL, is_preset = true):

**Conservative Preset:**
- Name: "Conservative (Email Only)"
- service_type: NULL (all services)
- Touches:
  - Touch 1: email, 24 hours delay
  - Touch 2: email, 72 hours delay (3 days after job)

**Standard Preset:**
- Name: "Standard (Email + SMS)"
- service_type: NULL (all services)
- Touches:
  - Touch 1: email, 24 hours delay
  - Touch 2: email, 72 hours delay
  - Touch 3: sms, 168 hours delay (7 days after job)

**Aggressive Preset:**
- Name: "Aggressive (Multi-Channel)"
- service_type: NULL (all services)
- Touches (SMS-first per CONTEXT.md):
  - Touch 1: sms, 4 hours delay (immediate follow-up)
  - Touch 2: email, 24 hours delay
  - Touch 3: sms, 72 hours delay
  - Touch 4: email, 168 hours delay

**Template references:**
Set template_id to NULL for all touches - users will select templates when they duplicate presets. Alternatively, reference system default templates by service type using subquery:
```sql
(SELECT id FROM message_templates WHERE is_default = true AND channel = 'email' AND service_type IS NULL LIMIT 1)
```

But since presets are for all service types and system templates are per-service-type, use NULL for template_id. Users must configure templates after duplicating.

**SQL Pattern:**
```sql
WITH conservative AS (
  INSERT INTO campaigns (id, business_id, name, service_type, status, is_preset)
  VALUES (gen_random_uuid(), NULL, 'Conservative (Email Only)', NULL, 'active', true)
  RETURNING id
)
INSERT INTO campaign_touches (campaign_id, touch_number, channel, delay_hours, template_id)
SELECT id, 1, 'email', 24, NULL FROM conservative
UNION ALL
SELECT id, 2, 'email', 72, NULL FROM conservative;
```

Repeat pattern for standard and aggressive presets.
  </action>
  <verify>`grep "is_preset" supabase/migrations/20260204_seed_campaign_presets.sql | wc -l` shows 3 preset inserts; verify all 3 campaign names present</verify>
  <done>3 campaign presets (conservative, standard, aggressive) seeded with appropriate touch configurations</done>
</task>

</tasks>

<verification>
Run after all tasks:
1. claim_due_campaign_touches function created with FOR UPDATE SKIP LOCKED
2. Function returns enrollment details plus channel and template_id from touches
3. All 3 presets exist with correct touch counts (2, 3, 4)
4. Presets have business_id = NULL and is_preset = true
</verification>

<success_criteria>
- [ ] claim_due_campaign_touches RPC handles all 4 touch positions atomically
- [ ] RPC uses FOR UPDATE SKIP LOCKED to prevent race conditions
- [ ] Conservative preset has 2 email touches
- [ ] Standard preset has 2 emails + 1 SMS
- [ ] Aggressive preset has 2 SMS + 2 emails (SMS first)
- [ ] All presets have is_preset = true and business_id = NULL
- [ ] Touch delays follow timing from CONTEXT.md
</success_criteria>

<output>
After completion, create `.planning/phases/24-multi-touch-campaign-engine/24-02-SUMMARY.md`
</output>
