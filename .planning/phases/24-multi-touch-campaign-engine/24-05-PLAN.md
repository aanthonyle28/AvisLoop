---
phase: 24-multi-touch-campaign-engine
plan: 05
type: execute
wave: 2
depends_on: [24-01]
files_modified:
  - lib/actions/enrollment.ts
  - lib/actions/job.ts
  - lib/validations/job.ts
autonomous: true

must_haves:
  truths:
    - "Job completion triggers campaign enrollment when checkbox is checked"
    - "Enrollment calculates touch 1 scheduled time from service type timing defaults"
    - "Repeat job cancels existing active enrollment before creating new one"
    - "Enrollment checks 30-day cooldown (configurable) before auto-enrolling"
  artifacts:
    - path: "lib/actions/enrollment.ts"
      provides: "Enrollment creation and management actions"
      exports: ["enrollJobInCampaign", "checkEnrollmentCooldown"]
    - path: "lib/actions/job.ts"
      provides: "Updated job actions with enrollment trigger"
      contains: "enrollInCampaign"
    - path: "lib/validations/job.ts"
      provides: "Job validation schema with enrollInCampaign field"
      contains: "enrollInCampaign"
  key_links:
    - from: "lib/actions/job.ts"
      to: "lib/actions/enrollment.ts"
      via: "function call on completion"
      pattern: "enrollJobInCampaign"
    - from: "lib/actions/enrollment.ts"
      to: "campaign_enrollments"
      via: "Supabase insert"
      pattern: "\\.insert.*campaign_enrollments"
    - from: "lib/actions/enrollment.ts"
      to: "businesses.service_type_timing"
      via: "Supabase join query"
      pattern: "service_type_timing"
---

<objective>
Create enrollment server actions and integrate with job completion flow.

Purpose: When a job is marked complete, automatically enroll it in the matching campaign (if user keeps checkbox checked). Handles repeat customer logic, cooldown period, and touch scheduling.

Output: Enrollment actions and updated job actions with enrollment trigger.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/24-multi-touch-campaign-engine/24-RESEARCH.md
@.planning/phases/24-multi-touch-campaign-engine/24-CONTEXT.md
@lib/actions/job.ts
@lib/data/campaign.ts
@lib/validations/job.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create enrollment server actions</name>
  <files>lib/actions/enrollment.ts</files>
  <action>
Create lib/actions/enrollment.ts:

```typescript
'use server'

import { revalidatePath } from 'next/cache'
import { createClient } from '@/lib/supabase/server'
import { getActiveCampaignForJob } from '@/lib/data/campaign'
import { DEFAULT_ENROLLMENT_COOLDOWN_DAYS } from '@/lib/constants/campaigns'
import type { ServiceType, CampaignEnrollment } from '@/lib/types/database'

type EnrollmentResult = {
  success: boolean
  enrollmentId?: string
  error?: string
  skipped?: boolean
  skipReason?: string
}

/**
 * Check if customer is within enrollment cooldown period.
 * Returns true if customer was enrolled in ANY campaign within cooldown days.
 */
export async function checkEnrollmentCooldown(
  customerId: string,
  cooldownDays: number = DEFAULT_ENROLLMENT_COOLDOWN_DAYS
): Promise<{ inCooldown: boolean; lastEnrolledAt?: string }> {
  const supabase = await createClient()

  const cooldownDate = new Date()
  cooldownDate.setDate(cooldownDate.getDate() - cooldownDays)

  const { data } = await supabase
    .from('campaign_enrollments')
    .select('enrolled_at')
    .eq('customer_id', customerId)
    .gte('enrolled_at', cooldownDate.toISOString())
    .order('enrolled_at', { ascending: false })
    .limit(1)
    .single()

  return {
    inCooldown: !!data,
    lastEnrolledAt: data?.enrolled_at,
  }
}

/**
 * Cancel any active enrollments for a customer (for repeat job handling).
 */
async function cancelActiveEnrollments(
  supabase: ReturnType<typeof import('@/lib/supabase/server').createClient> extends Promise<infer T> ? T : never,
  customerId: string
): Promise<number> {
  const { data } = await supabase
    .from('campaign_enrollments')
    .update({
      status: 'stopped',
      stop_reason: 'repeat_job',
      stopped_at: new Date().toISOString(),
    })
    .eq('customer_id', customerId)
    .eq('status', 'active')
    .select('id')

  return data?.length || 0
}

/**
 * Enroll a completed job in its matching campaign.
 *
 * Flow:
 * 1. Find active campaign for job's service type (or "all services" fallback)
 * 2. Check cooldown period
 * 3. Cancel any active enrollments for same customer (repeat job)
 * 4. Calculate touch 1 scheduled time using service type timing defaults from businesses.service_type_timing
 * 5. Create enrollment record
 *
 * IMPORTANT: This function fetches service_type_timing from the business record via the job query.
 * The timing is used to calculate the delay for touch 1 (SVCT-03 requirement).
 */
export async function enrollJobInCampaign(
  jobId: string,
  options?: {
    forceCooldownOverride?: boolean
    campaignId?: string  // Optional: specify campaign instead of auto-detect
  }
): Promise<EnrollmentResult> {
  const supabase = await createClient()

  // Fetch job with business (including service_type_timing) and customer info
  // The service_type_timing from businesses is used to determine touch 1 delay
  const { data: job, error: jobError } = await supabase
    .from('jobs')
    .select(`
      id,
      business_id,
      customer_id,
      service_type,
      completed_at,
      status,
      businesses:business_id (
        id,
        service_type_timing
      )
    `)
    .eq('id', jobId)
    .single()

  if (jobError || !job) {
    return { success: false, error: 'Job not found' }
  }

  if (job.status !== 'completed') {
    return { success: false, error: 'Job must be completed to enroll' }
  }

  // Find matching campaign
  let campaign
  if (options?.campaignId) {
    const { data } = await supabase
      .from('campaigns')
      .select(`
        *,
        campaign_touches (*)
      `)
      .eq('id', options.campaignId)
      .eq('status', 'active')
      .single()
    campaign = data
  } else {
    campaign = await getActiveCampaignForJob(job.business_id, job.service_type as ServiceType)
  }

  if (!campaign) {
    return {
      success: false,
      skipped: true,
      skipReason: 'No active campaign for this service type'
    }
  }

  // Check cooldown (unless forced)
  if (!options?.forceCooldownOverride) {
    const { inCooldown, lastEnrolledAt } = await checkEnrollmentCooldown(job.customer_id)
    if (inCooldown) {
      return {
        success: false,
        skipped: true,
        skipReason: `Customer enrolled recently (${lastEnrolledAt}). Cooldown active.`,
      }
    }
  }

  // Cancel any existing active enrollments for this customer (repeat job handling)
  const cancelledCount = await cancelActiveEnrollments(supabase, job.customer_id)

  // Calculate touch 1 scheduled time
  const touch1 = campaign.campaign_touches?.find((t: { touch_number: number }) => t.touch_number === 1)
  if (!touch1) {
    return { success: false, error: 'Campaign has no touch 1 configured' }
  }

  // SVCT-03: Use service type timing from business settings if available
  // This is fetched above in the job query via businesses.service_type_timing
  const businessTiming = (job.businesses as { service_type_timing?: Record<string, number> })?.service_type_timing
  const defaultDelayHours = businessTiming?.[job.service_type] || touch1.delay_hours

  const touch1ScheduledAt = new Date(Date.now() + defaultDelayHours * 60 * 60 * 1000)

  // Create enrollment
  const { data: enrollment, error: enrollError } = await supabase
    .from('campaign_enrollments')
    .insert({
      business_id: job.business_id,
      campaign_id: campaign.id,
      job_id: jobId,
      customer_id: job.customer_id,
      status: 'active',
      current_touch: 1,
      touch_1_scheduled_at: touch1ScheduledAt.toISOString(),
      touch_1_status: 'pending',
      enrolled_at: new Date().toISOString(),
    })
    .select('id')
    .single()

  if (enrollError) {
    // Handle unique constraint (already enrolled)
    if (enrollError.code === '23505') {
      return {
        success: false,
        skipped: true,
        skipReason: 'Customer already has active enrollment for this campaign'
      }
    }
    return { success: false, error: `Failed to enroll: ${enrollError.message}` }
  }

  revalidatePath('/campaigns')
  revalidatePath('/jobs')

  return {
    success: true,
    enrollmentId: enrollment.id,
  }
}

/**
 * Manually enroll a job (from dashboard or job detail).
 * Skips cooldown check - user explicitly chose to enroll.
 */
export async function manuallyEnrollJob(
  jobId: string,
  campaignId: string
): Promise<EnrollmentResult> {
  return enrollJobInCampaign(jobId, {
    forceCooldownOverride: true,
    campaignId,
  })
}
```
  </action>
  <verify>`pnpm typecheck` passes; `grep "export async function enrollJobInCampaign" lib/actions/enrollment.ts` returns match</verify>
  <done>Enrollment actions handle auto-enrollment with cooldown checks, repeat job handling, and timing calculation using business's service_type_timing</done>
</task>

<task type="auto">
  <name>Task 2: Update job validation schema and actions with enrollment trigger</name>
  <files>lib/validations/job.ts, lib/actions/job.ts</files>
  <action>
**Part A: Update lib/validations/job.ts**

Add `enrollInCampaign` field to the jobSchema:

```typescript
// Add to the jobSchema object:
enrollInCampaign: z.boolean().optional().default(true)
```

The full schema should now include:
```typescript
export const jobSchema = z.object({
  customerId: z
    .string()
    .uuid('Please select a valid customer'),
  serviceType: z.enum(SERVICE_TYPES),
  status: z
    .enum(JOB_STATUSES)
    .default('completed'),
  notes: z
    .string()
    .max(1000, 'Notes must be under 1000 characters')
    .optional()
    .or(z.literal('')),
  enrollInCampaign: z.boolean().optional().default(true),
})
```

**Part B: Update lib/actions/job.ts**

1. Add import at top:
```typescript
import { enrollJobInCampaign } from '@/lib/actions/enrollment'
```

2. Update the job update/create functions that set status to 'completed':

Find the function that updates job status (likely `updateJob` or similar). When status changes to 'completed':

```typescript
// After job update succeeds and status is 'completed'
if (formData.status === 'completed' && formData.enrollInCampaign !== false) {
  // enrollInCampaign defaults to true if not specified
  // enrollJobInCampaign handles:
  // - Finding matching campaign (service-type specific or "all services")
  // - Checking 30-day cooldown
  // - Canceling existing enrollments (repeat job)
  // - Calculating touch 1 timing from business's service_type_timing (SVCT-03)
  const enrollResult = await enrollJobInCampaign(jobId)

  // Don't fail the job update if enrollment fails - just log
  if (!enrollResult.success && !enrollResult.skipped) {
    console.warn('Enrollment failed:', enrollResult.error)
  }
}
```

3. If there's a `markJobComplete` helper function, ensure it accepts and uses the enrollInCampaign parameter.

**Key behaviors:**
- Enrollment is async but non-blocking (job update succeeds even if enrollment fails)
- Default behavior is to enroll (checkbox on by default)
- If enrollInCampaign is explicitly false, skip enrollment
- Cooldown, campaign matching, and service_type_timing lookup happen in enrollJobInCampaign (Task 1)
- The service_type_timing from businesses table is automatically applied by enrollJobInCampaign
  </action>
  <verify>`pnpm typecheck` passes; `grep "enrollJobInCampaign" lib/actions/job.ts` returns match; `grep "enrollInCampaign" lib/validations/job.ts` returns match</verify>
  <done>Job completion triggers campaign enrollment when checkbox is checked (default: on), with service_type_timing applied via enrollJobInCampaign</done>
</task>

</tasks>

<verification>
Run after all tasks:
1. `pnpm typecheck` - All new imports and types compile
2. `pnpm lint` - No lint errors
3. Job actions correctly import and call enrollment functions
4. enrollJobInCampaign calculates correct touch 1 timing using business's service_type_timing
5. Repeat job cancels old enrollment before creating new
6. Validation schema includes enrollInCampaign field
</verification>

<success_criteria>
- [ ] enrollJobInCampaign finds matching campaign (service-type specific or "all")
- [ ] Cooldown check prevents over-messaging repeat customers
- [ ] Repeat job handling cancels old enrollment with 'repeat_job' reason
- [ ] Touch 1 scheduled time uses business's service_type_timing defaults (SVCT-03)
- [ ] Job update action triggers enrollment when status becomes 'completed'
- [ ] enrollInCampaign checkbox defaults to true
- [ ] manuallyEnrollJob bypasses cooldown for explicit user action
- [ ] lib/validations/job.ts includes enrollInCampaign field
- [ ] `pnpm typecheck` passes
</success_criteria>

<output>
After completion, create `.planning/phases/24-multi-touch-campaign-engine/24-05-SUMMARY.md`
</output>
