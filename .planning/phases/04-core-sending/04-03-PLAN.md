---
phase: 04-core-sending
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - lib/actions/send.ts
  - lib/data/send-logs.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can send review request email to a contact"
    - "System creates send_log before calling email API"
    - "System enforces 14-day cooldown per contact"
    - "System enforces monthly send limits by tier"
    - "System respects contact opt-out status"
    - "System updates contact.last_sent_at and send_count after send"
  artifacts:
    - path: "lib/actions/send.ts"
      provides: "Server Action for sending review requests"
      exports: ["sendReviewRequest", "SendActionState"]
    - path: "lib/data/send-logs.ts"
      provides: "Data fetching for send history"
      exports: ["getSendLogs", "getMonthlyCount"]
  key_links:
    - from: "lib/actions/send.ts"
      to: "lib/email/resend.ts"
      via: "import resend"
      pattern: "import.*resend.*from"
    - from: "lib/actions/send.ts"
      to: "lib/rate-limit.ts"
      via: "import checkSendRateLimit"
      pattern: "checkSendRateLimit"
    - from: "lib/actions/send.ts"
      to: "supabase.from('send_logs')"
      via: "database insert/update"
      pattern: "from\\('send_logs'\\)"
---

<objective>
Create Server Action for sending review request emails with comprehensive validation checks.

Purpose: Enable users to send emails while enforcing business rules (cooldowns, limits, opt-outs, rate limits).
Output: Complete send flow with logging, error handling, and contact tracking updates.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-sending/04-RESEARCH.md
@.planning/phases/04-core-sending/04-01-SUMMARY.md
@.planning/phases/04-core-sending/04-02-SUMMARY.md

@lib/actions/contact.ts
@lib/actions/business.ts
@lib/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create send Server Action with all validations</name>
  <files>lib/actions/send.ts</files>
  <action>
Create lib/actions/send.ts following the established Server Action patterns:

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { render } from '@react-email/render'
import { resend } from '@/lib/email/resend'
import { ReviewRequestEmail } from '@/lib/email/templates/review-request'
import { checkSendRateLimit } from '@/lib/rate-limit'
import { sendRequestSchema } from '@/lib/validations/send'

// Constants
const COOLDOWN_DAYS = 14
const MONTHLY_LIMITS: Record<string, number> = {
  trial: 25,
  basic: 200,
  pro: 500,
}

export type SendActionState = {
  error?: string
  fieldErrors?: Record<string, string[]>
  success?: boolean
  data?: { sendLogId: string }
}

/**
 * Send a review request email to a contact.
 * Implements all business rules: auth, rate limit, cooldown, opt-out, monthly limit.
 *
 * Flow:
 * 1. Authenticate user
 * 2. Rate limit check (per-user)
 * 3. Get business + contact + template
 * 4. Check cooldown (14 days since last send)
 * 5. Check opt-out status
 * 6. Check monthly limit
 * 7. Create send_log (status: 'pending')
 * 8. Send via Resend
 * 9. Update send_log (status: 'sent' or 'failed')
 * 10. Update contact tracking fields
 */
export async function sendReviewRequest(
  _prevState: SendActionState | null,
  formData: FormData
): Promise<SendActionState> {
  const supabase = await createClient()

  // === 1. Authenticate user ===
  const { data: { user }, error: authError } = await supabase.auth.getUser()
  if (authError || !user) {
    return { error: 'You must be logged in to send review requests' }
  }

  // === 2. Rate limit check ===
  const rateLimitResult = await checkSendRateLimit(user.id)
  if (!rateLimitResult.success) {
    return { error: 'Rate limit exceeded. Please wait before sending more emails.' }
  }

  // === Parse and validate input ===
  const parsed = sendRequestSchema.safeParse({
    contactId: formData.get('contactId'),
    templateId: formData.get('templateId') || undefined,
    customSubject: formData.get('customSubject') || undefined,
    customBody: formData.get('customBody') || undefined,
  })

  if (!parsed.success) {
    return { fieldErrors: parsed.error.flatten().fieldErrors }
  }

  const { contactId, templateId, customSubject } = parsed.data

  // === 3. Get business ===
  const { data: business, error: businessError } = await supabase
    .from('businesses')
    .select('id, name, google_review_link, default_sender_name, tier')
    .eq('user_id', user.id)
    .single()

  if (businessError || !business) {
    return { error: 'Please create a business profile first' }
  }

  if (!business.google_review_link) {
    return { error: 'Please add your Google review link in settings before sending' }
  }

  // === Get contact ===
  const { data: contact, error: contactError } = await supabase
    .from('contacts')
    .select('id, name, email, status, opted_out, last_sent_at, send_count')
    .eq('id', contactId)
    .eq('business_id', business.id) // Security: ensure contact belongs to this business
    .single()

  if (contactError || !contact) {
    return { error: 'Contact not found' }
  }

  // === 4. Check cooldown ===
  if (contact.last_sent_at) {
    const lastSent = new Date(contact.last_sent_at)
    const cooldownEnd = new Date(lastSent.getTime() + COOLDOWN_DAYS * 24 * 60 * 60 * 1000)

    if (new Date() < cooldownEnd) {
      const daysRemaining = Math.ceil((cooldownEnd.getTime() - Date.now()) / (24 * 60 * 60 * 1000))
      return {
        error: `Please wait ${daysRemaining} more day${daysRemaining === 1 ? '' : 's'} before sending to this contact again`
      }
    }
  }

  // === 5. Check opt-out ===
  if (contact.opted_out) {
    return { error: 'This contact has opted out of receiving review requests' }
  }

  if (contact.status === 'archived') {
    return { error: 'Cannot send to archived contacts' }
  }

  // === 6. Check monthly limit ===
  const monthlyLimit = MONTHLY_LIMITS[business.tier] || MONTHLY_LIMITS.basic
  const { count: monthlyCount } = await getMonthlyCount(supabase, business.id)

  if (monthlyCount >= monthlyLimit) {
    return {
      error: `Monthly send limit reached (${monthlyLimit}). Upgrade your plan for more sends.`
    }
  }

  // === Get template (optional - fall back to default) ===
  let subject: string
  let template: { name: string; subject: string; body: string } | null = null

  if (templateId) {
    const { data: tpl } = await supabase
      .from('email_templates')
      .select('name, subject, body')
      .eq('id', templateId)
      .eq('business_id', business.id)
      .single()
    template = tpl
  }

  // Use custom subject or template subject or default
  subject = customSubject || template?.subject || `${business.name} would love your feedback!`

  // === 7. Create send_log (status: 'pending') BEFORE calling API ===
  const { data: sendLog, error: logError } = await supabase
    .from('send_logs')
    .insert({
      business_id: business.id,
      contact_id: contactId,
      template_id: templateId || null,
      status: 'pending',
      subject,
    })
    .select('id')
    .single()

  if (logError || !sendLog) {
    return { error: 'Failed to create send log' }
  }

  // === 8. Render email and send via Resend ===
  const senderName = business.default_sender_name || business.name

  const html = await render(
    ReviewRequestEmail({
      customerName: contact.name,
      businessName: business.name,
      reviewLink: business.google_review_link,
      senderName,
    })
  )

  const { data: emailData, error: emailError } = await resend.emails.send(
    {
      from: `${senderName} <reviews@avisloop.com>`, // Platform domain for MVP
      to: contact.email,
      subject,
      html,
      tags: [
        { name: 'send_log_id', value: sendLog.id },
        { name: 'business_id', value: business.id },
      ],
    },
    { idempotencyKey: `send-${sendLog.id}` }
  )

  // === 9. Update send_log with result ===
  await supabase
    .from('send_logs')
    .update({
      status: emailError ? 'failed' : 'sent',
      provider_id: emailData?.id || null,
      error_message: emailError?.message || null,
    })
    .eq('id', sendLog.id)

  if (emailError) {
    return { error: `Failed to send email: ${emailError.message}` }
  }

  // === 10. Update contact tracking fields ===
  await supabase
    .from('contacts')
    .update({
      last_sent_at: new Date().toISOString(),
      send_count: (contact.send_count || 0) + 1,
    })
    .eq('id', contactId)

  revalidatePath('/dashboard/contacts')
  revalidatePath('/dashboard/send')

  return { success: true, data: { sendLogId: sendLog.id } }
}

/**
 * Helper to get monthly send count for a business.
 * Counts sends from the first of the current month.
 */
async function getMonthlyCount(
  supabase: Awaited<ReturnType<typeof createClient>>,
  businessId: string
): Promise<{ count: number }> {
  const startOfMonth = new Date()
  startOfMonth.setDate(1)
  startOfMonth.setHours(0, 0, 0, 0)

  const { count } = await supabase
    .from('send_logs')
    .select('*', { count: 'exact', head: true })
    .eq('business_id', businessId)
    .gte('created_at', startOfMonth.toISOString())
    .in('status', ['sent', 'delivered', 'opened']) // Only count successful sends

  return { count: count || 0 }
}
```

Key implementation details:
- Uses `'use server'` directive
- Pattern matches contact.ts and business.ts (getUser, safeParse, revalidatePath)
- Creates send_log BEFORE API call (audit trail even on failures)
- Uses idempotency key to prevent duplicate sends
- Tags emails for webhook correlation
- Comprehensive error messages for each failure mode
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors; exports sendReviewRequest and SendActionState</verify>
  <done>Send Server Action complete with auth, rate limiting, cooldown, opt-out, monthly limit checks, logging, and contact updates</done>
</task>

<task type="auto">
  <name>Task 2: Create send log data fetching functions</name>
  <files>lib/data/send-logs.ts</files>
  <action>
Create lib/data/send-logs.ts for Server Component data fetching:

```typescript
import { createClient } from '@/lib/supabase/server'
import type { SendLogWithContact } from '@/lib/types/database'

/**
 * Get send logs for the current user's business.
 * For Server Components - handles auth internally.
 */
export async function getSendLogs(options?: {
  limit?: number
  offset?: number
  contactId?: string
}): Promise<{ logs: SendLogWithContact[]; total: number }> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { logs: [], total: 0 }
  }

  // Get user's business
  const { data: business } = await supabase
    .from('businesses')
    .select('id')
    .eq('user_id', user.id)
    .single()

  if (!business) {
    return { logs: [], total: 0 }
  }

  const limit = options?.limit ?? 50
  const offset = options?.offset ?? 0

  // Build query
  let query = supabase
    .from('send_logs')
    .select('*, contacts!inner(name, email)', { count: 'exact' })
    .eq('business_id', business.id)
    .order('created_at', { ascending: false })

  if (options?.contactId) {
    query = query.eq('contact_id', options.contactId)
  }

  query = query.range(offset, offset + limit - 1)

  const { data, count, error } = await query

  if (error) {
    console.error('Error fetching send logs:', error)
    return { logs: [], total: 0 }
  }

  return {
    logs: data as SendLogWithContact[],
    total: count || 0,
  }
}

/**
 * Get monthly send count for usage display.
 */
export async function getMonthlyUsage(): Promise<{
  count: number
  limit: number
  tier: string
}> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { count: 0, limit: 0, tier: 'none' }
  }

  const { data: business } = await supabase
    .from('businesses')
    .select('id, tier')
    .eq('user_id', user.id)
    .single()

  if (!business) {
    return { count: 0, limit: 0, tier: 'none' }
  }

  const startOfMonth = new Date()
  startOfMonth.setDate(1)
  startOfMonth.setHours(0, 0, 0, 0)

  const { count } = await supabase
    .from('send_logs')
    .select('*', { count: 'exact', head: true })
    .eq('business_id', business.id)
    .gte('created_at', startOfMonth.toISOString())
    .in('status', ['sent', 'delivered', 'opened'])

  const limits: Record<string, number> = {
    trial: 25,
    basic: 200,
    pro: 500,
  }

  return {
    count: count || 0,
    limit: limits[business.tier] || limits.basic,
    tier: business.tier,
  }
}

/**
 * Get send stats for a specific contact.
 */
export async function getContactSendStats(contactId: string): Promise<{
  totalSent: number
  lastSentAt: string | null
  canSend: boolean
  cooldownEnds: string | null
}> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { totalSent: 0, lastSentAt: null, canSend: false, cooldownEnds: null }
  }

  const { data: contact } = await supabase
    .from('contacts')
    .select('last_sent_at, send_count, opted_out, status')
    .eq('id', contactId)
    .single()

  if (!contact) {
    return { totalSent: 0, lastSentAt: null, canSend: false, cooldownEnds: null }
  }

  const COOLDOWN_DAYS = 14
  let canSend = contact.status === 'active' && !contact.opted_out
  let cooldownEnds: string | null = null

  if (contact.last_sent_at) {
    const lastSent = new Date(contact.last_sent_at)
    const cooldownEnd = new Date(lastSent.getTime() + COOLDOWN_DAYS * 24 * 60 * 60 * 1000)

    if (new Date() < cooldownEnd) {
      canSend = false
      cooldownEnds = cooldownEnd.toISOString()
    }
  }

  return {
    totalSent: contact.send_count || 0,
    lastSentAt: contact.last_sent_at,
    canSend,
    cooldownEnds,
  }
}
```
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors; exports getSendLogs, getMonthlyUsage, getContactSendStats</verify>
  <done>Data fetching functions for send history, usage stats, and contact send eligibility</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes without errors
2. lib/actions/send.ts exports sendReviewRequest and SendActionState
3. lib/data/send-logs.ts exports getSendLogs, getMonthlyUsage, getContactSendStats
4. sendReviewRequest implements all 10 steps from flow
5. All validation checks present: auth, rate limit, cooldown, opt-out, monthly limit
6. send_log created BEFORE API call
7. Contact tracking fields updated after successful send
</verification>

<success_criteria>
- sendReviewRequest Server Action validates all business rules
- Creates audit trail before sending
- Updates send_log status after API response
- Updates contact.last_sent_at and send_count on success
- Returns appropriate error messages for each failure mode
- Data fetching functions ready for UI components
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-sending/04-03-SUMMARY.md`
</output>
