---
phase: 04-core-sending
plan: 04
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - app/api/webhooks/resend/route.ts
autonomous: true
user_setup:
  - service: resend
    why: "Webhook endpoint configuration"
    dashboard_config:
      - task: "Add webhook endpoint"
        location: "Resend Dashboard -> Webhooks -> Add Webhook"
        details: "URL: https://your-domain/api/webhooks/resend, Events: email.delivered, email.bounced, email.complained, email.opened"
    env_vars:
      - name: RESEND_WEBHOOK_SECRET
        source: "Resend Dashboard -> Webhooks -> Signing Secret"

must_haves:
  truths:
    - "Webhook endpoint validates Resend signatures"
    - "Delivered emails update send_log status to 'delivered'"
    - "Bounced emails update send_log status and opt-out contact"
    - "Complained emails update send_log status and opt-out contact"
  artifacts:
    - path: "app/api/webhooks/resend/route.ts"
      provides: "Webhook handler for Resend delivery events"
      exports: ["POST"]
  key_links:
    - from: "app/api/webhooks/resend/route.ts"
      to: "process.env.RESEND_WEBHOOK_SECRET"
      via: "signature verification"
      pattern: "RESEND_WEBHOOK_SECRET"
    - from: "app/api/webhooks/resend/route.ts"
      to: "supabase.from('send_logs')"
      via: "status update"
      pattern: "from\\('send_logs'\\)"
---

<objective>
Create webhook handler to receive Resend delivery events and update send_log status.

Purpose: Track email delivery status (delivered, bounced, complained, opened) and auto-opt-out contacts on delivery failures.
Output: API route that securely processes Resend webhooks and updates database.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-sending/04-RESEARCH.md
@.planning/phases/04-core-sending/04-01-SUMMARY.md
@.planning/phases/04-core-sending/04-02-SUMMARY.md

@lib/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Resend webhook handler</name>
  <files>app/api/webhooks/resend/route.ts</files>
  <action>
Create app/api/webhooks/resend/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { Resend } from 'resend'
import { createClient } from '@supabase/supabase-js'

// Use service role for webhook handler - no user context available
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
)

const resend = new Resend(process.env.RESEND_API_KEY)

// Map Resend event types to our status values
const STATUS_MAP: Record<string, string> = {
  'email.delivered': 'delivered',
  'email.bounced': 'bounced',
  'email.complained': 'complained',
  'email.opened': 'opened',
}

// Events that should trigger contact opt-out
const OPT_OUT_EVENTS = ['email.bounced', 'email.complained']

/**
 * Resend Webhook Types (simplified)
 */
interface ResendWebhookEvent {
  type: string
  data: {
    email_id: string
    to: string[]
    tags?: Array<{ name: string; value: string }>
  }
}

export async function POST(req: NextRequest) {
  try {
    const payload = await req.text()

    // === Verify webhook signature ===
    const webhookSecret = process.env.RESEND_WEBHOOK_SECRET
    if (!webhookSecret) {
      console.error('RESEND_WEBHOOK_SECRET not configured')
      return NextResponse.json({ error: 'Webhook not configured' }, { status: 500 })
    }

    let event: ResendWebhookEvent
    try {
      // Verify signature using Resend SDK
      event = resend.webhooks.verify({
        payload,
        headers: {
          'svix-id': req.headers.get('svix-id') || '',
          'svix-timestamp': req.headers.get('svix-timestamp') || '',
          'svix-signature': req.headers.get('svix-signature') || '',
        },
        secret: webhookSecret,
      }) as ResendWebhookEvent
    } catch (verifyError) {
      console.error('Webhook signature verification failed:', verifyError)
      return NextResponse.json({ error: 'Invalid webhook signature' }, { status: 400 })
    }

    // === Extract send_log_id from tags ===
    const sendLogId = event.data.tags?.find(tag => tag.name === 'send_log_id')?.value

    if (!sendLogId) {
      // Email wasn't sent through our system (or missing tag) - ignore
      console.log(`Webhook received for unknown email: ${event.type}`)
      return NextResponse.json({ received: true })
    }

    // === Map event type to status ===
    const newStatus = STATUS_MAP[event.type]
    if (!newStatus) {
      // Unknown event type - acknowledge but don't process
      console.log(`Unknown webhook event type: ${event.type}`)
      return NextResponse.json({ received: true })
    }

    // === Update send_log status ===
    const { error: updateError } = await supabase
      .from('send_logs')
      .update({
        status: newStatus,
        updated_at: new Date().toISOString(),
      })
      .eq('id', sendLogId)

    if (updateError) {
      console.error('Failed to update send_log:', updateError)
      // Don't return error - we don't want Resend to retry for our DB issues
    }

    // === Auto opt-out contact on bounce or complaint ===
    if (OPT_OUT_EVENTS.includes(event.type)) {
      // Get the contact_id from the send_log
      const { data: sendLog } = await supabase
        .from('send_logs')
        .select('contact_id')
        .eq('id', sendLogId)
        .single()

      if (sendLog?.contact_id) {
        const { error: optOutError } = await supabase
          .from('contacts')
          .update({ opted_out: true })
          .eq('id', sendLog.contact_id)

        if (optOutError) {
          console.error('Failed to opt-out contact:', optOutError)
        } else {
          console.log(`Contact ${sendLog.contact_id} opted out due to ${event.type}`)
        }
      }
    }

    return NextResponse.json({ received: true })
  } catch (error) {
    console.error('Webhook processing error:', error)
    // Return 200 to prevent Resend from retrying
    return NextResponse.json({ received: true, error: 'Processing error' })
  }
}

// Reject other methods
export async function GET() {
  return NextResponse.json({ error: 'Method not allowed' }, { status: 405 })
}
```

Key implementation details:
- Uses service role key (server-only, not user-scoped)
- Verifies webhook signature using Resend SDK
- Maps event types to our status enum
- Extracts send_log_id from email tags (set during send)
- Auto opts-out contacts on bounces/complaints
- Returns 200 even on processing errors to prevent retry loops
- Logs unknown events for debugging

NOTE: The webhook verification uses hyphenated header names (`svix-id`, `svix-timestamp`, `svix-signature`) which are the actual HTTP header names sent by Resend/Svix. The Resend SDK's `verify()` method expects these exact property names in the headers object. The non-hyphenated names (`id`, `timestamp`, `signature`) shown in some documentation examples are simplified property names - the actual implementation must use the hyphenated versions when reading from `req.headers.get()`.
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors; run `npm run build` to verify API route compiles</verify>
  <done>Webhook handler verifies signatures, updates send_log status, and auto-opts-out contacts on failures</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes without errors
2. `npm run build` compiles the API route
3. Route exports POST handler
4. Signature verification uses RESEND_WEBHOOK_SECRET
5. Status mapping covers delivered, bounced, complained, opened
6. Auto opt-out triggers on bounced and complained events
7. Returns 200 on all scenarios (prevents webhook retry storms)
</verification>

<success_criteria>
- Webhook endpoint at /api/webhooks/resend
- Validates Resend webhook signatures
- Updates send_log status based on event type
- Auto-opts-out contacts on bounces and complaints
- Graceful error handling (no retry storms)
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-sending/04-04-SUMMARY.md`
</output>
