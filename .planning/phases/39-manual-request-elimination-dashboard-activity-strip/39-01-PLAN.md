---
phase: 39-manual-request-elimination-dashboard-activity-strip
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/types/dashboard.ts
  - lib/data/dashboard.ts
autonomous: true

must_haves:
  truths:
    - "Dashboard data layer includes a getRecentCampaignEvents function that returns campaign-specific activity events"
    - "CampaignEvent type covers touch_sent, review_click, feedback_submitted, and enrollment event types"
    - "getRecentCampaignEvents fetches review_click events from send_logs WHERE reviewed_at IS NOT NULL AND campaign_id IS NOT NULL"
    - "Pipeline metrics (activeSequences, pendingQueued) remain available in DashboardKPIs for inline counters"
  artifacts:
    - path: "lib/types/dashboard.ts"
      provides: "CampaignEvent interface and PipelineSummary interface"
      contains: "CampaignEvent"
    - path: "lib/data/dashboard.ts"
      provides: "getRecentCampaignEvents query function"
      exports: ["getRecentCampaignEvents"]
  key_links:
    - from: "lib/data/dashboard.ts"
      to: "send_logs + customer_feedback + campaign_enrollments"
      via: "Supabase queries with campaign_id filter"
      pattern: "getRecentCampaignEvents"
    - from: "lib/data/dashboard.ts"
      to: "send_logs.reviewed_at"
      via: "Query D fetches review clicks for campaign-attributed sends"
      pattern: "reviewed_at.*is.*null"
---

<objective>
Create the data layer for the RecentCampaignActivity strip and audit server queries from the /send page to confirm their new homes.

Purpose: The dashboard's pipeline cards are being replaced with an activity strip showing concrete campaign events. This plan creates the types and query function the strip will consume. It also documents query migration for the /send page removal (Plan 39-04).
Output: CampaignEvent type, PipelineSummary type, getRecentCampaignEvents() function in lib/data/dashboard.ts
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/39-manual-request-elimination-dashboard-activity-strip/39-RESEARCH.md
@lib/types/dashboard.ts
@lib/data/dashboard.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CampaignEvent and PipelineSummary types to dashboard types</name>
  <files>lib/types/dashboard.ts</files>
  <action>
Add the following types to `lib/types/dashboard.ts` AFTER the existing DashboardKPIs interface:

```typescript
// Campaign activity event for RecentCampaignActivity strip
export type CampaignEventType = 'touch_sent' | 'review_click' | 'feedback_submitted' | 'enrollment'

export interface CampaignEvent {
  id: string
  type: CampaignEventType
  customerName: string
  campaignName: string
  touchNumber?: number
  channel?: 'email' | 'sms'
  status?: string
  rating?: number           // For feedback_submitted events
  timestamp: string
}

// Inline pipeline counters for activity strip header
export interface PipelineSummary {
  activeSequences: number
  pending: number
  requestsSentThisWeek: number
}
```

Do NOT modify the existing DashboardKPIs interface -- it must retain all 6 fields. The pipeline metrics (requestsSentThisWeek, activeSequences, pendingQueued) stay in DashboardKPIs because getDashboardKPIs still fetches them for the activity strip counters.
  </action>
  <verify>Run `pnpm typecheck` -- no new errors from the type additions</verify>
  <done>CampaignEvent and PipelineSummary types exist in lib/types/dashboard.ts with all required fields</done>
</task>

<task type="auto">
  <name>Task 2: Create getRecentCampaignEvents query function</name>
  <files>lib/data/dashboard.ts</files>
  <action>
Add a new exported async function `getRecentCampaignEvents` to `lib/data/dashboard.ts`. Import the new `CampaignEvent` type from `lib/types/dashboard`.

The function signature:
```typescript
export async function getRecentCampaignEvents(
  businessId: string,
  limit: number = 5
): Promise<CampaignEvent[]>
```

Implementation approach:
1. Create a Supabase client via `await createClient()`
2. Run **4 queries in parallel** (Promise.all):

   **Query A -- Campaign touch sends** (most recent sends WITH campaign attribution):
   ```
   supabase.from('send_logs')
     .select('id, status, channel, touch_number, created_at, customers!send_logs_customer_id_fkey(name), campaigns!send_logs_campaign_id_fkey(name)')
     .eq('business_id', businessId)
     .not('campaign_id', 'is', null)
     .order('created_at', { ascending: false })
     .limit(limit)
   ```
   Map each row to CampaignEvent with type='touch_sent', use row.created_at as timestamp.

   **Query B -- Feedback submissions**:
   ```
   supabase.from('customer_feedback')
     .select('id, rating, submitted_at, customers!inner(name)')
     .eq('business_id', businessId)
     .order('submitted_at', { ascending: false })
     .limit(limit)
   ```
   Map each row to CampaignEvent with type='feedback_submitted', use submitted_at as timestamp. For campaignName, use "Review feedback" as a fallback label since feedback may not always be tied to a named campaign.

   **Query C -- Recent enrollments**:
   ```
   supabase.from('campaign_enrollments')
     .select('id, enrolled_at, customers!inner(name), campaigns!inner(name)')
     .eq('business_id', businessId)
     .order('enrolled_at', { ascending: false })
     .limit(limit)
   ```
   Map each row to CampaignEvent with type='enrollment', use enrolled_at as timestamp. The customerName comes from the customers join, campaignName from the campaigns join.

   **Query D -- Review clicks** (campaign-attributed sends where the customer clicked the review link):
   ```
   supabase.from('send_logs')
     .select('id, reviewed_at, customers!send_logs_customer_id_fkey(name), campaigns(name)')
     .eq('business_id', businessId)
     .not('campaign_id', 'is', null)
     .not('reviewed_at', 'is', null)
     .order('reviewed_at', { ascending: false })
     .limit(limit)
   ```
   Map each row to CampaignEvent with type='review_click', use row.reviewed_at as timestamp. The customerName comes from the customers join, campaignName from the campaigns join.

3. After all 4 queries return, merge results into a single array.
4. Sort by timestamp descending (most recent first).
5. Slice to `limit` items and return.

Handle errors gracefully -- if any query fails, log the error and return an empty array. Wrap the entire function body in try/catch.

**Important Supabase join patterns:** The foreign key references must match the actual FK names in the database:
- For send_logs -> customers: `customers!send_logs_customer_id_fkey(name)`
- For send_logs -> campaigns: `campaigns!send_logs_campaign_id_fkey(name)` -- note the FK might just be `campaigns(name)` if the default FK is used. Check the existing code in getAttentionAlerts for the pattern -- it uses `customers!send_logs_customer_id_fkey(id, name)`. For campaigns, since send_logs.campaign_id references campaigns.id, use `campaigns(name)`.
- For campaign_enrollments -> customers: Use `customers!inner(name)` -- the `inner` modifier ensures we only get enrollments that have a valid customer.
- For campaign_enrollments -> campaigns: Use `campaigns!inner(name)`.
- For customer_feedback -> customers: Use `customers!inner(name)` (same as existing pattern in getAttentionAlerts).

When mapping query results to CampaignEvent objects, handle the case where the Supabase join returns either an array or a single object by checking `Array.isArray()` -- follow the exact pattern used in the existing `getAttentionAlerts` function: `const customer = Array.isArray(row.customers) ? row.customers[0] : row.customers`.

Add the import for CampaignEvent to the existing imports from '@/lib/types/dashboard':
```typescript
import type {
  DashboardKPIs,
  ReadyToSendJob,
  AttentionAlert,
  DashboardCounts,
  CampaignEvent,
} from '@/lib/types/dashboard'
```
  </action>
  <verify>Run `pnpm typecheck` -- function compiles without errors. Run `pnpm lint` -- no lint warnings.</verify>
  <done>getRecentCampaignEvents is exported from lib/data/dashboard.ts, returns CampaignEvent[], queries send_logs (campaign-attributed touch sends), send_logs (review clicks via reviewed_at), customer_feedback, and campaign_enrollments</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes with zero errors
2. `pnpm lint` passes with zero errors
3. `CampaignEvent` type is exported from `lib/types/dashboard.ts`
4. `PipelineSummary` type is exported from `lib/types/dashboard.ts`
5. `getRecentCampaignEvents` function is exported from `lib/data/dashboard.ts`
6. getRecentCampaignEvents runs 4 parallel queries (touch sends, feedback, enrollments, review clicks)
7. Review click query filters on `campaign_id IS NOT NULL` AND `reviewed_at IS NOT NULL`
8. Existing `DashboardKPIs` interface is unchanged (still has all 6 fields)
9. Existing `getDashboardKPIs` function is unchanged
</verification>

<success_criteria>
- CampaignEvent type defines all 4 event types with proper fields
- PipelineSummary type provides activeSequences, pending, requestsSentThisWeek
- getRecentCampaignEvents queries 4 tables/views, merges, sorts by timestamp, returns top N
- Review clicks are fetched from send_logs WHERE reviewed_at IS NOT NULL AND campaign_id IS NOT NULL
- No existing code is broken (typecheck + lint pass)
</success_criteria>

<output>
After completion, create `.planning/phases/39-manual-request-elimination-dashboard-activity-strip/39-01-SUMMARY.md`
</output>
