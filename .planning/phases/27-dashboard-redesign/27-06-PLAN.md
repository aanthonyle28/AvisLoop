---
phase: 27-dashboard-redesign
plan: 06
type: execute
wave: 3
depends_on: ["27-01"]
files_modified:
  - app/(dashboard)/analytics/page.tsx
  - lib/data/analytics.ts
  - components/dashboard/analytics-service-breakdown.tsx
autonomous: true

must_haves:
  truths:
    - "Analytics page displays response rate breakdown by service type"
    - "Analytics page displays review rate breakdown by service type"
    - "Data is derived from actual send_logs and customer_feedback tables"
    - "Page is accessible from navigation"
  artifacts:
    - path: "app/(dashboard)/analytics/page.tsx"
      provides: "Analytics page with service type breakdowns"
      min_lines: 30
    - path: "lib/data/analytics.ts"
      provides: "Analytics data functions"
      exports: ["getServiceTypeAnalytics"]
    - path: "components/dashboard/analytics-service-breakdown.tsx"
      provides: "Service type breakdown table component"
      exports: ["ServiceTypeBreakdown"]
  key_links:
    - from: "app/(dashboard)/analytics/page.tsx"
      to: "lib/data/analytics.ts"
      via: "getServiceTypeAnalytics data fetch"
      pattern: "getServiceTypeAnalytics"
    - from: "components/dashboard/analytics-service-breakdown.tsx"
      to: "lib/data/analytics.ts"
      via: "ServiceTypeAnalytics type"
      pattern: "ServiceTypeAnalytics"
---

<objective>
Build the Analytics page with response rate and review rate breakdowns by service type (requirement SVCT-04).

Purpose: Business owners need to see which service types generate the most reviews so they can optimize campaign timing and messaging.
Output: Analytics page at /analytics with table-based service type breakdowns.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/27-dashboard-redesign/27-CONTEXT.md
@.planning/phases/27-dashboard-redesign/27-RESEARCH.md
@lib/data/send-logs.ts
@lib/data/feedback.ts
@lib/data/campaign.ts
@lib/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create analytics data functions</name>
  <files>lib/data/analytics.ts</files>
  <action>
Create `lib/data/analytics.ts`. No 'use server' directive (data functions).

**Types (define in this file or in lib/types/dashboard.ts):**

```typescript
interface ServiceTypeMetrics {
  serviceType: string          // e.g., "hvac", "plumbing"
  displayName: string          // e.g., "HVAC", "Plumbing"
  totalSent: number            // Total sends for this service type
  delivered: number            // Successful deliveries
  reviewed: number             // Sends where reviewed_at is set
  feedbackCount: number        // Private feedback received
  responseRate: number         // (reviewed + feedbackCount) / delivered * 100
  reviewRate: number           // reviewed / delivered * 100 (public reviews only)
}

interface ServiceTypeAnalytics {
  byServiceType: ServiceTypeMetrics[]
  totals: {
    totalSent: number
    totalDelivered: number
    totalReviewed: number
    totalFeedback: number
    overallResponseRate: number
    overallReviewRate: number
  }
}
```

**`getServiceTypeAnalytics(businessId: string): Promise<ServiceTypeAnalytics>`**

Implementation approach:
1. Fetch send_logs for this business that have a campaign association (campaign_id IS NOT NULL). Join to campaign_enrollments and then to jobs to get the service_type. Since send_logs have campaign_id and touch_number, we can trace back:
   - Send logs -> campaign_enrollments (via campaign_enrollment_id) -> jobs (via job_id) -> service_type
   - Query: `send_logs` with `campaign_enrollment_id IS NOT NULL`, join to get job service_type

2. Simpler approach (recommended): Query campaign_enrollments grouped by service type from the joined jobs table:
   ```
   SELECT j.service_type,
     COUNT(DISTINCT ce.id) as total_enrollments,
     COUNT(sl.id) FILTER (WHERE sl.status IN ('sent','delivered','opened')) as total_sent,
     COUNT(sl.id) FILTER (WHERE sl.reviewed_at IS NOT NULL) as reviewed
   FROM campaign_enrollments ce
   JOIN jobs j ON ce.job_id = j.id
   LEFT JOIN send_logs sl ON sl.campaign_enrollment_id = ce.id
   WHERE ce.business_id = ?
   GROUP BY j.service_type
   ```

3. Since Supabase client doesn't support complex GROUP BY, do it in JS:
   - Fetch all campaign_enrollments for this business with job.service_type (join jobs)
   - Fetch all send_logs with campaign_enrollment_id for this business
   - Fetch all customer_feedback for this business (for feedback counts, can join via enrollment)
   - Group and compute metrics in JS

   Steps:
   a. `campaign_enrollments` with `jobs(service_type)` join -> get service_type per enrollment
   b. `send_logs` where `campaign_enrollment_id IS NOT NULL` -> get statuses per enrollment
   c. `customer_feedback` with `enrollment_id` -> count per service type
   d. Group by service_type, compute rates

4. For each service type, compute:
   - `responseRate = totalDelivered > 0 ? Math.round(((reviewed + feedbackCount) / totalDelivered) * 100) : 0`
   - `reviewRate = totalDelivered > 0 ? Math.round((reviewed / totalDelivered) * 100) : 0`

5. Display name mapping: `{ hvac: 'HVAC', plumbing: 'Plumbing', electrical: 'Electrical', cleaning: 'Cleaning', roofing: 'Roofing', painting: 'Painting', handyman: 'Handyman', other: 'Other' }`

6. Sort by totalSent descending (most active service types first).

Handle auth internally: get user -> get business -> run queries. Return empty data if not authenticated.
  </action>
  <verify>Run `pnpm typecheck` -- no errors.</verify>
  <done>Analytics data function computes response rate and review rate per service type from actual data.</done>
</task>

<task type="auto">
  <name>Task 2: Create analytics page and breakdown component</name>
  <files>
    components/dashboard/analytics-service-breakdown.tsx
    app/(dashboard)/analytics/page.tsx
  </files>
  <action>
**ServiceTypeBreakdown component** (`components/dashboard/analytics-service-breakdown.tsx`):

Client component ('use client'). Props: `{ data: ServiceTypeAnalytics }`.

Render a clean table-based layout (no chart library needed for MVP):

**Summary cards row** (grid-cols-1 md:grid-cols-3 gap-4):
1. Overall Response Rate: large percentage + "of delivered requests got a response"
2. Overall Review Rate: large percentage + "of delivered requests led to a public review"
3. Total Requests Sent: large number + "across all service types"

**Service Type Breakdown Table:**
Use a styled HTML table (not @tanstack/react-table -- too heavy for this read-only display).

Columns:
| Service Type | Sent | Delivered | Reviews | Feedback | Response Rate | Review Rate |
|---|---|---|---|---|---|---|

Each row shows the ServiceTypeMetrics for one service type.
- Response Rate and Review Rate shown as percentage with a simple horizontal bar indicator:
  ```tsx
  <div className="flex items-center gap-2">
    <div className="w-24 h-2 bg-muted rounded-full overflow-hidden">
      <div
        className="h-full bg-primary rounded-full"
        style={{ width: `${Math.min(rate, 100)}%` }}
      />
    </div>
    <span className="text-sm font-medium">{rate}%</span>
  </div>
  ```

**Empty state:** If no data (no campaigns sent yet): "No campaign data yet. Once campaigns start sending, service type breakdowns will appear here."

Style: Use Card for the table wrapper. Match existing table styling from the codebase.

**Analytics page** (`app/(dashboard)/analytics/page.tsx`):

Server Component. Pattern:
1. `getBusiness()` -> redirect if null
2. `getServiceTypeAnalytics(business.id)`
3. Render with page header and ServiceTypeBreakdown component

```jsx
<div className="container mx-auto py-6 px-4">
  <h1 className="text-2xl font-bold mb-6">Analytics</h1>
  <ServiceTypeBreakdown data={analyticsData} />
</div>
```

Metadata: `title: 'Analytics | AvisLoop'`

Note: Do NOT add Analytics to the sidebar navigation yet. It can be accessed via KPI card clicks or direct URL. If the user wants it in nav, it can be added in a future iteration. This keeps the nav clean per CONTEXT.md (which doesn't mention Analytics as a nav item).
  </action>
  <verify>Run `pnpm typecheck` and `pnpm lint` -- no errors. Navigate to /analytics to verify page renders.</verify>
  <done>Analytics page shows service type breakdown with response rate and review rate per type, summary cards at top.</done>
</task>

</tasks>

<verification>
- `pnpm typecheck` passes
- `pnpm lint` passes
- getServiceTypeAnalytics exported from lib/data/analytics.ts
- ServiceTypeBreakdown exported from component
- Page exists at app/(dashboard)/analytics/page.tsx
- Table shows service type metrics with percentage bars
- Empty state renders when no campaign data exists
</verification>

<success_criteria>
- Analytics shows real data from send_logs, campaign_enrollments, and customer_feedback
- Response rate = (reviews + feedback) / delivered -- includes all responses
- Review rate = reviews / delivered -- only public reviews
- Service types sorted by volume (most active first)
- No new dependencies needed (pure Tailwind + existing components)
</success_criteria>

<output>
After completion, create `.planning/phases/27-dashboard-redesign/27-06-SUMMARY.md`
</output>
