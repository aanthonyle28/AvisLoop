---
phase: 27-dashboard-redesign
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/data/dashboard.ts
  - lib/types/dashboard.ts
autonomous: true

must_haves:
  truths:
    - "Dashboard data layer returns KPI metrics with trend comparisons"
    - "Ready-to-send query returns completed jobs not enrolled in any campaign"
    - "Attention alerts query returns failed sends and unresolved feedback sorted by severity"
    - "All queries accept businessId and run independently (no waterfalls)"
  artifacts:
    - path: "lib/data/dashboard.ts"
      provides: "All dashboard data fetching functions"
      exports: ["getDashboardKPIs", "getReadyToSendJobs", "getAttentionAlerts", "getDashboardCounts"]
    - path: "lib/types/dashboard.ts"
      provides: "TypeScript interfaces for dashboard data"
      exports: ["DashboardKPIs", "ReadyToSendJob", "AttentionAlert", "DashboardCounts"]
  key_links:
    - from: "lib/data/dashboard.ts"
      to: "supabase"
      via: "createClient() queries"
      pattern: "createClient.*from\\("
---

<objective>
Create the dashboard data layer: TypeScript types and Supabase query functions for KPI metrics, ready-to-send queue, and attention alerts.

Purpose: All dashboard components depend on clean, typed data. Building the data layer first means components can be built in parallel without data concerns.
Output: `lib/types/dashboard.ts` and `lib/data/dashboard.ts` with all dashboard queries.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-dashboard-redesign/27-CONTEXT.md
@.planning/phases/27-dashboard-redesign/27-RESEARCH.md
@lib/data/send-logs.ts
@lib/data/jobs.ts
@lib/data/feedback.ts
@lib/data/campaign.ts
@lib/data/business.ts
@lib/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dashboard TypeScript types</name>
  <files>lib/types/dashboard.ts</files>
  <action>
Create `lib/types/dashboard.ts` with these interfaces:

```typescript
// KPI data with trend comparisons
interface KPIMetric {
  value: number
  previousValue: number
  trend: number          // percentage change (positive = up, negative = down)
  trendPeriod: string    // "vs last week" or "vs last month"
}

interface DashboardKPIs {
  // Outcome metrics (large cards, monthly comparison)
  reviewsThisMonth: KPIMetric
  averageRating: KPIMetric       // 0-5 scale
  conversionRate: KPIMetric      // percentage: reviews / total sends

  // Pipeline metrics (smaller cards, weekly comparison)
  requestsSentThisWeek: KPIMetric
  activeSequences: KPIMetric     // active campaign enrollments
  pendingQueued: KPIMetric       // pending/scheduled sends
}

// Ready-to-send job (completed but not enrolled)
interface ReadyToSendJob {
  id: string
  customer: { id: string; name: string; email: string }
  service_type: ServiceType
  completed_at: string
  isStale: boolean           // exceeds optimal service type window
  hoursElapsed: number
  threshold: number          // from business.service_type_timing
}

// Attention alert with contextual action
type AlertSeverity = 'critical' | 'warning' | 'info'
type AlertType = 'failed_send' | 'bounced_email' | 'stop_request' | 'unresolved_feedback'

interface AttentionAlert {
  id: string
  severity: AlertSeverity
  type: AlertType
  title: string
  description: string
  timestamp: string
  contextualAction: {
    label: string
    href: string
  }
  // For retry actions (failed sends)
  retryable?: boolean
  sendLogId?: string
  // For feedback alerts
  feedbackId?: string
}

// Aggregate counts for banner and nav badge
interface DashboardCounts {
  readyToSend: number
  attentionAlerts: number
  total: number              // readyToSend + attentionAlerts
}
```

Import `ServiceType` from `@/lib/types/database`. Export all interfaces.
  </action>
  <verify>Run `pnpm typecheck` -- no errors from the new file.</verify>
  <done>All dashboard type interfaces are exported and type-check clean.</done>
</task>

<task type="auto">
  <name>Task 2: Create dashboard data functions</name>
  <files>lib/data/dashboard.ts</files>
  <action>
Create `lib/data/dashboard.ts` with these functions. All functions accept `businessId: string` (caller resolves auth). Use `createClient()` from `@/lib/supabase/server`.

**`getDashboardKPIs(businessId: string): Promise<DashboardKPIs>`**
- Outcome metrics (monthly comparison):
  - `reviewsThisMonth`: Count send_logs where `reviewed_at IS NOT NULL` in current calendar month. Compare to same day range in previous month.
  - `averageRating`: Average `rating` from `customer_feedback` this month. Compare to previous month.
  - `conversionRate`: `(reviews / total delivered sends) * 100` this month. Compare to previous month.
- Pipeline metrics (weekly comparison, rolling 7 days vs previous 7 days):
  - `requestsSentThisWeek`: Count send_logs with status in ('sent','delivered','opened') in last 7 days. Compare to 7 days before that.
  - `activeSequences`: Count campaign_enrollments where status='active'. Compare to 7 days ago snapshot (use enrolled_at counting).
  - `pendingQueued`: Count send_logs where status='pending' now. Compare to same count 7 days ago (approximate: just show current value, trend=0 if no historical data).
- Use `Promise.all()` internally to fetch all counts in parallel.
- For trend calculation: `trend = previousValue === 0 ? (value > 0 ? 100 : 0) : Math.round(((value - previousValue) / previousValue) * 100)`
- All trend periods use the string literals from CONTEXT.md ("vs last week" / "vs last month").

**`getReadyToSendJobs(businessId: string, serviceTypeTiming: Record<string, number>): Promise<ReadyToSendJob[]>`**
- Query `jobs` where `business_id = businessId AND status = 'completed'`.
- LEFT JOIN check: exclude jobs that have an active enrollment in `campaign_enrollments` (WHERE ce.job_id = j.id AND ce.status = 'active').
- Approach: Fetch completed jobs, then fetch job_ids with active enrollments, then filter in JS (Supabase client doesn't support NOT EXISTS subqueries well).
- Join customer data: `customers!inner(id, name, email)`.
- For each job, calculate `hoursElapsed = differenceInHours(new Date(), new Date(job.completed_at))`.
- Use `serviceTypeTiming[job.service_type]` (or default 24) as `threshold`.
- Set `isStale = hoursElapsed > threshold`.
- Sort: stale jobs first, then by completed_at ascending (oldest first).
- Limit to 20 results (paginated expansion handled in UI).

**`getAttentionAlerts(businessId: string): Promise<AttentionAlert[]>`**
- Fetch two data sources in parallel:
  1. Failed/bounced send_logs: `status IN ('failed', 'bounced')` for this business, most recent 50. Map each to an AttentionAlert:
     - `failed` -> severity 'critical', type 'failed_send', action label "Retry", retryable=true
     - `bounced` -> severity 'warning', type 'bounced_email', action label "Update contact", href to `/customers/{customer_id}`
  2. Unresolved feedback: `customer_feedback WHERE business_id = businessId AND resolved_at IS NULL`, most recent 20. Map to AttentionAlert:
     - severity 'info', type 'unresolved_feedback', action label "Respond", href to `/feedback?id={feedback_id}`
  - Join customer name on send_logs: `contacts(name)` for the alert description.
  - Merge both arrays and sort by severity (critical=0, warning=1, info=2), then by timestamp descending within same severity.

**`getDashboardCounts(businessId: string): Promise<DashboardCounts>`**
- Lightweight version for nav badge: just counts, no full data.
- Count ready-to-send jobs (same logic as getReadyToSendJobs but count only).
- Count attention alerts: failed/bounced send_logs + unresolved feedback.
- Use `{ count: 'exact', head: true }` for efficiency.
- Return `{ readyToSend, attentionAlerts, total: readyToSend + attentionAlerts }`.

Important patterns to follow:
- Match existing data function patterns from `lib/data/send-logs.ts` and `lib/data/jobs.ts`.
- Use `import { createClient } from '@/lib/supabase/server'`.
- Handle errors gracefully: log with console.error, return safe defaults (empty arrays, zero counts).
- Do NOT use 'use server' directive -- these are data functions, not server actions.
  </action>
  <verify>Run `pnpm typecheck` -- no errors. Verify function signatures match the types from Task 1.</verify>
  <done>All four dashboard data functions exist, type-check clean, and follow existing codebase patterns.</done>
</task>

</tasks>

<verification>
- `pnpm typecheck` passes with zero errors
- `lib/types/dashboard.ts` exports DashboardKPIs, ReadyToSendJob, AttentionAlert, DashboardCounts
- `lib/data/dashboard.ts` exports getDashboardKPIs, getReadyToSendJobs, getAttentionAlerts, getDashboardCounts
- All functions use Promise.all() for parallel queries
- No 'use server' directive on data functions
</verification>

<success_criteria>
- Dashboard types are comprehensive and match CONTEXT.md requirements
- Data functions cover all dashboard sections (KPIs, queue, alerts, badge counts)
- Trend calculations use correct comparison periods (weekly for activity, monthly for outcomes)
- Ready-to-send correctly excludes jobs with active enrollments
- Alerts sorted by severity with contextual action metadata
</success_criteria>

<output>
After completion, create `.planning/phases/27-dashboard-redesign/27-01-SUMMARY.md`
</output>
