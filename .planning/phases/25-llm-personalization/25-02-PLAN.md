---
phase: 25-llm-personalization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/ai/schemas.ts
  - lib/ai/validation.ts
autonomous: true

must_haves:
  truths:
    - "Zod schemas constrain LLM output format"
    - "Input sanitization prevents prompt injection from customer data"
    - "Output validation catches missing required fields under 50ms"
    - "Validation detects prohibited content (incentives, fake urgency)"
  artifacts:
    - path: "lib/ai/schemas.ts"
      provides: "Zod schemas for structured LLM outputs"
      exports: ["PersonalizedEmailSchema", "PersonalizedSmsSchema", "PersonalizedMessageSchema"]
    - path: "lib/ai/validation.ts"
      provides: "Input sanitization and output validation"
      exports: ["sanitizeInput", "validateOutput", "ValidationResult"]
  key_links:
    - from: "lib/ai/validation.ts"
      to: "lib/ai/schemas.ts"
      via: "schema imports for type definitions"
      pattern: "import.*from.*schemas"
---

<objective>
Create Zod schemas for structured LLM output and validation utilities for input sanitization and output verification.

Purpose: Defense-in-depth for LLM integration. Input sanitization prevents prompt injection from customer-controlled fields (notes, tags). Output validation ensures LLM responses meet quality and compliance requirements before sending to customers.

Output: lib/ai/schemas.ts and lib/ai/validation.ts ready for use in personalization function.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-llm-personalization/25-CONTEXT.md
@.planning/phases/25-llm-personalization/25-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zod schemas for structured LLM output</name>
  <files>lib/ai/schemas.ts</files>
  <action>
Create `lib/ai/schemas.ts` with schemas for email and SMS personalization:

```typescript
import { z } from 'zod'

// Email personalization output schema
export const PersonalizedEmailSchema = z.object({
  subject: z.string().min(1).max(200),
  body: z.string().min(10).max(2000),
})

// SMS personalization output schema
// Tighter constraints for character limit
export const PersonalizedSmsSchema = z.object({
  body: z.string().min(10).max(160),  // SMS character limit
})

// Discriminated union for channel-specific validation
export const PersonalizedMessageSchema = z.discriminatedUnion('channel', [
  z.object({
    channel: z.literal('email'),
    subject: z.string().min(1).max(200),
    body: z.string().min(10).max(2000),
  }),
  z.object({
    channel: z.literal('sms'),
    body: z.string().min(10).max(160),
  }),
])

// Type exports
export type PersonalizedEmail = z.infer<typeof PersonalizedEmailSchema>
export type PersonalizedSms = z.infer<typeof PersonalizedSmsSchema>
export type PersonalizedMessage = z.infer<typeof PersonalizedMessageSchema>

// Input context schema (for validation before LLM call)
export const PersonalizationInputSchema = z.object({
  template: z.string().min(1),
  customerName: z.string().min(1).max(100),
  businessName: z.string().min(1).max(200),
  serviceType: z.string().optional(),
  technicianName: z.string().optional(),
  touchNumber: z.number().int().min(1).max(4),
  channel: z.enum(['email', 'sms']),
  reviewLink: z.string().url(),
  isRepeatCustomer: z.boolean().optional(),
  businessId: z.string().uuid(),  // For rate limiting
})

export type PersonalizationInput = z.infer<typeof PersonalizationInputSchema>
```

Key decisions:
- Discriminated union allows channel-specific validation in single parse
- SMS max 160 chars (single segment) - opt-out added separately
- Email allows up to 2000 chars (reasonable for review request)
- Input schema validates all context before LLM call
  </action>
  <verify>
TypeScript compiles: `pnpm typecheck` passes.
File exports PersonalizedEmailSchema, PersonalizedSmsSchema, PersonalizedMessageSchema, PersonalizationInputSchema.
  </verify>
  <done>Zod schemas define structured output format for email and SMS personalization</done>
</task>

<task type="auto">
  <name>Task 2: Create input sanitization and output validation</name>
  <files>lib/ai/validation.ts</files>
  <action>
Create `lib/ai/validation.ts` with triple-layer defense:

```typescript
/**
 * Input sanitization and output validation for LLM personalization.
 * Budget: <50ms total for all validation steps.
 */

export type ValidationResult =
  | { valid: true }
  | { valid: false; reason: ValidationFailureReason }

export type ValidationFailureReason =
  | 'missing_review_link'
  | 'missing_opt_out'
  | 'missing_business_name'
  | 'too_long'
  | 'contains_html'
  | 'contains_unknown_url'
  | 'contains_prohibited_content'
  | 'contains_unresolved_token'

// === LAYER 1: Input Sanitization (<1ms budget) ===

/**
 * Sanitize user-controlled input before sending to LLM.
 * Prevents prompt injection from customer notes, tags, etc.
 */
export function sanitizeInput(raw: string): string {
  if (!raw) return ''

  let clean = raw

  // Remove common prompt injection phrases
  clean = clean
    .replace(/ignore\s+(previous|all|above)\s+instructions?/gi, '')
    .replace(/system\s*:/gi, '')
    .replace(/assistant\s*:/gi, '')
    .replace(/user\s*:/gi, '')
    .replace(/developer\s+mode/gi, '')
    .replace(/jailbreak/gi, '')
    .replace(/DAN\s+mode/gi, '')
    .replace(/pretend\s+you('re|are)/gi, '')
    .replace(/act\s+as\s+if/gi, '')

  // Detect and neutralize base64 encoded content (common evasion)
  if (/^[A-Za-z0-9+/=]{20,}$/.test(clean.trim())) {
    // Likely base64 - truncate to prevent injection
    clean = clean.slice(0, 20) + '...'
  }

  // Remove angle brackets that could confuse XML-style prompts
  clean = clean.replace(/[<>]/g, '')

  // Length limit
  return clean.slice(0, 500)
}

/**
 * Sanitize all input fields before building prompt.
 */
export function sanitizeAllInputs(input: {
  customerName: string
  businessName: string
  serviceType?: string
  technicianName?: string
  notes?: string
}): typeof input {
  return {
    customerName: sanitizeInput(input.customerName),
    businessName: sanitizeInput(input.businessName),
    serviceType: input.serviceType ? sanitizeInput(input.serviceType) : undefined,
    technicianName: input.technicianName ? sanitizeInput(input.technicianName) : undefined,
    notes: input.notes ? sanitizeInput(input.notes) : undefined,
  }
}

// === LAYER 3: Output Validation (<50ms budget) ===

// Prohibited content patterns (from CONTEXT.md)
const PROHIBITED_PATTERNS = [
  // Incentive language
  /give.{0,20}discount/i,
  /reward.{0,20}review/i,
  /gift.{0,20}card/i,
  /free.{0,20}service/i,

  // Fake urgency
  /limited\s+time/i,
  /act\s+now/i,
  /don'?t\s+miss/i,
  /expires?\s+(soon|today)/i,
  /hurry/i,

  // Pressure tactics
  /must\s+(leave|write|give).{0,10}review/i,
  /only\s+if\s+(happy|satisfied|positive)/i,
  /leave\s+(?:a\s+)?5.?star/i,
  /positive\s+review/i,

  // Invented claims
  /award.?winning/i,
  /best\s+in\s+(town|city|area)/i,
  /#1\s+(rated|ranked)/i,
]

// Unresolved token patterns (template variables that weren't filled)
const UNRESOLVED_TOKEN_PATTERNS = [
  /\{\{[^}]+\}\}/,  // {{variable}}
  /\[\[?[^\]]+\]?\]/,  // [[variable]] or [variable]
  /%[A-Z_]+%/,  // %VARIABLE%
]

/**
 * Validate LLM output before sending to customer.
 * All checks run in parallel where possible.
 */
export function validateOutput(
  output: string,
  context: {
    reviewLink: string
    businessName: string
    templateLength: number
    channel: 'email' | 'sms'
  }
): ValidationResult {
  // === Critical checks (<1ms) ===

  // 1. Review link must be present
  if (!output.includes(context.reviewLink)) {
    return { valid: false, reason: 'missing_review_link' }
  }

  // 2. Business name must be present
  if (!output.toLowerCase().includes(context.businessName.toLowerCase())) {
    return { valid: false, reason: 'missing_business_name' }
  }

  // 3. Length check (max 2x template length)
  if (output.length > context.templateLength * 2) {
    return { valid: false, reason: 'too_long' }
  }

  // === Security checks (<5ms) ===

  // 4. No HTML/script tags
  if (/<script|<iframe|<object|<embed|javascript:|on\w+=/i.test(output)) {
    return { valid: false, reason: 'contains_html' }
  }

  // 5. No unknown URLs (only review link allowed)
  const urlPattern = /https?:\/\/[^\s<>"']+/gi
  const urls = output.match(urlPattern) || []
  for (const url of urls) {
    // Allow the review link
    if (url.startsWith(context.reviewLink)) continue
    // Allow common URL fragments that might be split
    if (url.length < 10) continue
    // Unknown URL detected
    return { valid: false, reason: 'contains_unknown_url' }
  }

  // === Compliance checks (<10ms) ===

  // 6. No prohibited content
  for (const pattern of PROHIBITED_PATTERNS) {
    if (pattern.test(output)) {
      return { valid: false, reason: 'contains_prohibited_content' }
    }
  }

  // 7. No unresolved template tokens
  for (const pattern of UNRESOLVED_TOKEN_PATTERNS) {
    if (pattern.test(output)) {
      return { valid: false, reason: 'contains_unresolved_token' }
    }
  }

  return { valid: true }
}

/**
 * Quick check for opt-out language in SMS.
 * Called separately since opt-out is appended after LLM output.
 */
export function hasOptOutLanguage(text: string): boolean {
  return /stop|unsubscribe|opt.?out/i.test(text)
}
```

Design decisions from RESEARCH.md:
- Budget <50ms total for all validation
- Input sanitization removes injection phrases + base64 detection
- Output validation checks: review link, business name, length, HTML, URLs, prohibited content
- Prohibited patterns from CONTEXT.md baked into validation
- Fail-fast: Return on first validation failure
  </action>
  <verify>
TypeScript compiles: `pnpm typecheck` passes.
File exports sanitizeInput, sanitizeAllInputs, validateOutput, hasOptOutLanguage.
  </verify>
  <done>Validation utilities provide input sanitization and output verification under 50ms budget</done>
</task>

</tasks>

<verification>
All verification commands should pass:

```bash
pnpm typecheck
pnpm lint
```

Check lib/ai/ directory structure:
- lib/ai/schemas.ts exists with Zod schemas
- lib/ai/validation.ts exists with sanitization and validation functions
</verification>

<success_criteria>
- lib/ai/schemas.ts exports PersonalizedEmailSchema, PersonalizedSmsSchema, PersonalizedMessageSchema, PersonalizationInputSchema
- lib/ai/validation.ts exports sanitizeInput, validateOutput
- Validation detects prohibited content patterns from CONTEXT.md
- Input sanitization removes prompt injection phrases
- All code typechecks and lints clean
</success_criteria>

<output>
After completion, create `.planning/phases/25-llm-personalization/25-02-SUMMARY.md`
</output>
