---
phase: 25-llm-personalization
plan: 04
type: execute
wave: 3
depends_on: ["25-03"]
files_modified:
  - lib/actions/personalize.ts
  - app/api/cron/process-campaign-touches/route.ts
autonomous: true

must_haves:
  truths:
    - "Server action provides client-callable personalization interface"
    - "Campaign touch processor uses LLM personalization before sending"
    - "Personalization failure falls back to raw template - never blocks sends"
    - "Send logs track whether message was personalized"
    - "Personalized subject line is used in sent emails"
  artifacts:
    - path: "lib/actions/personalize.ts"
      provides: "Server action for personalization preview"
      exports: ["personalizePreview", "PersonalizePreviewResult"]
    - path: "app/api/cron/process-campaign-touches/route.ts"
      provides: "Campaign touch processor with personalization integration"
  key_links:
    - from: "lib/actions/personalize.ts"
      to: "lib/ai/fallback.ts"
      via: "personalizeWithFallback import"
      pattern: "import.*personalizeWithFallback.*from.*fallback"
    - from: "app/api/cron/process-campaign-touches/route.ts"
      to: "lib/ai/fallback.ts"
      via: "personalizeWithFallback import"
      pattern: "import.*personalizeWithFallback.*from.*fallback"
---

<objective>
Create server action for personalization preview and integrate LLM personalization into the campaign touch processor.

Purpose: Connect the LLM personalization layer to existing systems. The server action enables preview UI to show personalized samples. The cron processor integration makes every campaign touch optionally personalized.

Output: Campaign messages are personalized via LLM with graceful fallback. Preview server action ready for UI components.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-llm-personalization/25-CONTEXT.md
@.planning/phases/24-multi-touch-campaign-engine/24-06-SUMMARY.md
@app/api/cron/process-campaign-touches/route.ts
@lib/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create server action for personalization preview</name>
  <files>lib/actions/personalize.ts</files>
  <action>
Create `lib/actions/personalize.ts` for client-callable personalization:

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { personalizeWithFallback, personalizePreviewBatch } from '@/lib/ai/fallback'
import type { PersonalizationContext } from '@/lib/ai/prompts'
import type { ServiceType } from '@/lib/types/database'

export type PersonalizePreviewResult = {
  error?: string
  success?: boolean
  data?: {
    original: string
    personalized: string
    subject?: string
    wasPersonalized: boolean
    fallbackReason?: string
  }
}

export type BatchPreviewResult = {
  error?: string
  success?: boolean
  data?: Array<{
    customerId: string
    customerName: string
    original: string
    personalized: string
    subject?: string
    wasPersonalized: boolean
    fallbackReason?: string
  }>
}

/**
 * Preview personalization for a single message.
 * Used for template editing and single-message preview.
 */
export async function personalizePreview(input: {
  templateBody: string
  templateSubject?: string
  customerId: string
  channel: 'email' | 'sms'
  touchNumber?: 1 | 2 | 3 | 4
  serviceType?: string
}): Promise<PersonalizePreviewResult> {
  const supabase = await createClient()

  // Authenticate
  const { data: { user }, error: authError } = await supabase.auth.getUser()
  if (authError || !user) {
    return { error: 'You must be logged in' }
  }

  // Get business
  const { data: business, error: businessError } = await supabase
    .from('businesses')
    .select('id, name, google_review_link')
    .eq('user_id', user.id)
    .single()

  if (businessError || !business) {
    return { error: 'Business not found' }
  }

  if (!business.google_review_link) {
    return { error: 'Please configure your Google review link first' }
  }

  // Get customer
  const { data: customer, error: customerError } = await supabase
    .from('customers')
    .select('id, name, email, send_count')
    .eq('id', input.customerId)
    .eq('business_id', business.id)
    .single()

  if (customerError || !customer) {
    return { error: 'Customer not found' }
  }

  // Build personalization context
  const ctx: PersonalizationContext & { businessId: string } = {
    template: input.templateBody,
    customerName: customer.name,
    businessName: business.name,
    serviceType: input.serviceType,
    touchNumber: input.touchNumber || 1,
    channel: input.channel,
    reviewLink: business.google_review_link,
    isRepeatCustomer: (customer.send_count || 0) > 0,
    businessId: business.id,
  }

  // Personalize
  const result = await personalizeWithFallback(ctx)

  return {
    success: true,
    data: {
      original: input.templateBody,
      personalized: result.message,
      subject: result.subject,
      wasPersonalized: result.personalized,
      fallbackReason: result.fallbackReason,
    },
  }
}

/**
 * Preview personalization for multiple customers (campaign preview).
 * Returns 3-5 sample messages with different customer contexts.
 */
export async function personalizePreviewBatchAction(input: {
  templateBody: string
  templateSubject?: string
  campaignId?: string
  channel: 'email' | 'sms'
  serviceType?: string
  sampleCount?: number
}): Promise<BatchPreviewResult> {
  const supabase = await createClient()
  const sampleCount = Math.min(input.sampleCount || 3, 5)  // Max 5 samples

  // Authenticate
  const { data: { user }, error: authError } = await supabase.auth.getUser()
  if (authError || !user) {
    return { error: 'You must be logged in' }
  }

  // Get business
  const { data: business, error: businessError } = await supabase
    .from('businesses')
    .select('id, name, google_review_link')
    .eq('user_id', user.id)
    .single()

  if (businessError || !business) {
    return { error: 'Business not found' }
  }

  if (!business.google_review_link) {
    return { error: 'Please configure your Google review link first' }
  }

  // Get sample customers
  // Strategy: Mix of repeat and new customers for diverse samples
  const { data: customers, error: customersError } = await supabase
    .from('customers')
    .select('id, name, email, send_count')
    .eq('business_id', business.id)
    .eq('status', 'active')
    .order('send_count', { ascending: false })  // Repeat customers first
    .limit(sampleCount * 2)  // Get more than needed for variety

  if (customersError || !customers || customers.length === 0) {
    return { error: 'No active customers found for preview' }
  }

  // Select diverse sample (mix of repeat and new)
  const selectedCustomers = selectDiverseSample(customers, sampleCount)

  // Build contexts
  const contexts = selectedCustomers.map((customer, index) => ({
    template: input.templateBody,
    customerName: customer.name,
    businessName: business.name,
    serviceType: input.serviceType,
    touchNumber: 1 as const,
    channel: input.channel,
    reviewLink: business.google_review_link!,
    isRepeatCustomer: (customer.send_count || 0) > 0,
    businessId: business.id,
  }))

  // Personalize batch
  const results = await personalizePreviewBatch(contexts, 3)

  return {
    success: true,
    data: results.map((result, index) => ({
      customerId: selectedCustomers[index].id,
      customerName: selectedCustomers[index].name,
      original: input.templateBody,
      personalized: result.message,
      subject: result.subject,
      wasPersonalized: result.personalized,
      fallbackReason: result.fallbackReason,
    })),
  }
}

/**
 * Select diverse sample from customers.
 * Ensures mix of repeat and new customers.
 */
function selectDiverseSample<T extends { send_count: number | null }>(
  customers: T[],
  count: number
): T[] {
  const repeat = customers.filter(c => (c.send_count || 0) > 0)
  const newCustomers = customers.filter(c => (c.send_count || 0) === 0)

  const result: T[] = []

  // Add at least one repeat customer if available
  if (repeat.length > 0) {
    result.push(repeat[0])
  }

  // Add at least one new customer if available
  if (newCustomers.length > 0) {
    result.push(newCustomers[0])
  }

  // Fill remaining with alternating
  let repeatIdx = 1
  let newIdx = 1

  while (result.length < count) {
    if (repeatIdx < repeat.length) {
      result.push(repeat[repeatIdx++])
    } else if (newIdx < newCustomers.length) {
      result.push(newCustomers[newIdx++])
    } else {
      break
    }
  }

  return result.slice(0, count)
}
```

Key decisions:
- Server action pattern matches existing lib/actions/ conventions
- Batch preview limits to 5 samples (cost control)
- Diverse sample selection ensures preview shows repeat + new customers
- Rate limiting enforced via personalizeWithFallback internally
  </action>
  <verify>
TypeScript compiles: `pnpm typecheck` passes.
File exports personalizePreview, personalizePreviewBatchAction.
  </verify>
  <done>Server action provides client-callable personalization interface</done>
</task>

<task type="auto">
  <name>Task 2: Integrate personalization into campaign touch processor</name>
  <files>app/api/cron/process-campaign-touches/route.ts</files>
  <action>
Update `app/api/cron/process-campaign-touches/route.ts` to use LLM personalization:

Add import at top:
```typescript
import { personalizeWithFallback } from '@/lib/ai/fallback'
import type { PersonalizationContext } from '@/lib/ai/prompts'
```

Update `sendEmailTouch` function to personalize before sending:

Replace the section that renders and sends email (lines ~249-276) with:

```typescript
// === Try LLM personalization ===
let personalizedSubject = subject
let personalizedBody: string | null = null
let wasPersonalized = false

// Build personalization context
const personalizationCtx: PersonalizationContext & { businessId: string } = {
  template: template?.body || `Hi ${customer.name}, we'd love to hear about your experience with ${business.name}!`,
  customerName: customer.name,
  businessName: business.name,
  serviceType: touch.service_type || undefined,
  touchNumber: touch.touch_number as 1 | 2 | 3 | 4,
  channel: 'email',
  reviewLink: business.google_review_link!,
  isRepeatCustomer: (customer.send_count || 0) > 0,
  businessId: touch.business_id,
}

const personalizationResult = await personalizeWithFallback(personalizationCtx)

if (personalizationResult.personalized) {
  wasPersonalized = true
  // Use personalized subject if available
  if (personalizationResult.subject) {
    personalizedSubject = personalizationResult.subject
  }
  // Store personalized body for the email
  personalizedBody = personalizationResult.message
}

// Render email with personalized or original content
// For MVP: Use personalized body directly in email HTML
// The ReviewRequestEmail component is bypassed when we have personalized content
let html: string

if (personalizedBody) {
  // Use personalized body directly (includes review link from LLM output)
  // Wrap in simple HTML template
  html = `
    <!DOCTYPE html>
    <html>
    <head><meta charset="utf-8"></head>
    <body style="font-family: sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
      ${personalizedBody.split('\n').map(p => `<p style="margin: 0 0 16px;">${p}</p>`).join('')}
      <hr style="border: none; border-top: 1px solid #eee; margin: 24px 0;" />
      <p style="font-size: 12px; color: #666;">
        <a href="{{unsubscribe_url}}" style="color: #666;">Unsubscribe</a> from future messages
      </p>
    </body>
    </html>
  `.trim()
} else {
  // Fallback: Use original template component
  html = await render(
    ReviewRequestEmail({
      customerName: customer.name,
      businessName: business.name,
      reviewLink: business.google_review_link!,
      senderName,
    })
  )
}

// Send via Resend
const { data: emailData, error: emailError } = await resend.emails.send(
  {
    from: `${senderName} <${RESEND_FROM_EMAIL}>`,
    to: customer.email,
    subject: personalizedSubject,
    html,
    tags: [
      { name: 'send_log_id', value: sendLog.id },
      { name: 'business_id', value: touch.business_id },
      { name: 'campaign_id', value: touch.campaign_id },
      { name: 'enrollment_id', value: touch.enrollment_id },
      { name: 'touch_number', value: String(touch.touch_number) },
      { name: 'personalized', value: wasPersonalized ? 'true' : 'false' },
    ],
  },
  { idempotencyKey: `campaign-touch-${touch.enrollment_id}-${touch.touch_number}` }
)
```

Also update the ClaimedCampaignTouch usage to include service_type. Check if the type includes it, otherwise fetch from job.

Add to the database fetch section (around line ~92) to get service_type:
```typescript
// Also fetch job for service_type
const { data: job } = await supabase
  .from('jobs')
  .select('service_type')
  .eq('id', touch.job_id)
  .single()

const serviceType = job?.service_type
```

Then pass serviceType to sendEmailTouch and use in personalization context.

Key decisions:
- Personalization happens BEFORE email rendering
- Fallback is automatic - never blocks send
- **Personalized body IS used directly** - bypasses ReviewRequestEmail component
- Simple HTML wrapper for personalized content (no complex template needed)
- Subject can be personalized
- Resend tags track whether message was personalized
- Service type fetched from job for context
  </action>
  <verify>
TypeScript compiles: `pnpm typecheck` passes.
Cron route imports personalizeWithFallback from lib/ai/fallback.
Personalized body is used in email HTML when available.
  </verify>
  <done>Campaign touch processor uses LLM personalization with fallback to template, personalized content is used in sent emails</done>
</task>

</tasks>

<verification>
All verification commands should pass:

```bash
pnpm typecheck
pnpm lint
```

Check integration:
- lib/actions/personalize.ts exports server actions
- Cron route imports and uses personalizeWithFallback
- Personalization failure falls back silently (console.warn, not throw)
- Personalized body is used directly in email HTML (not ignored)
</verification>

<success_criteria>
- personalizePreview server action returns personalized message or fallback
- personalizePreviewBatchAction returns 3-5 diverse samples
- Campaign touch processor calls personalizeWithFallback before sending
- Personalized body is used in sent emails (not just subject)
- Personalization failure falls back to template - sends still happen
- Send log tags include 'personalized: true/false' for tracking
</success_criteria>

<output>
After completion, create `.planning/phases/25-llm-personalization/25-04-SUMMARY.md`
</output>
