---
phase: 01-foundation-auth
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00001_create_profiles.sql
autonomous: true
user_setup:
  - service: supabase
    why: "Database migrations via Supabase CLI or Dashboard"
    dashboard_config:
      - task: "Run SQL migration in SQL Editor"
        location: "Supabase Dashboard -> SQL Editor -> New Query"

must_haves:
  truths:
    - "Profiles table exists in Supabase database"
    - "RLS is enabled on profiles table"
    - "Users can only read their own profile"
    - "Users can only insert their own profile"
    - "Users can only update their own profile"
  artifacts:
    - path: "supabase/migrations/00001_create_profiles.sql"
      provides: "Database schema and RLS policies"
      contains: "ENABLE ROW LEVEL SECURITY"
  key_links:
    - from: "profiles table"
      to: "auth.uid()"
      via: "RLS policies using (SELECT auth.uid()) = user_id"
      pattern: "\\(SELECT auth\\.uid\\(\\)\\)"
---

<objective>
Create database foundation with RLS-enabled profiles table for user data isolation.

Purpose: Establish multi-tenant data security from day 1. Without RLS, user data could leak across accounts.
Output: Profiles table with user_id reference and RLS policies preventing cross-user data access.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-auth/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create profiles table with RLS policies</name>
  <files>
    supabase/migrations/00001_create_profiles.sql
  </files>
  <action>
Create the migration directory and SQL file with profiles table and RLS policies.

```sql
-- Migration: 00001_create_profiles
-- Purpose: User profile storage with RLS for multi-tenant isolation

-- Create profiles table
-- Links to auth.users via user_id, stores additional user metadata
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  email TEXT,
  full_name TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT profiles_user_id_unique UNIQUE (user_id)
);

-- CRITICAL: Enable Row Level Security immediately
-- Without this, all users can see all profiles
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Performance: Index on user_id for RLS policy efficiency
-- Wrap auth.uid() in SELECT to cache result per statement
CREATE INDEX IF NOT EXISTS idx_profiles_user_id ON public.profiles USING btree (user_id);

-- Policy: Users can view only their own profile
CREATE POLICY "Users view own profile"
ON public.profiles FOR SELECT
TO authenticated
USING ((SELECT auth.uid()) = user_id);

-- Policy: Users can insert only their own profile
CREATE POLICY "Users insert own profile"
ON public.profiles FOR INSERT
TO authenticated
WITH CHECK ((SELECT auth.uid()) = user_id);

-- Policy: Users can update only their own profile
CREATE POLICY "Users update own profile"
ON public.profiles FOR UPDATE
TO authenticated
USING ((SELECT auth.uid()) = user_id)
WITH CHECK ((SELECT auth.uid()) = user_id);

-- Policy: Users can delete only their own profile
CREATE POLICY "Users delete own profile"
ON public.profiles FOR DELETE
TO authenticated
USING ((SELECT auth.uid()) = user_id);

-- Trigger: Auto-create profile on user signup
-- This ensures every auth.users entry has a corresponding profile
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (user_id, email, full_name)
  VALUES (
    NEW.id,
    NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'full_name', '')
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger if it doesn't exist
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Trigger: Update updated_at timestamp on profile changes
CREATE OR REPLACE FUNCTION public.update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS profiles_updated_at ON public.profiles;
CREATE TRIGGER profiles_updated_at
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();
```

Create the supabase/migrations directory first if it doesn't exist.

NOTE: This migration must be run in Supabase Dashboard SQL Editor or via Supabase CLI (`supabase db push`). The execute-plan workflow will handle prompting the user for this.
  </action>
  <verify>
- `supabase/migrations/00001_create_profiles.sql` exists
- File contains CREATE TABLE profiles
- File contains ENABLE ROW LEVEL SECURITY
- File contains at least 4 policies (SELECT, INSERT, UPDATE, DELETE)
- File contains trigger for auto-creating profile on signup
  </verify>
  <done>Profiles table migration ready with RLS policies and auto-profile trigger</done>
</task>

<task type="auto">
  <name>Task 2: Create RLS verification query</name>
  <files>
    supabase/verify_rls.sql
  </files>
  <action>
Create a verification query that can be run to confirm RLS is properly configured:

```sql
-- Verification query: Run this to confirm RLS is enabled and policies exist
-- Expected output: profiles table should show rowsecurity = true

-- Check 1: RLS is enabled on profiles
SELECT
  schemaname,
  tablename,
  rowsecurity
FROM pg_tables
WHERE schemaname = 'public'
  AND tablename = 'profiles';

-- Check 2: Policies exist for profiles table
SELECT
  policyname,
  cmd,
  qual,
  with_check
FROM pg_policies
WHERE schemaname = 'public'
  AND tablename = 'profiles';

-- Check 3: Index exists for performance
SELECT
  indexname,
  indexdef
FROM pg_indexes
WHERE schemaname = 'public'
  AND tablename = 'profiles';
```

This query helps verify the migration was applied correctly.
  </action>
  <verify>
- `supabase/verify_rls.sql` exists
- Contains queries to check rowsecurity, pg_policies, and pg_indexes
  </verify>
  <done>RLS verification query created for post-migration validation</done>
</task>

</tasks>

<verification>
After migration is run in Supabase:
1. Run `supabase/verify_rls.sql` in SQL Editor
2. Confirm profiles table shows `rowsecurity = true`
3. Confirm 4 policies exist (view, insert, update, delete)
4. Confirm index idx_profiles_user_id exists
</verification>

<success_criteria>
- Migration file exists in supabase/migrations/
- RLS enabled on profiles table
- Four RLS policies created (SELECT, INSERT, UPDATE, DELETE)
- Trigger auto-creates profile on user signup
- Performance index on user_id column
- Verification query ready for testing
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-auth/01-02-SUMMARY.md`
</output>
