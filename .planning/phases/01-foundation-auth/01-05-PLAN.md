---
phase: 01-foundation-auth
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00001_create_profiles.sql
  - supabase/verify_rls.sql
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Profiles table migration file exists for database setup"
    - "RLS is enabled in the migration"
    - "Auto-profile trigger creates profile on user signup"
  artifacts:
    - path: "supabase/migrations/00001_create_profiles.sql"
      provides: "Database migration for profiles table"
      contains: "CREATE TABLE"
      min_lines: 40
    - path: "supabase/verify_rls.sql"
      provides: "RLS verification queries"
      min_lines: 10
  key_links:
    - from: "supabase/migrations/00001_create_profiles.sql"
      to: "auth.users"
      via: "foreign key reference"
      pattern: "REFERENCES auth\\.users"
    - from: "supabase/migrations/00001_create_profiles.sql"
      to: "auth.uid()"
      via: "RLS policy"
      pattern: "auth\\.uid\\(\\)"
---

<objective>
Create the database migration file for the profiles table with RLS policies.

Purpose: Plan 01-02 created the migration content but the file was not persisted to disk (supabase/migrations/ directory does not exist). This creates the migration files so they exist for user to run in Supabase Dashboard.

Output: Migration file ready for user to execute in Supabase SQL Editor.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-auth/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create supabase migrations directory and profiles migration</name>
  <files>supabase/migrations/00001_create_profiles.sql</files>
  <action>
1. Create directory: `supabase/migrations/`
2. Create file `supabase/migrations/00001_create_profiles.sql` with:

```sql
-- Create profiles table linked to auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name TEXT,
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  UNIQUE(user_id)
);

-- Enable Row Level Security
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- RLS Policies using (SELECT auth.uid()) for performance
-- SELECT: Users can view only their own profile
CREATE POLICY "Users view own profile"
  ON public.profiles FOR SELECT
  USING ((SELECT auth.uid()) = user_id);

-- INSERT: Users can insert only their own profile
CREATE POLICY "Users insert own profile"
  ON public.profiles FOR INSERT
  WITH CHECK ((SELECT auth.uid()) = user_id);

-- UPDATE: Users can update only their own profile
CREATE POLICY "Users update own profile"
  ON public.profiles FOR UPDATE
  USING ((SELECT auth.uid()) = user_id);

-- DELETE: Users can delete only their own profile
CREATE POLICY "Users delete own profile"
  ON public.profiles FOR DELETE
  USING ((SELECT auth.uid()) = user_id);

-- Index for faster lookups
CREATE INDEX IF NOT EXISTS idx_profiles_user_id ON public.profiles(user_id);

-- Auto-update updated_at timestamp
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER profiles_updated_at
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_updated_at();

-- Auto-create profile on user signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  INSERT INTO public.profiles (user_id, full_name)
  VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger on auth.users insert
CREATE OR REPLACE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_user();
```

Key patterns from 01-02-SUMMARY decisions:
- Use `(SELECT auth.uid())` wrapper for RLS policies (caches result, better performance)
- Use `SECURITY DEFINER` on handle_new_user (required to insert from auth.users trigger)
- Use `ON DELETE CASCADE` for user_id FK (cleanup profiles when users deleted)
  </action>
  <verify>
1. `ls supabase/migrations/00001_create_profiles.sql` confirms file exists
2. `grep "CREATE TABLE" supabase/migrations/00001_create_profiles.sql` shows table creation
3. `grep "ENABLE ROW LEVEL SECURITY" supabase/migrations/00001_create_profiles.sql` shows RLS enabled
4. `grep "SELECT auth.uid()" supabase/migrations/00001_create_profiles.sql` shows optimized pattern
5. `grep "SECURITY DEFINER" supabase/migrations/00001_create_profiles.sql` shows trigger security
  </verify>
  <done>
- supabase/migrations/ directory exists
- 00001_create_profiles.sql contains profiles table, RLS policies, triggers
- File ready for user to run in Supabase Dashboard
  </done>
</task>

<task type="auto">
  <name>Task 2: Create RLS verification query file</name>
  <files>supabase/verify_rls.sql</files>
  <action>
Create `supabase/verify_rls.sql` with verification queries user can run to confirm RLS is working:

```sql
-- Verify RLS is enabled on profiles table
SELECT
  tablename,
  rowsecurity
FROM pg_tables
WHERE schemaname = 'public' AND tablename = 'profiles';
-- Expected: rowsecurity = true

-- Verify RLS policies exist
SELECT
  policyname,
  cmd,
  qual
FROM pg_policies
WHERE schemaname = 'public' AND tablename = 'profiles';
-- Expected: 4 policies (SELECT, INSERT, UPDATE, DELETE)

-- Verify index exists
SELECT indexname
FROM pg_indexes
WHERE schemaname = 'public' AND tablename = 'profiles';
-- Expected: idx_profiles_user_id

-- Verify trigger exists
SELECT trigger_name, event_manipulation
FROM information_schema.triggers
WHERE event_object_table = 'profiles';
-- Expected: profiles_updated_at trigger
```
  </action>
  <verify>
1. `ls supabase/verify_rls.sql` confirms file exists
2. `grep "pg_policies" supabase/verify_rls.sql` shows policy verification
  </verify>
  <done>
- verify_rls.sql exists with queries to validate RLS setup
  </done>
</task>

</tasks>

<verification>
1. Both files exist in supabase/ directory
2. Migration has all required components (table, RLS, policies, triggers)
3. Verification file has queries for validation
</verification>

<success_criteria>
- supabase/migrations/00001_create_profiles.sql exists with complete migration
- supabase/verify_rls.sql exists with verification queries
- Files are ready for user to execute in Supabase Dashboard SQL Editor
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-auth/01-05-SUMMARY.md`
</output>
