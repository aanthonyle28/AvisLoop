---
phase: 01-foundation-auth
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/actions/auth.ts
  - src/lib/validations/auth.ts
  - src/app/auth/confirm/route.ts
autonomous: true

must_haves:
  truths:
    - "signUp action validates input and creates user in Supabase"
    - "signIn action authenticates user and sets session cookie"
    - "signOut action clears session and redirects to login"
    - "resetPassword action sends password reset email"
    - "updatePassword action changes password for authenticated user"
    - "Email confirmation callback validates token and redirects"
  artifacts:
    - path: "src/lib/actions/auth.ts"
      provides: "Server Actions for all auth mutations"
      exports: ["signUp", "signIn", "signOut", "resetPassword", "updatePassword"]
    - path: "src/lib/validations/auth.ts"
      provides: "Zod schemas for auth input validation"
      exports: ["signUpSchema", "signInSchema", "resetPasswordSchema", "updatePasswordSchema"]
    - path: "src/app/auth/confirm/route.ts"
      provides: "Email confirmation callback handler"
      exports: ["GET"]
  key_links:
    - from: "src/lib/actions/auth.ts"
      to: "src/lib/supabase/server.ts"
      via: "createClient import"
      pattern: "import.*createClient.*from.*supabase/server"
    - from: "src/lib/actions/auth.ts"
      to: "src/lib/validations/auth.ts"
      via: "Zod schema imports"
      pattern: "import.*Schema.*from.*validations/auth"
    - from: "src/app/auth/confirm/route.ts"
      to: "supabase.auth.verifyOtp"
      via: "PKCE token validation"
      pattern: "verifyOtp"
---

<objective>
Implement all authentication Server Actions and email confirmation route.

Purpose: Provide the backend logic for signup, login, logout, and password reset flows. These actions are called by the auth UI forms.
Output: Type-safe Server Actions with Zod validation and PKCE-compatible email confirmation handler.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-auth/01-RESEARCH.md
@.planning/phases/01-foundation-auth/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zod validation schemas for auth</name>
  <files>
    src/lib/validations/auth.ts
  </files>
  <action>
Create validation schemas for all auth inputs:

```typescript
import { z } from 'zod'

export const signUpSchema = z.object({
  email: z
    .string()
    .min(1, 'Email is required')
    .email('Please enter a valid email address'),
  password: z
    .string()
    .min(8, 'Password must be at least 8 characters')
    .max(72, 'Password must be less than 72 characters'),
  fullName: z
    .string()
    .min(1, 'Full name is required')
    .max(100, 'Full name must be less than 100 characters')
    .optional(),
})

export const signInSchema = z.object({
  email: z
    .string()
    .min(1, 'Email is required')
    .email('Please enter a valid email address'),
  password: z
    .string()
    .min(1, 'Password is required'),
})

export const resetPasswordSchema = z.object({
  email: z
    .string()
    .min(1, 'Email is required')
    .email('Please enter a valid email address'),
})

export const updatePasswordSchema = z.object({
  password: z
    .string()
    .min(8, 'Password must be at least 8 characters')
    .max(72, 'Password must be less than 72 characters'),
  confirmPassword: z
    .string()
    .min(1, 'Please confirm your password'),
}).refine((data) => data.password === data.confirmPassword, {
  message: 'Passwords do not match',
  path: ['confirmPassword'],
})

// Type exports for use in forms
export type SignUpInput = z.infer<typeof signUpSchema>
export type SignInInput = z.infer<typeof signInSchema>
export type ResetPasswordInput = z.infer<typeof resetPasswordSchema>
export type UpdatePasswordInput = z.infer<typeof updatePasswordSchema>
```
  </action>
  <verify>
- File exports signUpSchema, signInSchema, resetPasswordSchema, updatePasswordSchema
- Each schema has appropriate validation rules
- Type exports exist for form integration
  </verify>
  <done>Zod validation schemas created for all auth inputs</done>
</task>

<task type="auto">
  <name>Task 2: Create auth Server Actions</name>
  <files>
    src/lib/actions/auth.ts
  </files>
  <action>
Create Server Actions for all auth operations. Each action:
- Uses 'use server' directive
- Validates input with Zod before calling Supabase
- Returns structured errors (never throws)
- Uses revalidatePath after state changes
- Uses redirect for navigation

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { redirect } from 'next/navigation'
import {
  signUpSchema,
  signInSchema,
  resetPasswordSchema,
  updatePasswordSchema,
} from '@/lib/validations/auth'

export type AuthActionState = {
  error?: string
  fieldErrors?: Record<string, string[]>
  success?: boolean
}

export async function signUp(
  _prevState: AuthActionState | null,
  formData: FormData
): Promise<AuthActionState> {
  const supabase = await createClient()

  const parsed = signUpSchema.safeParse({
    email: formData.get('email'),
    password: formData.get('password'),
    fullName: formData.get('fullName'),
  })

  if (!parsed.success) {
    return { fieldErrors: parsed.error.flatten().fieldErrors }
  }

  const { email, password, fullName } = parsed.data

  const { error } = await supabase.auth.signUp({
    email,
    password,
    options: {
      emailRedirectTo: `${process.env.NEXT_PUBLIC_SITE_URL}/auth/confirm`,
      data: {
        full_name: fullName || '',
      },
    },
  })

  if (error) {
    return { error: error.message }
  }

  redirect('/verify-email')
}

export async function signIn(
  _prevState: AuthActionState | null,
  formData: FormData
): Promise<AuthActionState> {
  const supabase = await createClient()

  const parsed = signInSchema.safeParse({
    email: formData.get('email'),
    password: formData.get('password'),
  })

  if (!parsed.success) {
    return { fieldErrors: parsed.error.flatten().fieldErrors }
  }

  const { email, password } = parsed.data

  const { error } = await supabase.auth.signInWithPassword({
    email,
    password,
  })

  if (error) {
    return { error: error.message }
  }

  revalidatePath('/', 'layout')
  redirect('/dashboard')
}

export async function signOut(): Promise<never> {
  const supabase = await createClient()
  await supabase.auth.signOut()
  revalidatePath('/', 'layout')
  redirect('/login')
}

export async function resetPassword(
  _prevState: AuthActionState | null,
  formData: FormData
): Promise<AuthActionState> {
  const supabase = await createClient()

  const parsed = resetPasswordSchema.safeParse({
    email: formData.get('email'),
  })

  if (!parsed.success) {
    return { fieldErrors: parsed.error.flatten().fieldErrors }
  }

  const { email } = parsed.data

  const { error } = await supabase.auth.resetPasswordForEmail(email, {
    redirectTo: `${process.env.NEXT_PUBLIC_SITE_URL}/update-password`,
  })

  if (error) {
    return { error: error.message }
  }

  return { success: true }
}

export async function updatePassword(
  _prevState: AuthActionState | null,
  formData: FormData
): Promise<AuthActionState> {
  const supabase = await createClient()

  const parsed = updatePasswordSchema.safeParse({
    password: formData.get('password'),
    confirmPassword: formData.get('confirmPassword'),
  })

  if (!parsed.success) {
    return { fieldErrors: parsed.error.flatten().fieldErrors }
  }

  const { password } = parsed.data

  const { error } = await supabase.auth.updateUser({ password })

  if (error) {
    return { error: error.message }
  }

  revalidatePath('/', 'layout')
  redirect('/dashboard')
}
```
  </action>
  <verify>
- File has 'use server' directive at top
- Exports signUp, signIn, signOut, resetPassword, updatePassword
- Each action validates with Zod before Supabase call
- Actions return AuthActionState (never throw)
- signOut always calls redirect (return type never)
  </verify>
  <done>Auth Server Actions created with Zod validation and proper error handling</done>
</task>

<task type="auto">
  <name>Task 3: Create email confirmation route handler</name>
  <files>
    src/app/auth/confirm/route.ts
  </files>
  <action>
Create the route handler for email confirmation links. This handles the PKCE flow where users click a link with token_hash:

```typescript
import { createClient } from '@/lib/supabase/server'
import { NextResponse, type NextRequest } from 'next/server'

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url)
  const token_hash = searchParams.get('token_hash')
  const type = searchParams.get('type') as
    | 'signup'
    | 'email'
    | 'recovery'
    | 'invite'
    | 'magiclink'
    | null

  // Construct redirect URLs
  const redirectTo = new URL('/dashboard', request.url)
  const errorRedirect = new URL('/login', request.url)

  if (!token_hash || !type) {
    errorRedirect.searchParams.set('error', 'Invalid confirmation link')
    return NextResponse.redirect(errorRedirect)
  }

  const supabase = await createClient()

  const { error } = await supabase.auth.verifyOtp({
    type,
    token_hash,
  })

  if (error) {
    console.error('Email confirmation error:', error.message)
    errorRedirect.searchParams.set('error', error.message)
    return NextResponse.redirect(errorRedirect)
  }

  // For recovery (password reset), redirect to update password page
  if (type === 'recovery') {
    return NextResponse.redirect(new URL('/update-password', request.url))
  }

  // For signup/email confirmation, redirect to dashboard
  return NextResponse.redirect(redirectTo)
}
```

This route:
- Extracts token_hash and type from URL params
- Validates the token with Supabase verifyOtp
- Redirects to appropriate page based on type
- Handles errors gracefully with error message in URL
  </action>
  <verify>
- File exists at src/app/auth/confirm/route.ts
- Exports GET function
- Uses verifyOtp with token_hash (PKCE flow)
- Handles recovery type differently (redirect to update-password)
- Returns NextResponse.redirect on success and error
  </verify>
  <done>Email confirmation route handler created with PKCE flow support</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. TypeScript compiles without errors: `npm run build`
2. All auth actions are exported from src/lib/actions/auth.ts
3. Validation schemas exist in src/lib/validations/auth.ts
4. Email confirmation route exists at src/app/auth/confirm/route.ts
</verification>

<success_criteria>
- Zod schemas validate all auth inputs
- Server Actions handle signup, signin, signout, password reset, password update
- Actions return structured errors, never throw
- Email confirmation route handles PKCE token validation
- TypeScript types exported for form integration
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-auth/01-03-SUMMARY.md`
</output>
