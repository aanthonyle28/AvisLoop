---
phase: 26-review-funnel
plan: 03
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - lib/types/feedback.ts
  - lib/validations/feedback.ts
  - lib/data/feedback.ts
autonomous: true

must_haves:
  truths:
    - "Feedback type matches customer_feedback table schema"
    - "Zod validation enforces rating 1-5 and optional text max 5000 chars"
    - "Data functions support CRUD with business scope"
    - "Unresolved feedback query uses partial index"
  artifacts:
    - path: "lib/types/feedback.ts"
      provides: "TypeScript types for customer feedback"
      exports: ["CustomerFeedback", "FeedbackWithCustomer"]
    - path: "lib/validations/feedback.ts"
      provides: "Zod schemas for feedback"
      exports: ["feedbackSchema", "resolveFeedbackSchema"]
    - path: "lib/data/feedback.ts"
      provides: "Database CRUD operations"
      exports: ["getFeedback", "getFeedbackForBusiness", "createFeedback", "resolveFeedback"]
  key_links:
    - from: "lib/data/feedback.ts"
      to: "lib/supabase/service-role.ts"
      via: "import for public insert"
      pattern: "createServiceRoleClient"
---

<objective>
Create TypeScript types, Zod validations, and data functions for customer feedback.

Purpose: Provides type safety and database access patterns for feedback storage and retrieval, enabling the API route and dashboard components.
Output: Type definitions, validation schemas, and data access functions for feedback CRUD operations.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-review-funnel/26-RESEARCH.md
@.planning/phases/26-review-funnel/26-01-PLAN.md
@lib/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create feedback TypeScript types</name>
  <files>lib/types/feedback.ts</files>
  <action>
Create lib/types/feedback.ts with TypeScript interfaces matching the customer_feedback table schema.

```typescript
/**
 * Customer Feedback Types
 * Phase 26: Review Funnel
 *
 * Feedback is collected from customers who rate their experience 1-3 stars.
 * Higher ratings (4-5) are routed to Google reviews instead.
 */

/**
 * Base feedback record from customer_feedback table.
 */
export interface CustomerFeedback {
  id: string
  business_id: string
  customer_id: string
  enrollment_id: string | null

  // Rating and content
  rating: number // 1-5, though typically 1-3 for feedback path
  feedback_text: string | null

  // Timestamps
  submitted_at: string
  created_at: string
  updated_at: string

  // Resolution workflow
  resolved_at: string | null
  resolved_by: string | null
  internal_notes: string | null
}

/**
 * Feedback with customer details for dashboard display.
 */
export interface FeedbackWithCustomer extends CustomerFeedback {
  customer: {
    id: string
    name: string
    email: string
    phone: string | null
  }
}

/**
 * Feedback with full relations (customer + resolver user).
 */
export interface FeedbackWithRelations extends FeedbackWithCustomer {
  resolved_by_user?: {
    email: string
  } | null
}

/**
 * Input for creating new feedback (from public form).
 */
export interface CreateFeedbackInput {
  business_id: string
  customer_id: string
  enrollment_id?: string
  rating: number
  feedback_text?: string
}

/**
 * Input for resolving feedback (from dashboard).
 */
export interface ResolveFeedbackInput {
  id: string
  internal_notes?: string
}

/**
 * Feedback list filters for dashboard.
 */
export interface FeedbackFilters {
  resolved?: boolean // true = resolved only, false = unresolved only, undefined = all
  rating?: number // filter by specific rating
  search?: string // search customer name or feedback text
}

/**
 * Stats for feedback dashboard.
 */
export interface FeedbackStats {
  total: number
  unresolved: number
  averageRating: number
  byRating: Record<number, number> // { 1: 5, 2: 3, 3: 10 }
}
```
  </action>
  <verify>
Run: `dir lib\types\feedback.ts` to confirm file exists.
Run: `grep -n "export interface" lib/types/feedback.ts` to confirm exports exist.
Run: `pnpm typecheck` to verify TypeScript compiles.
  </verify>
  <done>Feedback types exist with CustomerFeedback (base), FeedbackWithCustomer (for dashboard), CreateFeedbackInput, ResolveFeedbackInput, and FeedbackFilters interfaces.</done>
</task>

<task type="auto">
  <name>Task 2: Create feedback Zod validations</name>
  <files>lib/validations/feedback.ts</files>
  <action>
Create lib/validations/feedback.ts with Zod schemas for feedback creation and resolution.

```typescript
import { z } from 'zod'

/**
 * Schema for creating feedback from public review page.
 * Rating is required, text is optional but limited.
 */
export const feedbackSchema = z.object({
  token: z.string().min(1, 'Token is required'),
  rating: z
    .number()
    .int('Rating must be a whole number')
    .min(1, 'Rating must be at least 1')
    .max(5, 'Rating must be at most 5'),
  feedback_text: z
    .string()
    .max(5000, 'Feedback must be less than 5000 characters')
    .optional()
    .transform((val) => val?.trim() || undefined),
})

export type FeedbackInput = z.infer<typeof feedbackSchema>

/**
 * Schema for rating-only submission (before feedback form).
 * Used when 4-5 stars selected (no feedback text needed).
 */
export const ratingSchema = z.object({
  token: z.string().min(1, 'Token is required'),
  rating: z
    .number()
    .int('Rating must be a whole number')
    .min(1, 'Rating must be at least 1')
    .max(5, 'Rating must be at most 5'),
})

export type RatingInput = z.infer<typeof ratingSchema>

/**
 * Schema for resolving feedback from dashboard.
 * Internal notes are optional.
 */
export const resolveFeedbackSchema = z.object({
  id: z.string().uuid('Invalid feedback ID'),
  internal_notes: z
    .string()
    .max(2000, 'Notes must be less than 2000 characters')
    .optional()
    .transform((val) => val?.trim() || undefined),
})

export type ResolveFeedbackInput = z.infer<typeof resolveFeedbackSchema>

/**
 * Schema for feedback list query params.
 */
export const feedbackFiltersSchema = z.object({
  resolved: z.boolean().optional(),
  rating: z.number().int().min(1).max(5).optional(),
  search: z.string().max(100).optional(),
  page: z.number().int().min(1).optional().default(1),
  limit: z.number().int().min(1).max(100).optional().default(20),
})

export type FeedbackFiltersInput = z.infer<typeof feedbackFiltersSchema>
```
  </action>
  <verify>
Run: `dir lib\validations\feedback.ts` to confirm file exists.
Run: `grep -n "export const\|export type" lib/validations/feedback.ts` to confirm exports exist.
Run: `pnpm typecheck` to verify TypeScript compiles.
  </verify>
  <done>Feedback validations exist with feedbackSchema (public form), ratingSchema (rating only), resolveFeedbackSchema (dashboard), and feedbackFiltersSchema (list queries).</done>
</task>

<task type="auto">
  <name>Task 3: Create feedback data functions</name>
  <files>lib/data/feedback.ts</files>
  <action>
Create lib/data/feedback.ts with database CRUD operations for feedback.

```typescript
import { createClient } from '@/lib/supabase/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import type {
  CustomerFeedback,
  FeedbackWithCustomer,
  CreateFeedbackInput,
  FeedbackFilters,
  FeedbackStats,
} from '@/lib/types/feedback'

/**
 * Get a single feedback record by ID.
 * Requires authenticated user with business access (RLS enforced).
 */
export async function getFeedback(id: string): Promise<FeedbackWithCustomer | null> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('customer_feedback')
    .select(`
      *,
      customer:customers(id, name, email, phone)
    `)
    .eq('id', id)
    .single()

  if (error || !data) {
    console.error('getFeedback error:', error)
    return null
  }

  return data as unknown as FeedbackWithCustomer
}

/**
 * Get feedback list for a business with optional filters.
 * Uses partial index for unresolved queries (fast).
 */
export async function getFeedbackForBusiness(
  businessId: string,
  filters: FeedbackFilters = {},
  page = 1,
  limit = 20
): Promise<{ data: FeedbackWithCustomer[]; total: number }> {
  const supabase = await createClient()

  let query = supabase
    .from('customer_feedback')
    .select(`
      *,
      customer:customers(id, name, email, phone)
    `, { count: 'exact' })
    .eq('business_id', businessId)
    .order('submitted_at', { ascending: false })

  // Apply resolved filter (uses partial index when false)
  if (filters.resolved === true) {
    query = query.not('resolved_at', 'is', null)
  } else if (filters.resolved === false) {
    query = query.is('resolved_at', null)
  }

  // Apply rating filter
  if (filters.rating) {
    query = query.eq('rating', filters.rating)
  }

  // Apply search filter (customer name or feedback text)
  if (filters.search) {
    query = query.or(`feedback_text.ilike.%${filters.search}%,customer.name.ilike.%${filters.search}%`)
  }

  // Apply pagination
  const from = (page - 1) * limit
  const to = from + limit - 1
  query = query.range(from, to)

  const { data, count, error } = await query

  if (error) {
    console.error('getFeedbackForBusiness error:', error)
    return { data: [], total: 0 }
  }

  return {
    data: (data || []) as unknown as FeedbackWithCustomer[],
    total: count || 0,
  }
}

/**
 * Get unresolved feedback count for a business.
 * Used for dashboard alerts/badges.
 */
export async function getUnresolvedFeedbackCount(businessId: string): Promise<number> {
  const supabase = await createClient()

  const { count, error } = await supabase
    .from('customer_feedback')
    .select('*', { count: 'exact', head: true })
    .eq('business_id', businessId)
    .is('resolved_at', null)

  if (error) {
    console.error('getUnresolvedFeedbackCount error:', error)
    return 0
  }

  return count || 0
}

/**
 * Get feedback statistics for a business.
 */
export async function getFeedbackStats(businessId: string): Promise<FeedbackStats> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('customer_feedback')
    .select('rating, resolved_at')
    .eq('business_id', businessId)

  if (error || !data) {
    console.error('getFeedbackStats error:', error)
    return { total: 0, unresolved: 0, averageRating: 0, byRating: {} }
  }

  const total = data.length
  const unresolved = data.filter((f) => !f.resolved_at).length
  const averageRating = total > 0 ? data.reduce((sum, f) => sum + f.rating, 0) / total : 0
  const byRating: Record<number, number> = {}
  data.forEach((f) => {
    byRating[f.rating] = (byRating[f.rating] || 0) + 1
  })

  return { total, unresolved, averageRating: Math.round(averageRating * 10) / 10, byRating }
}

/**
 * Create feedback from public review page.
 * Uses service role client (bypasses RLS for public insert).
 * Token validation happens in API route before calling this.
 */
export async function createFeedback(input: CreateFeedbackInput): Promise<CustomerFeedback | null> {
  const supabase = createServiceRoleClient()

  const { data, error } = await supabase
    .from('customer_feedback')
    .insert({
      business_id: input.business_id,
      customer_id: input.customer_id,
      enrollment_id: input.enrollment_id || null,
      rating: input.rating,
      feedback_text: input.feedback_text || null,
    })
    .select()
    .single()

  if (error) {
    console.error('createFeedback error:', error)
    return null
  }

  return data as CustomerFeedback
}

/**
 * Resolve feedback (mark as addressed by business owner).
 * Requires authenticated user with business access (RLS enforced).
 */
export async function resolveFeedback(
  feedbackId: string,
  userId: string,
  internalNotes?: string
): Promise<CustomerFeedback | null> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('customer_feedback')
    .update({
      resolved_at: new Date().toISOString(),
      resolved_by: userId,
      internal_notes: internalNotes || null,
    })
    .eq('id', feedbackId)
    .select()
    .single()

  if (error) {
    console.error('resolveFeedback error:', error)
    return null
  }

  return data as CustomerFeedback
}

/**
 * Unresolve feedback (reopen for follow-up).
 */
export async function unresolveFeedback(feedbackId: string): Promise<CustomerFeedback | null> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('customer_feedback')
    .update({
      resolved_at: null,
      resolved_by: null,
    })
    .eq('id', feedbackId)
    .select()
    .single()

  if (error) {
    console.error('unresolveFeedback error:', error)
    return null
  }

  return data as CustomerFeedback
}
```
  </action>
  <verify>
Run: `dir lib\data\feedback.ts` to confirm file exists.
Run: `grep -n "export async function" lib/data/feedback.ts` to confirm exports exist.
Run: `pnpm typecheck` to verify TypeScript compiles.
  </verify>
  <done>Feedback data functions exist with getFeedback, getFeedbackForBusiness (with filters + pagination), getUnresolvedFeedbackCount, getFeedbackStats, createFeedback (service role), resolveFeedback, and unresolveFeedback.</done>
</task>

</tasks>

<verification>
1. Types file exists: `dir lib\types\feedback.ts`
2. Validations file exists: `dir lib\validations\feedback.ts`
3. Data file exists: `dir lib\data\feedback.ts`
4. Data functions use service role for public insert: `grep -n "createServiceRoleClient" lib/data/feedback.ts`
5. TypeScript compiles: `pnpm typecheck`
6. Lint passes: `pnpm lint`
</verification>

<success_criteria>
- lib/types/feedback.ts exists with CustomerFeedback, FeedbackWithCustomer, CreateFeedbackInput, ResolveFeedbackInput interfaces
- lib/validations/feedback.ts exists with feedbackSchema, ratingSchema, resolveFeedbackSchema, feedbackFiltersSchema
- lib/data/feedback.ts exists with CRUD functions using proper Supabase clients
- createFeedback uses service role client for public insert
- getFeedbackForBusiness supports filters and pagination
- All TypeScript compiles without errors
- Lint passes
</success_criteria>

<output>
After completion, create `.planning/phases/26-review-funnel/26-03-SUMMARY.md`
</output>
