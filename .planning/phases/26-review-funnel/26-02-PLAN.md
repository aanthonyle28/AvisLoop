---
phase: 26-review-funnel
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/review/token.ts
autonomous: true

must_haves:
  truths:
    - "Token encodes customerId, businessId, enrollmentId, and timestamp"
    - "Token uses base64url encoding for URL safety"
    - "Token expiration enforced at 30 days"
    - "Invalid tokens return null (no exceptions thrown)"
  artifacts:
    - path: "lib/review/token.ts"
      provides: "Token generation and parsing utilities"
      exports: ["generateReviewToken", "parseReviewToken"]
      min_lines: 40
  key_links:
    - from: "lib/review/token.ts"
      to: "Node crypto module"
      via: "randomBytes import"
      pattern: "import.*crypto"
---

<objective>
Create token utilities for generating and parsing secure review URLs that identify customers without authentication.

Purpose: Review links in emails/SMS need to identify the customer, business, and campaign enrollment without requiring login. Tokens must be secure (unpredictable) and time-limited.
Output: Token module with generate and parse functions using cryptographically secure random data.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-review-funnel/26-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create review token utilities</name>
  <files>lib/review/token.ts</files>
  <action>
Create lib/review directory if needed, then create token.ts with secure token generation and parsing.

```typescript
import { randomBytes } from 'crypto'

// Token expiration: 30 days in milliseconds
const TOKEN_EXPIRY_MS = 30 * 24 * 60 * 60 * 1000

export interface ReviewTokenPayload {
  customerId: string
  businessId: string
  enrollmentId?: string
  timestamp: number
}

/**
 * Generate a secure, URL-safe review token.
 * Token encodes customer, business, and optional enrollment IDs with timestamp.
 * Uses cryptographically secure random data to prevent guessing.
 *
 * @example
 * const token = generateReviewToken({
 *   customerId: 'uuid-1',
 *   businessId: 'uuid-2',
 *   enrollmentId: 'uuid-3'
 * })
 * // Returns: base64url encoded string like "dXVpZC0xOnV1aWQtMjp1dWlkLTM6MTcwNDEyMzQ1Njc4OTphYmNkZWYxMjM0NTY3ODkw"
 */
export function generateReviewToken(params: {
  customerId: string
  businessId: string
  enrollmentId?: string
}): string {
  const timestamp = Date.now()
  const random = randomBytes(16).toString('hex')

  // Format: customerId:businessId:enrollmentId:timestamp:random
  // enrollmentId is empty string if not provided
  const payload = [
    params.customerId,
    params.businessId,
    params.enrollmentId || '',
    timestamp.toString(),
    random,
  ].join(':')

  // Use base64url encoding for URL safety (no +, /, or = padding issues)
  return Buffer.from(payload).toString('base64url')
}

/**
 * Parse and validate a review token.
 * Returns null if token is invalid, expired, or malformed.
 * Does NOT throw exceptions - callers check for null.
 *
 * @example
 * const data = parseReviewToken(token)
 * if (!data) {
 *   return notFound()
 * }
 * const { customerId, businessId, enrollmentId } = data
 */
export function parseReviewToken(token: string): ReviewTokenPayload | null {
  try {
    // Decode base64url
    const decoded = Buffer.from(token, 'base64url').toString('utf-8')
    const parts = decoded.split(':')

    // Expect 5 parts: customerId, businessId, enrollmentId, timestamp, random
    if (parts.length !== 5) {
      return null
    }

    const [customerId, businessId, enrollmentId, timestampStr] = parts
    const timestamp = parseInt(timestampStr, 10)

    // Validate timestamp is a number
    if (isNaN(timestamp)) {
      return null
    }

    // Check token age (30 days max)
    const age = Date.now() - timestamp
    if (age > TOKEN_EXPIRY_MS) {
      console.log('Review token expired:', { age: Math.floor(age / 1000 / 60 / 60), hours: 'hours' })
      return null
    }

    // Validate required fields are non-empty
    if (!customerId || !businessId) {
      return null
    }

    return {
      customerId,
      businessId,
      enrollmentId: enrollmentId || undefined,
      timestamp,
    }
  } catch (error) {
    // Any parsing error returns null (don't expose internals)
    console.error('Token parse error:', error)
    return null
  }
}

/**
 * Check if a token is still valid (not expired).
 * Useful for quick expiration checks without full parsing.
 */
export function isTokenExpired(token: string): boolean {
  const data = parseReviewToken(token)
  return data === null
}

/**
 * Get the review page URL for a given token.
 * Uses NEXT_PUBLIC_SITE_URL for proper domain handling.
 */
export function getReviewUrl(token: string): string {
  const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000'
  return `${baseUrl}/r/${token}`
}
```

Key implementation decisions:
- Uses base64url (not base64) for URL safety
- Includes random bytes to prevent token guessing
- 30-day expiration matches research recommendation
- Returns null on any error (no exceptions for callers)
- Logs expiration for debugging but doesn't expose to user
  </action>
  <verify>
Run: `dir lib\review\token.ts` to confirm file exists.
Run: `grep -n "generateReviewToken\|parseReviewToken" lib/review/token.ts` to confirm exports exist.
Run: `pnpm typecheck` to verify TypeScript compiles.
  </verify>
  <done>Token utilities exist with generateReviewToken (creates secure tokens) and parseReviewToken (validates and extracts data), both using base64url encoding and 30-day expiration.</done>
</task>

<task type="auto">
  <name>Task 2: Create review routing utility</name>
  <files>lib/review/routing.ts</files>
  <action>
Create routing.ts in lib/review/ with logic for determining review destination based on star rating.

```typescript
/**
 * Review destination routing based on satisfaction rating.
 * 4-5 stars → Google review link
 * 1-3 stars → Private feedback form
 *
 * IMPORTANT: Language must be FTC-compliant. Use "share your experience"
 * framing, NOT "leave a review if happy" (that's review gating).
 */

export type ReviewDestination = {
  type: 'google' | 'feedback'
  message: string
}

/**
 * Determine where to route the customer based on their satisfaction rating.
 *
 * FTC Compliance Note:
 * - We route satisfied customers (4-5) to Google as a convenience
 * - We offer dissatisfied customers (1-3) a private feedback option
 * - The language must frame this as "sharing experience" not "leave review if happy"
 * - Customers can still find Google reviews independently (we don't block access)
 *
 * @param rating - Customer's satisfaction rating (1-5)
 * @returns Destination type and confirmation message
 */
export function getReviewDestination(rating: number): ReviewDestination {
  // 4-5 stars: satisfied → Google review
  if (rating >= 4) {
    return {
      type: 'google',
      message: "Thank you for sharing! We'd love to hear more about your experience.",
    }
  }

  // 1-3 stars: less satisfied → private feedback
  return {
    type: 'feedback',
    message: "We appreciate your feedback and want to make things right.",
  }
}

/**
 * Rating threshold for Google vs feedback routing.
 * Export for UI components that need to know the boundary.
 */
export const GOOGLE_THRESHOLD = 4

/**
 * Get human-readable description for a rating.
 * Used for accessibility and screen readers.
 */
export function getRatingLabel(rating: number): string {
  switch (rating) {
    case 1:
      return 'Very dissatisfied'
    case 2:
      return 'Dissatisfied'
    case 3:
      return 'Neutral'
    case 4:
      return 'Satisfied'
    case 5:
      return 'Very satisfied'
    default:
      return 'Unknown'
  }
}

/**
 * Compliant page title and header text.
 * NEVER use conditional language like "if you're happy" or "for satisfied customers".
 */
export const REVIEW_PAGE_COPY = {
  // Main heading - neutral, asks everyone the same thing
  heading: 'How was your experience?',

  // Subheading - frames as feedback, not review request
  subheading: 'Your honest feedback helps us serve you better',

  // Footer disclaimer - required for FTC compliance
  footer: 'We value all feedback and use it to improve our service.',

  // Button text for submitting rating
  submitButton: 'Continue',

  // Feedback form heading (1-3 stars path)
  feedbackHeading: "We'd love to hear more",
  feedbackSubheading: 'Please share any details about your experience so we can improve.',

  // Thank you messages
  thankYouGoogle: 'Thank you! Your feedback helps other customers find great service.',
  thankYouFeedback: "Thank you for your feedback. We'll use it to improve.",
} as const
```
  </action>
  <verify>
Run: `dir lib\review\routing.ts` to confirm file exists.
Run: `grep -n "getReviewDestination\|REVIEW_PAGE_COPY" lib/review/routing.ts` to confirm exports exist.
Run: `pnpm typecheck` to verify TypeScript compiles.
  </verify>
  <done>Routing utility exists with getReviewDestination function (4-5 → google, 1-3 → feedback), FTC-compliant copy constants, and rating label helpers.</done>
</task>

</tasks>

<verification>
1. Token file exists: `dir lib\review\token.ts`
2. Routing file exists: `dir lib\review\routing.ts`
3. Token exports functions: `grep -n "export function" lib/review/token.ts`
4. Routing exports constants: `grep -n "export const\|export function" lib/review/routing.ts`
5. TypeScript compiles: `pnpm typecheck`
6. Lint passes: `pnpm lint`
</verification>

<success_criteria>
- lib/review/token.ts exists with generateReviewToken and parseReviewToken functions
- Token uses base64url encoding and includes random bytes
- Token expiration enforced at 30 days
- lib/review/routing.ts exists with getReviewDestination and REVIEW_PAGE_COPY
- Routing returns 'google' for 4-5 stars, 'feedback' for 1-3 stars
- All TypeScript compiles without errors
- Lint passes
</success_criteria>

<output>
After completion, create `.planning/phases/26-review-funnel/26-02-SUMMARY.md`
</output>
