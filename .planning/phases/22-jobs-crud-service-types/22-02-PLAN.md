---
phase: 22-jobs-crud-service-types
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/types/database.ts
  - lib/validations/job.ts
  - lib/actions/job.ts
  - lib/data/jobs.ts
autonomous: true

must_haves:
  truths:
    - "Job TypeScript interface matches database schema"
    - "Zod schema validates service type and status"
    - "Server actions for create, update, delete jobs exist"
    - "Data fetching function returns jobs with customer join"
  artifacts:
    - path: "lib/types/database.ts"
      provides: "Job interface and related types"
      contains: "interface Job"
    - path: "lib/validations/job.ts"
      provides: "Zod schemas for job validation"
      exports: ["jobSchema", "SERVICE_TYPES", "JOB_STATUSES"]
    - path: "lib/actions/job.ts"
      provides: "Server actions for job CRUD"
      exports: ["createJob", "updateJob", "deleteJob"]
    - path: "lib/data/jobs.ts"
      provides: "Data fetching functions"
      exports: ["getJobs", "getJob"]
  key_links:
    - from: "lib/actions/job.ts"
      to: "lib/validations/job.ts"
      via: "import jobSchema"
      pattern: "import.*jobSchema.*from.*validations/job"
    - from: "lib/actions/job.ts"
      to: "lib/supabase/server"
      via: "createClient import"
      pattern: "import.*createClient.*from.*supabase/server"
---

<objective>
Create TypeScript types, Zod validations, and server actions for Jobs CRUD operations.

Purpose: Enable type-safe job creation and management following existing patterns from customers. Server actions handle all business logic including customer validation and status timestamps.

Output: Types, validation schemas, server actions, and data fetching functions for jobs.
</objective>

<execution_context>
@C:\Users\aanth\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\aanth\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-jobs-crud-service-types/22-RESEARCH.md
@lib/types/database.ts
@lib/validations/customer.ts
@lib/actions/customer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Job types to database.ts</name>
  <files>lib/types/database.ts</files>
  <action>
Add Job interface and related types to lib/types/database.ts following existing Customer pattern.

Add these types:

```typescript
// Service type literal union
export type ServiceType = 'hvac' | 'plumbing' | 'electrical' | 'cleaning' | 'roofing' | 'painting' | 'handyman' | 'other'

// Job status literal union
export type JobStatus = 'completed' | 'do_not_send'

// Job interface matching database schema
export interface Job {
  id: string
  business_id: string
  customer_id: string
  service_type: ServiceType
  status: JobStatus
  notes: string | null
  completed_at: string | null
  created_at: string
  updated_at: string
}

// Job with joined customer data for list views
export interface JobWithCustomer extends Job {
  customers: Pick<Customer, 'id' | 'name' | 'email' | 'phone'>
}

// Insert type (omit auto-generated fields)
export type JobInsert = Omit<Job, 'id' | 'created_at' | 'updated_at'>

// Update type (partial, omit immutable fields)
export type JobUpdate = Partial<Omit<Job, 'id' | 'business_id' | 'created_at' | 'updated_at'>>
```

Place after Customer types in the file.
  </action>
  <verify>Run `pnpm typecheck` - no errors. Job type exists and is exported.</verify>
  <done>lib/types/database.ts exports Job, JobWithCustomer, ServiceType, JobStatus, JobInsert, JobUpdate types.</done>
</task>

<task type="auto">
  <name>Task 2: Create job validation schemas</name>
  <files>lib/validations/job.ts</files>
  <action>
Create lib/validations/job.ts with Zod schemas following customer.ts pattern:

```typescript
import { z } from 'zod'

// Service types as const array for Zod enum
export const SERVICE_TYPES = [
  'hvac',
  'plumbing',
  'electrical',
  'cleaning',
  'roofing',
  'painting',
  'handyman',
  'other',
] as const

// Job statuses as const array
export const JOB_STATUSES = ['completed', 'do_not_send'] as const

// Display labels for UI (proper casing)
export const SERVICE_TYPE_LABELS: Record<typeof SERVICE_TYPES[number], string> = {
  hvac: 'HVAC',
  plumbing: 'Plumbing',
  electrical: 'Electrical',
  cleaning: 'Cleaning',
  roofing: 'Roofing',
  painting: 'Painting',
  handyman: 'Handyman',
  other: 'Other',
}

export const JOB_STATUS_LABELS: Record<typeof JOB_STATUSES[number], string> = {
  completed: 'Completed',
  do_not_send: 'Do Not Send',
}

// Default timing in hours (for campaign first touch)
export const DEFAULT_TIMING_HOURS: Record<typeof SERVICE_TYPES[number], number> = {
  hvac: 24,
  plumbing: 48,
  electrical: 24,
  cleaning: 4,
  roofing: 72,
  painting: 48,
  handyman: 24,
  other: 24,
}

// Job creation/update schema
export const jobSchema = z.object({
  customerId: z
    .string({ required_error: 'Please select a customer' })
    .uuid('Please select a valid customer'),
  serviceType: z.enum(SERVICE_TYPES, {
    errorMap: () => ({ message: 'Please select a service type' }),
  }),
  status: z
    .enum(JOB_STATUSES)
    .default('completed'),
  notes: z
    .string()
    .max(1000, 'Notes must be under 1000 characters')
    .optional()
    .or(z.literal('')),
})

// Infer types from schema
export type JobInput = z.infer<typeof jobSchema>
export type ServiceType = typeof SERVICE_TYPES[number]
export type JobStatusType = typeof JOB_STATUSES[number]
```
  </action>
  <verify>Run `pnpm typecheck` - no errors. Import jobSchema in a test file to verify export.</verify>
  <done>lib/validations/job.ts exports jobSchema, SERVICE_TYPES, JOB_STATUSES, labels, and timing defaults.</done>
</task>

<task type="auto">
  <name>Task 3: Create job server actions</name>
  <files>lib/actions/job.ts</files>
  <action>
Create lib/actions/job.ts with CRUD server actions following customer.ts pattern exactly:

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { jobSchema } from '@/lib/validations/job'

export type JobActionState = {
  error?: string
  fieldErrors?: Record<string, string[]>
  success?: boolean
  data?: { id: string }
}

/**
 * Create a new job for the user's business.
 * Validates customer belongs to same business.
 */
export async function createJob(
  _prevState: JobActionState | null,
  formData: FormData
): Promise<JobActionState> {
  const supabase = await createClient()

  // Validate user authentication
  const { data: { user }, error: authError } = await supabase.auth.getUser()
  if (authError || !user) {
    return { error: 'You must be logged in to create jobs' }
  }

  // Get user's business
  const { data: business, error: businessError } = await supabase
    .from('businesses')
    .select('id')
    .eq('user_id', user.id)
    .single()

  if (businessError || !business) {
    return { error: 'Please create a business profile first' }
  }

  // Parse and validate input
  const parsed = jobSchema.safeParse({
    customerId: formData.get('customerId'),
    serviceType: formData.get('serviceType'),
    status: formData.get('status') || 'completed',
    notes: formData.get('notes') || '',
  })

  if (!parsed.success) {
    return { fieldErrors: parsed.error.flatten().fieldErrors }
  }

  const { customerId, serviceType, status, notes } = parsed.data

  // Validate customer belongs to this business (prevent cross-tenant data leak)
  const { data: customer, error: customerError } = await supabase
    .from('customers')
    .select('id')
    .eq('id', customerId)
    .eq('business_id', business.id)
    .single()

  if (customerError || !customer) {
    return { fieldErrors: { customerId: ['Please select a valid customer'] } }
  }

  // Insert job
  const { data: newJob, error } = await supabase
    .from('jobs')
    .insert({
      business_id: business.id,
      customer_id: customerId,
      service_type: serviceType,
      status,
      notes: notes || null,
      completed_at: status === 'completed' ? new Date().toISOString() : null,
    })
    .select('id')
    .single()

  if (error) {
    return { error: error.message }
  }

  revalidatePath('/jobs')
  return { success: true, data: { id: newJob.id } }
}

/**
 * Update an existing job.
 */
export async function updateJob(
  _prevState: JobActionState | null,
  formData: FormData
): Promise<JobActionState> {
  const supabase = await createClient()

  // Validate user authentication
  const { data: { user }, error: authError } = await supabase.auth.getUser()
  if (authError || !user) {
    return { error: 'You must be logged in to update jobs' }
  }

  // Get user's business
  const { data: business } = await supabase
    .from('businesses')
    .select('id')
    .eq('user_id', user.id)
    .single()

  if (!business) {
    return { error: 'Please create a business profile first' }
  }

  // Extract job ID
  const jobId = formData.get('jobId') as string
  if (!jobId) {
    return { error: 'Job ID is required' }
  }

  // Parse and validate input
  const parsed = jobSchema.safeParse({
    customerId: formData.get('customerId'),
    serviceType: formData.get('serviceType'),
    status: formData.get('status') || 'completed',
    notes: formData.get('notes') || '',
  })

  if (!parsed.success) {
    return { fieldErrors: parsed.error.flatten().fieldErrors }
  }

  const { customerId, serviceType, status, notes } = parsed.data

  // Validate customer belongs to this business
  const { data: customer } = await supabase
    .from('customers')
    .select('id')
    .eq('id', customerId)
    .eq('business_id', business.id)
    .single()

  if (!customer) {
    return { fieldErrors: { customerId: ['Please select a valid customer'] } }
  }

  // Get current job to check status change
  const { data: currentJob } = await supabase
    .from('jobs')
    .select('status, completed_at')
    .eq('id', jobId)
    .single()

  // Determine completed_at value
  let completedAt: string | null = currentJob?.completed_at || null
  if (status === 'completed' && currentJob?.status !== 'completed') {
    // Status changing to completed - set timestamp
    completedAt = new Date().toISOString()
  } else if (status === 'do_not_send') {
    // Status is do_not_send - clear timestamp
    completedAt = null
  }

  // Update job (RLS handles ownership check)
  const { error } = await supabase
    .from('jobs')
    .update({
      customer_id: customerId,
      service_type: serviceType,
      status,
      notes: notes || null,
      completed_at: completedAt,
    })
    .eq('id', jobId)

  if (error) {
    return { error: error.message }
  }

  revalidatePath('/jobs')
  return { success: true, data: { id: jobId } }
}

/**
 * Delete a job.
 */
export async function deleteJob(jobId: string): Promise<JobActionState> {
  const supabase = await createClient()

  // Validate user authentication
  const { data: { user }, error: authError } = await supabase.auth.getUser()
  if (authError || !user) {
    return { error: 'You must be logged in to delete jobs' }
  }

  // Delete job (RLS handles ownership check)
  const { error } = await supabase
    .from('jobs')
    .delete()
    .eq('id', jobId)

  if (error) {
    return { error: error.message }
  }

  revalidatePath('/jobs')
  return { success: true }
}

/**
 * Mark job as completed (sets status and completed_at).
 */
export async function markJobCompleted(jobId: string): Promise<JobActionState> {
  const supabase = await createClient()

  const { data: { user }, error: authError } = await supabase.auth.getUser()
  if (authError || !user) {
    return { error: 'You must be logged in' }
  }

  const { error } = await supabase
    .from('jobs')
    .update({
      status: 'completed',
      completed_at: new Date().toISOString(),
    })
    .eq('id', jobId)

  if (error) {
    return { error: error.message }
  }

  revalidatePath('/jobs')
  return { success: true }
}

/**
 * Mark job as do-not-send.
 */
export async function markJobDoNotSend(jobId: string): Promise<JobActionState> {
  const supabase = await createClient()

  const { data: { user }, error: authError } = await supabase.auth.getUser()
  if (authError || !user) {
    return { error: 'You must be logged in' }
  }

  const { error } = await supabase
    .from('jobs')
    .update({
      status: 'do_not_send',
      completed_at: null,
    })
    .eq('id', jobId)

  if (error) {
    return { error: error.message }
  }

  revalidatePath('/jobs')
  return { success: true }
}
```

Key points:
- Follow customer.ts pattern exactly
- Validate customer belongs to same business before insert/update
- Set completed_at when status is 'completed'
- Clear completed_at when status is 'do_not_send'
- revalidatePath('/jobs') after mutations
  </action>
  <verify>Run `pnpm typecheck` - no errors. All functions export correctly.</verify>
  <done>lib/actions/job.ts exports createJob, updateJob, deleteJob, markJobCompleted, markJobDoNotSend server actions.</done>
</task>

<task type="auto">
  <name>Task 4: Create job data fetching functions</name>
  <files>lib/data/jobs.ts</files>
  <action>
Create lib/data/jobs.ts with data fetching functions following existing patterns:

```typescript
import { createClient } from '@/lib/supabase/server'
import type { JobWithCustomer, Job } from '@/lib/types/database'

/**
 * Fetch jobs for the current user's business with pagination and filters.
 */
export async function getJobs(options?: {
  limit?: number
  offset?: number
  serviceType?: string
  status?: string
}): Promise<{ jobs: JobWithCustomer[]; total: number }> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { jobs: [], total: 0 }
  }

  // Get user's business
  const { data: business } = await supabase
    .from('businesses')
    .select('id')
    .eq('user_id', user.id)
    .single()

  if (!business) {
    return { jobs: [], total: 0 }
  }

  const limit = options?.limit ?? 50
  const offset = options?.offset ?? 0

  // Build query with customer join
  let query = supabase
    .from('jobs')
    .select('*, customers!inner(id, name, email, phone)', { count: 'exact' })
    .eq('business_id', business.id)
    .order('created_at', { ascending: false })

  // Apply service type filter
  if (options?.serviceType) {
    query = query.eq('service_type', options.serviceType)
  }

  // Apply status filter
  if (options?.status) {
    query = query.eq('status', options.status)
  }

  // Apply pagination
  query = query.range(offset, offset + limit - 1)

  const { data, count, error } = await query

  if (error) {
    console.error('Error fetching jobs:', error)
    return { jobs: [], total: 0 }
  }

  return {
    jobs: data as JobWithCustomer[],
    total: count || 0,
  }
}

/**
 * Fetch a single job by ID.
 */
export async function getJob(jobId: string): Promise<JobWithCustomer | null> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return null
  }

  const { data, error } = await supabase
    .from('jobs')
    .select('*, customers!inner(id, name, email, phone)')
    .eq('id', jobId)
    .single()

  if (error) {
    console.error('Error fetching job:', error)
    return null
  }

  return data as JobWithCustomer
}

/**
 * Get job counts by status for the current business.
 */
export async function getJobCounts(): Promise<{
  total: number
  completed: number
  doNotSend: number
}> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { total: 0, completed: 0, doNotSend: 0 }
  }

  const { data: business } = await supabase
    .from('businesses')
    .select('id')
    .eq('user_id', user.id)
    .single()

  if (!business) {
    return { total: 0, completed: 0, doNotSend: 0 }
  }

  // Get total count
  const { count: total } = await supabase
    .from('jobs')
    .select('*', { count: 'exact', head: true })
    .eq('business_id', business.id)

  // Get completed count
  const { count: completed } = await supabase
    .from('jobs')
    .select('*', { count: 'exact', head: true })
    .eq('business_id', business.id)
    .eq('status', 'completed')

  // Get do_not_send count
  const { count: doNotSend } = await supabase
    .from('jobs')
    .select('*', { count: 'exact', head: true })
    .eq('business_id', business.id)
    .eq('status', 'do_not_send')

  return {
    total: total || 0,
    completed: completed || 0,
    doNotSend: doNotSend || 0,
  }
}
```
  </action>
  <verify>Run `pnpm typecheck` - no errors. Functions export correctly.</verify>
  <done>lib/data/jobs.ts exports getJobs, getJob, getJobCounts functions with proper types and business scoping.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `pnpm typecheck` passes with no errors
2. `pnpm lint` passes
3. All exports are accessible from their respective files
4. Types align with database schema from Plan 01
</verification>

<success_criteria>
- lib/types/database.ts exports Job, JobWithCustomer, ServiceType, JobStatus types
- lib/validations/job.ts exports jobSchema, SERVICE_TYPES, JOB_STATUSES, labels, timing defaults
- lib/actions/job.ts exports createJob, updateJob, deleteJob, markJobCompleted, markJobDoNotSend
- lib/data/jobs.ts exports getJobs, getJob, getJobCounts
- All TypeScript compiles without errors
- Server actions validate customer belongs to business before insert/update
- Server actions set completed_at when status is 'completed'
</success_criteria>

<output>
After completion, create `.planning/phases/22-jobs-crud-service-types/22-02-SUMMARY.md`
</output>
