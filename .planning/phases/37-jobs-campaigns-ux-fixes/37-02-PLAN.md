---
phase: 37-jobs-campaigns-ux-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/(dashboard)/jobs/page.tsx
  - components/jobs/jobs-client.tsx
  - components/jobs/job-filters.tsx
  - components/jobs/add-job-sheet.tsx
  - components/jobs/customer-autocomplete.tsx
autonomous: true

must_haves:
  truths:
    - "Jobs page service type filter only shows service types the business enabled during onboarding — an HVAC+plumbing business sees only HVAC and Plumbing chips, not all 8"
    - "When no service types are configured (onboarding incomplete), all 8 types show as fallback"
    - "Add Job form's ServiceTypeSelect only shows enabled service types"
    - "Customer autocomplete placeholder changes to hint at email search when user types an @ character"
    - "Status filter chips and service type filter chips are visually distinguishable at a glance"
  artifacts:
    - path: "app/(dashboard)/jobs/page.tsx"
      provides: "Server component fetching serviceTypesEnabled via getServiceTypeSettings"
    - path: "components/jobs/jobs-client.tsx"
      provides: "Client component accepting and threading enabledServiceTypes prop"
    - path: "components/jobs/job-filters.tsx"
      provides: "Filter chips scoped to enabled service types with visual distinction"
    - path: "components/jobs/customer-autocomplete.tsx"
      provides: "Smart name/email detection with dynamic placeholder"
  key_links:
    - from: "app/(dashboard)/jobs/page.tsx"
      to: "components/jobs/jobs-client.tsx"
      via: "enabledServiceTypes prop from getServiceTypeSettings()"
      pattern: "enabledServiceTypes="
    - from: "components/jobs/jobs-client.tsx"
      to: "components/jobs/job-filters.tsx"
      via: "enabledServiceTypes prop passed through"
      pattern: "enabledServiceTypes="
    - from: "components/jobs/jobs-client.tsx"
      to: "components/jobs/add-job-sheet.tsx"
      via: "enabledServiceTypes prop for ServiceTypeSelect"
      pattern: "enabledServiceTypes="
---

<objective>
Scope the Jobs page service type filter to the business's configured services (JC-01), add smart name/email detection to the customer autocomplete (JC-02), and make the status vs service type filter chips visually distinct (JC-09).

Purpose: The service filter showing all 8 types when a business only does HVAC is confusing. Smart email detection helps users who naturally type email addresses. Visual distinction prevents filter confusion.

Output: Jobs page with scoped filter chips, smart autocomplete placeholder, and visually distinct filter groups.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/37-jobs-campaigns-ux-fixes/37-RESEARCH.md

Key files:
@app/(dashboard)/jobs/page.tsx
@components/jobs/jobs-client.tsx
@components/jobs/job-filters.tsx
@components/jobs/add-job-sheet.tsx
@components/jobs/service-type-select.tsx
@components/jobs/customer-autocomplete.tsx
@lib/data/business.ts (getServiceTypeSettings function at line 79)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Thread serviceTypesEnabled from server component to filters and AddJobSheet (JC-01)</name>
  <files>app/(dashboard)/jobs/page.tsx, components/jobs/jobs-client.tsx, components/jobs/job-filters.tsx, components/jobs/add-job-sheet.tsx</files>
  <action>
  **Step 1: Fetch serviceTypesEnabled in the server component**

  In `app/(dashboard)/jobs/page.tsx`, import `getServiceTypeSettings` from `@/lib/data/business` and add it to the `Promise.all`:

  ```typescript
  import { getServiceTypeSettings } from '@/lib/data/business'

  async function JobsContent({ defaultAddJobOpen }: { defaultAddJobOpen: boolean }) {
    const [{ jobs, total, businessId }, { customers }, serviceSettings] = await Promise.all([
      getJobs(),
      getCustomers({ limit: 200 }),
      getServiceTypeSettings(),
    ])

    const enabledServiceTypes = (serviceSettings?.serviceTypesEnabled || []) as ServiceType[]
    // ... rest unchanged

    return (
      <JobsClient
        initialJobs={jobs}
        totalJobs={total}
        customers={customers}
        campaignMap={campaignMap}
        defaultAddJobOpen={defaultAddJobOpen}
        enabledServiceTypes={enabledServiceTypes}
      />
    )
  }
  ```

  **Step 2: Add prop to JobsClient**

  In `components/jobs/jobs-client.tsx`:
  - Add `enabledServiceTypes?: ServiceType[]` to `JobsClientProps` interface (import `ServiceType` from `@/lib/types/database`)
  - Pass `enabledServiceTypes` to `<JobFilters>` component
  - Pass `enabledServiceTypes` to `<AddJobSheet>` component

  **Step 3: Filter chips in JobFilters**

  In `components/jobs/job-filters.tsx`:
  - Add `enabledServiceTypes?: string[]` to `JobFiltersProps` interface
  - Before rendering service type chips, filter: `const visibleServiceTypes = enabledServiceTypes && enabledServiceTypes.length > 0 ? SERVICE_TYPES.filter(t => enabledServiceTypes.includes(t)) : SERVICE_TYPES`
  - Use `visibleServiceTypes` instead of `SERVICE_TYPES` in the service type chip `.map()`
  - If `visibleServiceTypes` has only 1 item, still show it (user can toggle it on/off)

  **Step 4: Pass enabledTypes to ServiceTypeSelect in AddJobSheet**

  In `components/jobs/add-job-sheet.tsx`:
  - Add `enabledServiceTypes?: ServiceType[]` to `AddJobSheetProps` interface (import ServiceType)
  - Pass `enabledTypes={enabledServiceTypes}` to `<ServiceTypeSelect>` (the component already supports this prop but it's currently unused)

  The `ServiceTypeSelect` component already implements the filtering logic with its `enabledTypes` prop — no changes needed there.
  </action>
  <verify>
  - `pnpm typecheck` passes
  - `pnpm lint` passes
  - Grep for `enabledServiceTypes` to confirm the prop chain: page.tsx -> jobs-client.tsx -> job-filters.tsx and add-job-sheet.tsx
  - Grep for `getServiceTypeSettings` in page.tsx to confirm the import
  </verify>
  <done>Jobs page service type filter only shows types from `service_types_enabled`. AddJobSheet's ServiceTypeSelect also scoped. Empty/missing service types gracefully fallback to showing all 8 types.</done>
</task>

<task type="auto">
  <name>Task 2: Smart name/email detection in autocomplete and filter visual distinction (JC-02, JC-09)</name>
  <files>components/jobs/customer-autocomplete.tsx, components/jobs/job-filters.tsx</files>
  <action>
  **Part A: Smart name/email detection (JC-02)**

  In `components/jobs/customer-autocomplete.tsx`:

  1. Add a computed `isEmailQuery` variable based on the query containing `@`:
     ```typescript
     const isEmailQuery = query.includes('@')
     ```

  2. Update the `<Input>` element's `placeholder` to be dynamic:
     - When `isEmailQuery` is true: `"Search by email address..."`
     - When false: use the `placeholder` prop (default: `"Type customer name or email..."`)

  3. Add an `aria-label` that reflects the current mode:
     - `isEmailQuery ? "Customer email search" : "Customer name or email search"`

  4. **Do NOT change the input `type`** — keep `type="text"` to avoid focus loss on dynamic type changes (per research pitfall #5).

  5. Optionally add a subtle visual indicator when in email mode. Inside the `<div className="relative">` wrapper, after the Input, add:
     ```tsx
     {isEmailQuery && query.length >= 3 && (
       <span className="absolute right-3 top-1/2 -translate-y-1/2 text-xs text-muted-foreground pointer-events-none">
         email
       </span>
     )}
     ```
     Only show when `query.length >= 3` to avoid flashing for a bare `@`.

  **Part B: Filter visual distinction (JC-09)**

  In `components/jobs/job-filters.tsx`:

  1. Add group labels above each filter section. Wrap the status chips and service chips in labeled groups:
     ```tsx
     <div className="flex flex-wrap items-center gap-2">
       {/* Status group */}
       <span className="text-xs font-medium text-muted-foreground uppercase tracking-wider mr-1">Status</span>
       {JOB_STATUSES.map(status => (
         <button ... className="... rounded-full ...">
           {JOB_STATUS_LABELS[status]}
         </button>
       ))}

       {/* Separator */}
       <div className="w-px h-6 bg-border mx-1" />

       {/* Service type group */}
       <span className="text-xs font-medium text-muted-foreground uppercase tracking-wider mr-1">Service</span>
       {visibleServiceTypes.map(type => (
         <button ... className="... rounded-md ...">
           {SERVICE_TYPE_LABELS[type]}
         </button>
       ))}

       {/* Clear button */}
       {hasActiveFilters && ( ... )}
     </div>
     ```

  2. The key visual distinction:
     - Status chips: `rounded-full` (pill shape) — ALREADY the case, keep it
     - Service type chips: `rounded-md` (rounded rectangle) — change from `rounded-full` to `rounded-md`
     - Both groups get a small label prefix ("Status", "Service")
     - Keep the vertical separator `<div className="w-px bg-border" />` between groups, add a fixed height `h-6` to it

  3. The active state colors remain the same (`bg-primary text-primary-foreground`) for both groups — the shape and label differentiation is sufficient.

  4. Add `self-center` to the separator div so it vertically centers in the flex row.
  </action>
  <verify>
  - `pnpm typecheck` passes
  - `pnpm lint` passes
  - In `customer-autocomplete.tsx`, search for `isEmailQuery` to confirm detection logic exists
  - In `job-filters.tsx`, confirm service type chips use `rounded-md` and status chips use `rounded-full`
  - Confirm group labels "Status" and "Service" appear in the filter markup
  </verify>
  <done>Customer autocomplete shows "email" indicator and changes placeholder when @ is typed. Filter chips have group labels ("Status", "Service") and different border radius (pill vs rounded-rect) for instant visual distinction.</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes with zero errors
2. `pnpm lint` passes with zero errors
3. `getServiceTypeSettings` is imported and called in `app/(dashboard)/jobs/page.tsx`
4. `enabledServiceTypes` prop flows: page.tsx -> jobs-client.tsx -> job-filters.tsx AND add-job-sheet.tsx
5. `customer-autocomplete.tsx` has `isEmailQuery` computed from `query.includes('@')`
6. Service type chips use `rounded-md`, status chips use `rounded-full`
7. Both filter groups have text labels ("Status", "Service")
</verification>

<success_criteria>
- Service type filter on Jobs page only shows types the business enabled (from `service_types_enabled`)
- If no types configured, all 8 show as fallback
- AddJobSheet's ServiceTypeSelect also respects enabled types
- Typing an email address in autocomplete shows "email" indicator and updated placeholder
- Status and service type filter groups are visually distinct (shape + label)
- Typecheck and lint pass
</success_criteria>

<output>
After completion, create `.planning/phases/37-jobs-campaigns-ux-fixes/37-02-SUMMARY.md`
</output>
