---
phase: 23-message-templates-migration
plan: 04
type: execute
wave: 3
depends_on: ["23-02", "23-03"]
files_modified:
  - components/templates/message-template-form.tsx
  - components/templates/use-sms-character-counter.ts
  - components/ui/tabs.tsx
autonomous: true

must_haves:
  truths:
    - "Template form has Email/SMS tabs at top"
    - "Switching tabs shows channel-specific fields"
    - "SMS tab shows live character counter with warnings"
    - "SMS tab shows read-only opt-out footer text"
    - "Form submits with correct channel value"
  artifacts:
    - path: "components/templates/message-template-form.tsx"
      provides: "Tab-based template creation form"
      contains: "TabsList"
    - path: "components/templates/use-sms-character-counter.ts"
      provides: "GSM-7 aware character counter hook"
      exports: ["useSMSCharacterCounter"]
  key_links:
    - from: "components/templates/message-template-form.tsx"
      to: "lib/actions/message-template.ts"
      via: "form action import"
      pattern: "import.*createMessageTemplate"
    - from: "components/templates/message-template-form.tsx"
      to: "components/ui/tabs"
      via: "Radix tabs import"
      pattern: "import.*Tabs.*from.*@/components/ui/tabs"
---

<objective>
Create tab-based message template form with Email/SMS channel selector and SMS character counter.

Purpose: Enable users to create templates for either channel with appropriate validation UI.
Output: Client component with tabs, channel-specific fields, and live SMS character counting.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-message-templates-migration/23-CONTEXT.md
@.planning/phases/23-message-templates-migration/23-RESEARCH.md
@components/send/send-page-client.tsx
@components/email-template-form.tsx
@components/ui/tabs.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SMS character counter hook</name>
  <files>components/templates/use-sms-character-counter.ts</files>
  <action>
Create new file components/templates/use-sms-character-counter.ts:

```typescript
/**
 * SMS Character Counter Hook
 * Detects GSM-7 vs Unicode encoding and provides character counting with warnings.
 *
 * GSM-7 (standard SMS): 160 chars per segment
 * Unicode (emojis, accents): 70 chars per segment
 */

export interface SMSCharacterInfo {
  length: number
  limit: number
  segments: number
  remaining: number
  encoding: 'GSM-7' | 'Unicode'
  warning: 'none' | 'warning' | 'error'
  warningMessage: string
}

// GSM-7 character set regex (standard SMS encoding, 160 chars per segment)
// Includes basic Latin, numbers, common punctuation
const GSM7_REGEX = /^[A-Za-z0-9@£$¥èéùìòÇ\nØø\rÅåΔ_ΦΓΛΩΠΨΣΘΞ\x1BÆæßÉ !"#¤%&'()*+,\-./:;<=>?¡ÄÖÑÜ§¿äöñüà^{}\\[~\]|€]*$/

export function useSMSCharacterCounter(text: string): SMSCharacterInfo {
  const isGSM7 = GSM7_REGEX.test(text)
  const length = text.length

  // GSM-7: 160 chars/segment, Unicode (UCS-2): 70 chars/segment
  const limit = isGSM7 ? 160 : 70
  const segments = length > 0 ? Math.ceil(length / limit) : 1
  const remaining = (limit * segments) - length

  // Warning levels (accounting for opt-out footer ~20 chars)
  // Soft limit at 140 to reserve space for "Reply STOP to opt out"
  const effectiveLimit = 140

  let warning: 'none' | 'warning' | 'error'
  let warningMessage: string

  if (length <= effectiveLimit) {
    warning = 'none'
    warningMessage = ''
  } else if (length <= 160) {
    warning = 'warning'
    warningMessage = 'Approaching limit (reserve space for opt-out footer)'
  } else {
    warning = 'error'
    warningMessage = `Message will be split into ${segments} segments`
  }

  // Additional warning for Unicode
  if (!isGSM7 && length > 0) {
    warningMessage = `Unicode detected (${limit} char limit). ${warningMessage}`.trim()
  }

  return {
    length,
    limit,
    segments,
    remaining,
    encoding: isGSM7 ? 'GSM-7' : 'Unicode',
    warning,
    warningMessage,
  }
}
```

This is a pure function (not a React hook with useState) so it can be called in render.
If you need reactive updates, use it with useState in the component.
  </action>
  <verify>Run `pnpm typecheck` - no errors. Check function returns correct values for test inputs.</verify>
  <done>Character counter function created with GSM-7 detection and warning levels</done>
</task>

<task type="auto">
  <name>Task 2: Create message-template-form.tsx component</name>
  <files>components/templates/message-template-form.tsx</files>
  <action>
Create new file components/templates/message-template-form.tsx with tab-based form:

```typescript
'use client'

import { useState } from 'react'
import { useActionState } from 'react'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { createMessageTemplate, type MessageTemplateActionState } from '@/lib/actions/message-template'
import { useSMSCharacterCounter } from './use-sms-character-counter'
import { cn } from '@/lib/utils'

interface MessageTemplateFormProps {
  onSuccess?: () => void
}

export function MessageTemplateForm({ onSuccess }: MessageTemplateFormProps) {
  const [state, formAction, isPending] = useActionState<MessageTemplateActionState | null, FormData>(
    createMessageTemplate,
    null
  )
  const [channel, setChannel] = useState<'email' | 'sms'>('email')
  const [smsBody, setSmsBody] = useState('')
  const charInfo = useSMSCharacterCounter(smsBody)

  // Call onSuccess callback when form succeeds
  if (state?.success && onSuccess) {
    onSuccess()
  }

  return (
    <form action={formAction} className="space-y-4">
      {/* Hidden channel field */}
      <input type="hidden" name="channel" value={channel} />

      {/* General error */}
      {state?.error && (
        <div className="bg-red-50 dark:bg-red-950 border border-red-200 dark:border-red-800 text-red-800 dark:text-red-300 px-4 py-3 rounded">
          {state.error}
        </div>
      )}

      {/* Success message */}
      {state?.success && (
        <div className="bg-green-50 dark:bg-green-950 border border-green-200 dark:border-green-800 text-green-800 dark:text-green-300 px-4 py-3 rounded">
          Template created successfully!
        </div>
      )}

      {/* Template Name (shared across channels) */}
      <div>
        <label htmlFor="template-name" className="block text-sm font-medium text-foreground mb-1">
          Template Name <span className="text-red-500">*</span>
        </label>
        <input
          type="text"
          id="template-name"
          name="name"
          required
          placeholder="My Custom Template"
          className="w-full border border-border rounded-md px-3 py-2 bg-background text-foreground focus:outline-none focus:ring-2 focus:ring-primary/20 focus:border-primary"
        />
        {state?.fieldErrors?.name && (
          <p className="text-red-600 text-sm mt-1">{state.fieldErrors.name[0]}</p>
        )}
      </div>

      {/* Channel Tabs */}
      <Tabs
        value={channel}
        onValueChange={(v) => setChannel(v as 'email' | 'sms')}
        className="w-full"
      >
        <TabsList className="w-full grid grid-cols-2">
          <TabsTrigger value="email">Email</TabsTrigger>
          <TabsTrigger value="sms">SMS</TabsTrigger>
        </TabsList>

        {/* Email Fields */}
        <TabsContent value="email" className="space-y-4 mt-4">
          <div>
            <label htmlFor="email-subject" className="block text-sm font-medium text-foreground mb-1">
              Subject <span className="text-red-500">*</span>
            </label>
            <input
              type="text"
              id="email-subject"
              name="subject"
              required={channel === 'email'}
              placeholder="We'd love your feedback, {{CUSTOMER_NAME}}!"
              className="w-full border border-border rounded-md px-3 py-2 bg-background text-foreground focus:outline-none focus:ring-2 focus:ring-primary/20 focus:border-primary"
            />
            {state?.fieldErrors?.subject && (
              <p className="text-red-600 text-sm mt-1">{state.fieldErrors.subject[0]}</p>
            )}
          </div>

          <div>
            <label htmlFor="email-body" className="block text-sm font-medium text-foreground mb-1">
              Body <span className="text-red-500">*</span>
            </label>
            <textarea
              id="email-body"
              name="body"
              required={channel === 'email'}
              rows={8}
              placeholder={`Hi {{CUSTOMER_NAME}},

Thank you for choosing {{BUSINESS_NAME}}!

We would really appreciate if you could leave us a review:
{{REVIEW_LINK}}

Best regards,
{{SENDER_NAME}}`}
              className="w-full border border-border rounded-md px-3 py-2 bg-background text-foreground focus:outline-none focus:ring-2 focus:ring-primary/20 focus:border-primary font-mono text-sm"
            />
            {state?.fieldErrors?.body && channel === 'email' && (
              <p className="text-red-600 text-sm mt-1">{state.fieldErrors.body[0]}</p>
            )}
          </div>

          <p className="text-xs text-muted-foreground">
            Variables: {'{{CUSTOMER_NAME}}'}, {'{{BUSINESS_NAME}}'}, {'{{REVIEW_LINK}}'}, {'{{SENDER_NAME}}'}
          </p>
        </TabsContent>

        {/* SMS Fields */}
        <TabsContent value="sms" className="space-y-4 mt-4">
          <div>
            <label htmlFor="sms-body" className="block text-sm font-medium text-foreground mb-1">
              Message <span className="text-red-500">*</span>
            </label>
            <textarea
              id="sms-body"
              name="body"
              required={channel === 'sms'}
              rows={4}
              value={smsBody}
              onChange={(e) => setSmsBody(e.target.value)}
              placeholder="Hi {{CUSTOMER_NAME}}, thanks for choosing {{BUSINESS_NAME}}! We'd love your feedback. Reply YES for review link."
              className="w-full border border-border rounded-md px-3 py-2 bg-background text-foreground focus:outline-none focus:ring-2 focus:ring-primary/20 focus:border-primary font-mono text-sm"
            />

            {/* Character Counter */}
            <div className={cn(
              'text-sm mt-1 flex items-center gap-2',
              charInfo.warning === 'error' && 'text-red-600',
              charInfo.warning === 'warning' && 'text-yellow-600',
              charInfo.warning === 'none' && 'text-muted-foreground'
            )}>
              <span>{charInfo.length}/{charInfo.limit}</span>
              <span className="text-xs">({charInfo.encoding})</span>
              {charInfo.segments > 1 && (
                <span className="text-xs">{charInfo.segments} segments</span>
              )}
            </div>
            {charInfo.warningMessage && (
              <p className={cn(
                'text-xs mt-1',
                charInfo.warning === 'error' ? 'text-red-600' : 'text-yellow-600'
              )}>
                {charInfo.warningMessage}
              </p>
            )}
            {state?.fieldErrors?.body && channel === 'sms' && (
              <p className="text-red-600 text-sm mt-1">{state.fieldErrors.body[0]}</p>
            )}
          </div>

          {/* Opt-out footer notice (read-only) */}
          <div className="p-3 bg-muted rounded-md border border-border">
            <p className="text-xs text-muted-foreground font-medium mb-1">
              Auto-added to all SMS messages:
            </p>
            <p className="text-sm text-foreground">
              Reply STOP to opt out
            </p>
          </div>

          <p className="text-xs text-muted-foreground">
            Variables: {'{{CUSTOMER_NAME}}'}, {'{{BUSINESS_NAME}}'}, {'{{SENDER_NAME}}'}
            <br />
            <span className="text-yellow-600">Note: Avoid long URLs in SMS - use "Reply YES for review link" pattern instead.</span>
          </p>
        </TabsContent>
      </Tabs>

      {/* Submit Button */}
      <div className="pt-2">
        <button
          type="submit"
          disabled={isPending}
          className="bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {isPending ? 'Creating...' : 'Create Template'}
        </button>
      </div>
    </form>
  )
}
```

Key implementation details:
- Uses existing Radix UI Tabs (matches Send page pattern)
- Hidden input sends channel value with form
- SMS body tracked in state for live character counting
- Character counter shows warning colors (yellow at 140+, red at 160+)
- Opt-out footer shown as read-only notice
- Variables help text differs per channel (no REVIEW_LINK for SMS)
  </action>
  <verify>Run `pnpm typecheck` and `pnpm lint` - no errors. Component renders without crashing.</verify>
  <done>Tab-based template form created with channel selector and SMS character counter</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Run `pnpm typecheck` - no type errors
2. Run `pnpm lint` - no lint errors
3. Test component renders: Import in settings page temporarily
4. Test tab switching: Click Email/SMS tabs, fields change
5. Test character counter: Type in SMS body, count updates
</verification>

<success_criteria>
- Tabs switch between Email and SMS views
- Email tab shows subject + body fields
- SMS tab shows body only with character counter
- Character counter shows GSM-7 vs Unicode detection
- Warnings appear at 140+ chars (yellow) and 160+ chars (red)
- Opt-out footer shown as read-only
- Form submits with correct channel value
</success_criteria>

<output>
After completion, create `.planning/phases/23-message-templates-migration/23-04-SUMMARY.md`
</output>
