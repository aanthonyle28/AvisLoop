---
phase: 23-message-templates-migration
plan: 03
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - lib/actions/message-template.ts
  - lib/data/message-template.ts
autonomous: true

must_haves:
  truths:
    - "createMessageTemplate action validates and inserts templates"
    - "updateMessageTemplate action validates and updates templates"
    - "deleteMessageTemplate action removes non-default templates"
    - "getMessageTemplates returns templates filtered by business and optional channel"
    - "copySystemTemplate creates editable copy from system default"
  artifacts:
    - path: "lib/actions/message-template.ts"
      provides: "Server actions for template CRUD"
      exports: ["createMessageTemplate", "updateMessageTemplate", "deleteMessageTemplate", "copySystemTemplate"]
    - path: "lib/data/message-template.ts"
      provides: "Data fetching functions"
      exports: ["getMessageTemplates", "getMessageTemplate", "getDefaultMessageTemplates"]
  key_links:
    - from: "lib/actions/message-template.ts"
      to: "message_templates"
      via: "Supabase insert/update/delete"
      pattern: "from\\(['\"]message_templates['\"]\\)"
    - from: "lib/data/message-template.ts"
      to: "message_templates"
      via: "Supabase select"
      pattern: "from\\(['\"]message_templates['\"]\\)"
---

<objective>
Create server actions and data fetching functions for message templates CRUD operations.

Purpose: Enable template management with proper authentication, validation, and business scoping.
Output: Complete server-side functions for create/read/update/delete operations.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-message-templates-migration/23-CONTEXT.md
@.planning/phases/23-message-templates-migration/23-RESEARCH.md
@lib/actions/business.ts
@lib/data/business.ts
@lib/validations/message-template.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create message-template.ts server actions</name>
  <files>lib/actions/message-template.ts</files>
  <action>
Create new file lib/actions/message-template.ts with server actions following existing patterns from lib/actions/business.ts:

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { messageTemplateSchema } from '@/lib/validations/message-template'

export type MessageTemplateActionState = {
  error?: string
  fieldErrors?: Record<string, string[]>
  success?: boolean
  data?: { id: string }
}

/**
 * Create a new message template for the user's business.
 */
export async function createMessageTemplate(
  _prevState: MessageTemplateActionState | null,
  formData: FormData
): Promise<MessageTemplateActionState> {
  const supabase = await createClient()

  // Validate user authentication
  const { data: { user }, error: authError } = await supabase.auth.getUser()
  if (authError || !user) {
    return { error: 'You must be logged in to create templates' }
  }

  // Get user's business
  const { data: business, error: businessError } = await supabase
    .from('businesses')
    .select('id')
    .eq('user_id', user.id)
    .single()

  if (businessError || !business) {
    return { error: 'Please create a business profile first' }
  }

  // Parse form data
  const channel = formData.get('channel') as string
  const rawData = {
    channel,
    name: formData.get('name'),
    subject: channel === 'sms' ? '' : formData.get('subject'),
    body: formData.get('body'),
  }

  // Validate using discriminated union schema
  const parsed = messageTemplateSchema.safeParse(rawData)
  if (!parsed.success) {
    return { fieldErrors: parsed.error.flatten().fieldErrors }
  }

  const { name, subject, body } = parsed.data

  // Insert new template
  const { data: newTemplate, error } = await supabase
    .from('message_templates')
    .insert({
      business_id: business.id,
      name,
      subject: subject || '',
      body,
      channel,
      is_default: false,
    })
    .select('id')
    .single()

  if (error) {
    return { error: error.message }
  }

  revalidatePath('/settings')
  return { success: true, data: { id: newTemplate.id } }
}

/**
 * Update an existing message template.
 */
export async function updateMessageTemplate(
  templateId: string,
  _prevState: MessageTemplateActionState | null,
  formData: FormData
): Promise<MessageTemplateActionState> {
  const supabase = await createClient()

  const { data: { user }, error: authError } = await supabase.auth.getUser()
  if (authError || !user) {
    return { error: 'You must be logged in' }
  }

  // Verify template exists and belongs to user (RLS handles security)
  const { data: template } = await supabase
    .from('message_templates')
    .select('id, is_default, channel')
    .eq('id', templateId)
    .single()

  if (!template) {
    return { error: 'Template not found' }
  }

  if (template.is_default) {
    return { error: 'Cannot edit system templates. Use "Copy" to create an editable version.' }
  }

  // Parse and validate
  const channel = template.channel // Channel cannot change
  const rawData = {
    channel,
    name: formData.get('name'),
    subject: channel === 'sms' ? '' : formData.get('subject'),
    body: formData.get('body'),
  }

  const parsed = messageTemplateSchema.safeParse(rawData)
  if (!parsed.success) {
    return { fieldErrors: parsed.error.flatten().fieldErrors }
  }

  const { name, subject, body } = parsed.data

  const { error } = await supabase
    .from('message_templates')
    .update({ name, subject: subject || '', body })
    .eq('id', templateId)

  if (error) {
    return { error: error.message }
  }

  revalidatePath('/settings')
  return { success: true }
}

/**
 * Delete a message template.
 * Only allows deleting user's own non-default templates.
 */
export async function deleteMessageTemplate(
  templateId: string
): Promise<MessageTemplateActionState> {
  const supabase = await createClient()

  const { data: { user }, error: authError } = await supabase.auth.getUser()
  if (authError || !user) {
    return { error: 'You must be logged in' }
  }

  // Check if template is a default (RLS handles ownership)
  const { data: template } = await supabase
    .from('message_templates')
    .select('is_default')
    .eq('id', templateId)
    .single()

  if (!template) {
    return { error: 'Template not found' }
  }

  if (template.is_default) {
    return { error: 'Cannot delete system templates' }
  }

  const { error } = await supabase
    .from('message_templates')
    .delete()
    .eq('id', templateId)

  if (error) {
    return { error: error.message }
  }

  revalidatePath('/settings')
  return { success: true }
}

/**
 * Create a copy of a system template that the user can edit.
 * Used for "Use this template" flow.
 */
export async function copySystemTemplate(
  templateId: string,
  newName?: string
): Promise<MessageTemplateActionState> {
  const supabase = await createClient()

  const { data: { user }, error: authError } = await supabase.auth.getUser()
  if (authError || !user) {
    return { error: 'You must be logged in' }
  }

  const { data: business } = await supabase
    .from('businesses')
    .select('id')
    .eq('user_id', user.id)
    .single()

  if (!business) {
    return { error: 'Please create a business profile first' }
  }

  // Get the template to copy
  const { data: original } = await supabase
    .from('message_templates')
    .select('*')
    .eq('id', templateId)
    .single()

  if (!original) {
    return { error: 'Template not found' }
  }

  // Create copy with user's business_id
  const { data: copy, error } = await supabase
    .from('message_templates')
    .insert({
      business_id: business.id,
      name: newName || `${original.name} (Copy)`,
      subject: original.subject,
      body: original.body,
      channel: original.channel,
      is_default: false,
    })
    .select('id')
    .single()

  if (error) {
    return { error: error.message }
  }

  revalidatePath('/settings')
  return { success: true, data: { id: copy.id } }
}
```
  </action>
  <verify>Run `pnpm typecheck` - no type errors in message-template.ts</verify>
  <done>Server actions created for create, update, delete, and copy operations</done>
</task>

<task type="auto">
  <name>Task 2: Create message-template.ts data functions</name>
  <files>lib/data/message-template.ts</files>
  <action>
Create new file lib/data/message-template.ts with data fetching functions:

```typescript
import { createClient } from '@/lib/supabase/server'
import type { MessageTemplate, MessageChannel } from '@/lib/types/database'

/**
 * Fetch all message templates for the current user's business.
 * Optionally filter by channel (email/sms).
 */
export async function getMessageTemplates(
  channel?: MessageChannel
): Promise<MessageTemplate[]> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return []
  }

  // Get user's business
  const { data: business } = await supabase
    .from('businesses')
    .select('id')
    .eq('user_id', user.id)
    .single()

  if (!business) {
    return []
  }

  let query = supabase
    .from('message_templates')
    .select('*')
    .eq('business_id', business.id)
    .order('is_default', { ascending: false })
    .order('created_at', { ascending: true })

  if (channel) {
    query = query.eq('channel', channel)
  }

  const { data } = await query
  return data || []
}

/**
 * Fetch a single message template by ID.
 * Returns null if not found or not authorized.
 */
export async function getMessageTemplate(
  templateId: string
): Promise<MessageTemplate | null> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return null
  }

  // RLS handles authorization - only returns if user owns the business
  const { data } = await supabase
    .from('message_templates')
    .select('*')
    .eq('id', templateId)
    .single()

  return data
}

/**
 * Get default system templates.
 * These are templates where is_default = true.
 * Used for "Use this template" feature.
 */
export async function getDefaultMessageTemplates(
  channel?: MessageChannel
): Promise<MessageTemplate[]> {
  const supabase = await createClient()

  let query = supabase
    .from('message_templates')
    .select('*')
    .eq('is_default', true)
    .order('name', { ascending: true })

  if (channel) {
    query = query.eq('channel', channel)
  }

  const { data } = await query
  return data || []
}

/**
 * Get templates available for sending.
 * Includes both user-created and default templates.
 * Useful for template selectors in send forms.
 */
export async function getAvailableTemplates(
  channel?: MessageChannel
): Promise<MessageTemplate[]> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return []
  }

  const { data: business } = await supabase
    .from('businesses')
    .select('id')
    .eq('user_id', user.id)
    .single()

  if (!business) {
    return []
  }

  // Get user's templates + defaults
  let query = supabase
    .from('message_templates')
    .select('*')
    .or(`business_id.eq.${business.id},is_default.eq.true`)
    .order('is_default', { ascending: false })
    .order('name', { ascending: true })

  if (channel) {
    query = query.eq('channel', channel)
  }

  const { data } = await query
  return data || []
}
```
  </action>
  <verify>Run `pnpm typecheck` - no type errors in data functions</verify>
  <done>Data fetching functions created with channel filtering support</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Run `pnpm typecheck` - no type errors
2. Run `pnpm lint` - no lint errors
3. Check lib/actions/message-template.ts exports 4 functions
4. Check lib/data/message-template.ts exports 4 functions
</verification>

<success_criteria>
- Server actions handle validation errors gracefully
- Server actions revalidate correct paths
- Data functions support channel filtering
- copySystemTemplate creates editable copy with user's business_id
- All functions use proper auth checks
</success_criteria>

<output>
After completion, create `.planning/phases/23-message-templates-migration/23-03-SUMMARY.md`
</output>
