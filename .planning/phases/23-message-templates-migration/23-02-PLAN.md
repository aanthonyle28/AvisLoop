---
phase: 23-message-templates-migration
plan: 02
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - lib/types/database.ts
  - lib/validations/message-template.ts
  - lib/constants/default-templates.ts
  - lib/actions/message-template.ts
  - lib/data/message-template.ts
autonomous: true

must_haves:
  truths:
    - "MessageTemplate type supports both email and SMS channels"
    - "Zod schema uses discriminated union for channel-specific validation"
    - "Server actions support create/update/delete for message templates"
    - "Default templates defined in constants file"
  artifacts:
    - path: "lib/types/database.ts"
      provides: "MessageTemplate type definition"
      contains: "interface MessageTemplate"
    - path: "lib/validations/message-template.ts"
      provides: "Zod validation schema with discriminated union"
      contains: "discriminatedUnion"
    - path: "lib/constants/default-templates.ts"
      provides: "16 default templates (8 service types x 2 channels)"
      min_lines: 100
    - path: "lib/actions/message-template.ts"
      provides: "Server actions for CRUD operations"
      exports: ["createMessageTemplate", "updateMessageTemplate", "deleteMessageTemplate"]
    - path: "lib/data/message-template.ts"
      provides: "Data fetching functions"
      exports: ["getMessageTemplates", "getMessageTemplate"]
  key_links:
    - from: "lib/actions/message-template.ts"
      to: "lib/validations/message-template.ts"
      via: "schema import for validation"
      pattern: "import.*messageTemplateSchema"
    - from: "lib/actions/message-template.ts"
      to: "message_templates"
      via: "supabase query"
      pattern: "from\\(['\"]message_templates['\"]\\)"
---

<objective>
Create TypeScript types, Zod validations, server actions, and data functions for unified message templates.

Purpose: Enable type-safe CRUD operations for both email and SMS templates with proper validation.
Output: Complete TypeScript layer for message_templates table.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-message-templates-migration/23-CONTEXT.md
@.planning/phases/23-message-templates-migration/23-RESEARCH.md
@lib/types/database.ts
@lib/validations/business.ts
@lib/actions/business.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MessageTemplate types to database.ts</name>
  <files>lib/types/database.ts</files>
  <action>
Add MessageTemplate interface and related types to lib/types/database.ts:

```typescript
// Message channel literal union
export type MessageChannel = 'email' | 'sms'

// Unified message template supporting both email and SMS
export interface MessageTemplate {
  id: string
  business_id: string
  name: string
  subject: string        // Required for email, empty string for SMS
  body: string
  channel: MessageChannel
  is_default: boolean
  created_at: string
  updated_at: string
}

// Insert type (omit auto-generated fields)
export type MessageTemplateInsert = Omit<MessageTemplate, 'id' | 'created_at' | 'updated_at'>

// Update type (partial, omit immutable fields)
export type MessageTemplateUpdate = Partial<Omit<MessageTemplate, 'id' | 'business_id' | 'created_at' | 'updated_at'>>

// Combined type for business with nested templates
export interface BusinessWithMessageTemplates extends Business {
  message_templates: MessageTemplate[]
}
```

Keep existing EmailTemplate type for backward compatibility but add deprecation comment:
```typescript
/** @deprecated Use MessageTemplate with channel='email' instead */
export interface EmailTemplate { ... }
```

Update BusinessWithTemplates to use MessageTemplate:
```typescript
export interface BusinessWithTemplates extends Business {
  email_templates: EmailTemplate[]  // Keep for backward compat
  message_templates?: MessageTemplate[]  // New unified templates
}
```
  </action>
  <verify>Run `pnpm typecheck` - no type errors related to MessageTemplate</verify>
  <done>MessageTemplate interface added with channel discriminator, insert/update types, deprecation on EmailTemplate</done>
</task>

<task type="auto">
  <name>Task 2: Create message-template.ts validation schema</name>
  <files>lib/validations/message-template.ts</files>
  <action>
Create new file lib/validations/message-template.ts with Zod discriminated union schema:

```typescript
import { z } from 'zod'

// Base fields shared by both channels
const baseTemplateFields = {
  name: z
    .string()
    .min(1, 'Template name is required')
    .max(100, 'Template name must be less than 100 characters')
    .trim(),
}

// Email template schema
const emailTemplateSchema = z.object({
  ...baseTemplateFields,
  channel: z.literal('email'),
  subject: z
    .string()
    .min(1, 'Email subject is required')
    .max(200, 'Subject must be less than 200 characters')
    .trim(),
  body: z
    .string()
    .min(1, 'Email body is required')
    .max(5000, 'Body must be less than 5000 characters')
    .trim(),
})

// SMS template schema (soft limit on body, allow multi-segment)
const smsTemplateSchema = z.object({
  ...baseTemplateFields,
  channel: z.literal('sms'),
  subject: z.literal('').optional().default(''), // SMS has no subject
  body: z
    .string()
    .min(1, 'SMS body is required')
    .max(320, 'SMS body too long (max 2 segments)') // Soft limit
    .trim(),
})

// Discriminated union - validates based on channel value
export const messageTemplateSchema = z.discriminatedUnion('channel', [
  emailTemplateSchema,
  smsTemplateSchema,
])

// Type exports
export type MessageTemplateInput = z.infer<typeof messageTemplateSchema>
export type EmailTemplateSchemaInput = z.infer<typeof emailTemplateSchema>
export type SMSTemplateSchemaInput = z.infer<typeof smsTemplateSchema>

// Re-export individual schemas for direct use if needed
export { emailTemplateSchema, smsTemplateSchema }
```

Key points:
- Uses z.discriminatedUnion for efficient parsing based on channel
- SMS has soft limit (320 chars = 2 segments max) with warning, not hard block
- SMS subject is empty string (not null) to satisfy DB constraint
  </action>
  <verify>Run `pnpm typecheck` - message-template.ts compiles without errors</verify>
  <done>Zod discriminated union schema created for email and SMS validation</done>
</task>

<task type="auto">
  <name>Task 3: Create default-templates.ts constants file</name>
  <files>lib/constants/default-templates.ts</files>
  <action>
Create new file lib/constants/default-templates.ts with all 16 default templates.

Use the following structure:
```typescript
import type { MessageChannel, ServiceType } from '@/lib/types/database'

interface DefaultTemplate {
  name: string
  channel: MessageChannel
  service_type: ServiceType
  subject: string  // Empty string for SMS
  body: string
}

export const DEFAULT_TEMPLATES: DefaultTemplate[] = [
  // EMAIL TEMPLATES (8 service types)
  {
    name: 'HVAC Service Review',
    channel: 'email',
    service_type: 'hvac',
    subject: 'How was your AC/heating service, {{CUSTOMER_NAME}}?',
    body: `Hi {{CUSTOMER_NAME}},

Thank you for choosing {{BUSINESS_NAME}} for your HVAC service! We hope your home is now perfectly comfortable.

We'd love to hear about your experience. Your feedback helps us continue providing excellent heating and cooling services.

Leave a review here: {{REVIEW_LINK}}

Thanks for your trust in us,
{{SENDER_NAME}}`
  },
  // ... continue for plumbing, electrical, cleaning, roofing, painting, handyman, other

  // SMS TEMPLATES (8 service types) - Keep under 140 chars to reserve space for opt-out footer
  {
    name: 'HVAC Service SMS',
    channel: 'sms',
    service_type: 'hvac',
    subject: '',
    body: 'Hi {{CUSTOMER_NAME}}, thanks for choosing {{BUSINESS_NAME}} for HVAC! We\'d love your feedback. Reply YES for review link.'
  },
  // ... continue for other service types
]

// Helper to get templates by channel
export function getDefaultTemplatesByChannel(channel: MessageChannel): DefaultTemplate[] {
  return DEFAULT_TEMPLATES.filter(t => t.channel === channel)
}

// Helper to get templates by service type
export function getDefaultTemplatesByServiceType(serviceType: ServiceType): DefaultTemplate[] {
  return DEFAULT_TEMPLATES.filter(t => t.service_type === serviceType)
}
```

EMAIL TEMPLATE BODIES (expand for each):
- hvac: Emphasize comfort, temperature control, reliable service
- plumbing: Emphasize reliability, quick response, problem solved
- electrical: Emphasize safety, expertise, peace of mind
- cleaning: Emphasize attention to detail, sparkling results
- roofing: Emphasize protection, quality materials, long-term value
- painting: Emphasize transformation, beautiful results, craftsmanship
- handyman: Emphasize versatility, dependability, getting things done
- other: Generic friendly tone, appreciation for choosing the business

SMS TEMPLATE BODIES (keep under 140 chars):
- Use contractions to save space
- Don't include URL (too long) - use "Reply YES for review link" pattern
- Include {{CUSTOMER_NAME}} and {{BUSINESS_NAME}} placeholders
- Service-specific language where space allows
  </action>
  <verify>Run `pnpm typecheck` - constants file compiles. Verify all 16 templates defined (8 email + 8 SMS). Check SMS bodies under 140 chars.</verify>
  <done>16 default templates defined with appropriate tone per service type and channel</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Run `pnpm typecheck` - no type errors
2. Run `pnpm lint` - no lint errors
3. Check lib/types/database.ts has MessageTemplate interface
4. Check lib/validations/message-template.ts has discriminatedUnion schema
5. Check lib/constants/default-templates.ts has 16 templates
</verification>

<success_criteria>
- MessageTemplate type with channel discriminator
- Zod schema validates email (subject required) vs SMS (body only)
- 16 default templates with service-appropriate tone
- All types compile without errors
</success_criteria>

<output>
After completion, create `.planning/phases/23-message-templates-migration/23-02-SUMMARY.md`
</output>
