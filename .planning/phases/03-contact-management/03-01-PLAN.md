---
phase: 03-contact-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00003_create_contacts.sql
  - lib/validations/contact.ts
  - lib/types/database.ts
autonomous: true

must_haves:
  truths:
    - "Contacts table exists with business_id foreign key"
    - "RLS policies enforce business-scoped access"
    - "Unique constraint prevents duplicate emails per business"
  artifacts:
    - path: "supabase/migrations/00003_create_contacts.sql"
      provides: "Database schema for contacts"
      contains: "CREATE TABLE public.contacts"
    - path: "lib/validations/contact.ts"
      provides: "Zod schemas for contact validation"
      exports: ["contactSchema", "ContactInput"]
    - path: "lib/types/database.ts"
      provides: "Contact TypeScript types"
      contains: "interface Contact"
  key_links:
    - from: "contacts table"
      to: "businesses table"
      via: "foreign key business_id"
      pattern: "REFERENCES public.businesses"
---

<objective>
Create database schema for contacts with RLS policies, Zod validation schemas, and TypeScript types.

Purpose: Foundation for contact storage with multi-tenant isolation
Output: Migration file, validation schemas, TypeScript types
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-contact-management/03-RESEARCH.md
@supabase/migrations/00002_create_business.sql
@lib/validations/business.ts
@lib/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create contacts database migration</name>
  <files>supabase/migrations/00003_create_contacts.sql</files>
  <action>
Create migration file with:

1. **contacts table:**
   - id: UUID primary key with gen_random_uuid()
   - business_id: UUID FK to businesses.id (NOT NULL, ON DELETE CASCADE)
   - name: TEXT NOT NULL
   - email: TEXT NOT NULL (stored lowercase)
   - phone: TEXT (nullable, for future SMS)
   - status: TEXT NOT NULL DEFAULT 'active' (values: 'active', 'archived')
   - last_sent_at: TIMESTAMPTZ (nullable, for tracking sends)
   - send_count: INTEGER DEFAULT 0
   - created_at: TIMESTAMPTZ DEFAULT now()
   - updated_at: TIMESTAMPTZ DEFAULT now()

2. **Constraints:**
   - UNIQUE constraint on (business_id, email) for duplicate prevention
   - CHECK constraint on status IN ('active', 'archived')

3. **Indexes:**
   - Index on business_id for FK lookups
   - Index on (business_id, status) for filtered queries
   - Index on (business_id, email) for duplicate checks (covered by unique constraint)

4. **RLS policies (subquery pattern from Phase 2):**
   - SELECT: business_id IN (SELECT id FROM businesses WHERE user_id = (SELECT auth.uid()))
   - INSERT: Same check + business_id must match user's business
   - UPDATE: Same subquery check
   - DELETE: Same subquery check

5. **Trigger:**
   - updated_at trigger using moddatetime (already enabled in 00002)

Follow exact pattern from 00002_create_business.sql for consistency.
  </action>
  <verify>File exists and contains CREATE TABLE, RLS ENABLE, policies for SELECT/INSERT/UPDATE/DELETE</verify>
  <done>Migration creates contacts table with proper FK, unique constraint, RLS policies</done>
</task>

<task type="auto">
  <name>Task 2: Create Zod validation schemas for contacts</name>
  <files>lib/validations/contact.ts</files>
  <action>
Create validation schemas following business.ts pattern:

1. **contactSchema** - For add/edit forms:
   - name: string, min 1, max 100, required, trimmed
   - email: string, email format, required (will be lowercased in action)
   - phone: string, max 20, optional or empty string (use .optional().or(z.literal('')))

2. **csvContactSchema** - For CSV import (relaxed for batch processing):
   - name: string, min 1, max 100
   - email: string, email format
   - phone: string, optional

3. **Export types:**
   - ContactInput = z.infer<typeof contactSchema>
   - CSVContactInput = z.infer<typeof csvContactSchema>
  </action>
  <verify>`npx tsc --noEmit` passes, exports are accessible</verify>
  <done>Validation schemas match form requirements with proper optional field handling</done>
</task>

<task type="auto">
  <name>Task 3: Add Contact types to database types file</name>
  <files>lib/types/database.ts</files>
  <action>
Add to existing lib/types/database.ts:

1. **Contact interface:**
   ```typescript
   export interface Contact {
     id: string
     business_id: string
     name: string
     email: string
     phone: string | null
     status: 'active' | 'archived'
     last_sent_at: string | null
     send_count: number
     created_at: string
     updated_at: string
   }
   ```

2. **ContactInsert type:**
   ```typescript
   export type ContactInsert = Omit<Contact, 'id' | 'created_at' | 'updated_at' | 'last_sent_at' | 'send_count'>
   ```

3. **ContactUpdate type:**
   ```typescript
   export type ContactUpdate = Partial<Omit<Contact, 'id' | 'business_id' | 'created_at' | 'updated_at'>>
   ```

Keep existing Business and EmailTemplate types intact.
  </action>
  <verify>`npx tsc --noEmit` passes, Contact type exported</verify>
  <done>Contact types added with Insert/Update variants matching database schema</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - TypeScript compiles without errors
2. Migration file has all required elements (table, constraints, RLS, trigger)
3. Validation schemas handle both required and optional fields
4. Types match database schema columns
</verification>

<success_criteria>
- [ ] Migration file creates contacts table with proper schema
- [ ] Unique constraint on (business_id, email) prevents duplicates
- [ ] RLS policies use subquery pattern from Phase 2
- [ ] Zod schemas validate required fields and handle empty strings
- [ ] TypeScript types match database schema
- [ ] All files compile without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-contact-management/03-01-SUMMARY.md`
</output>
