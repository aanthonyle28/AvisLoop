---
phase: 03-contact-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/actions/contact.ts
autonomous: true

must_haves:
  truths:
    - "Server Actions authenticate users before mutations"
    - "Contacts are scoped to user's business"
    - "Duplicate emails within same business are rejected"
    - "Archived contacts can be restored"
  artifacts:
    - path: "lib/actions/contact.ts"
      provides: "Server Actions for contact CRUD"
      exports: ["createContact", "updateContact", "archiveContact", "restoreContact", "deleteContact", "bulkArchiveContacts", "bulkDeleteContacts", "getContacts", "searchContacts", "ContactActionState"]
  key_links:
    - from: "lib/actions/contact.ts"
      to: "lib/validations/contact.ts"
      via: "import contactSchema"
      pattern: "import.*contactSchema.*from"
    - from: "lib/actions/contact.ts"
      to: "supabase.from('contacts')"
      via: "database queries"
      pattern: "from\\('contacts'\\)"
---

<objective>
Create Server Actions for contact CRUD operations with auth validation, duplicate prevention, and bulk operations.

Purpose: API layer for all contact mutations and queries
Output: Server Actions file with complete CRUD + bulk operations
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-contact-management/03-RESEARCH.md
@lib/actions/business.ts
@lib/validations/business.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create contact Server Actions</name>
  <files>lib/actions/contact.ts</files>
  <action>
Create Server Actions file following exact pattern from business.ts:

**Header:**
```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { contactSchema } from '@/lib/validations/contact'

export type ContactActionState = {
  error?: string
  fieldErrors?: Record<string, string[]>
  success?: boolean
  data?: { id: string }  // Return ID for created/updated contacts
}
```

**Core Actions:**

1. **createContact(_prevState, formData):**
   - getUser() for auth (not getSession)
   - Fetch business by user_id (return error if no business)
   - Parse with contactSchema.safeParse
   - Lowercase email before duplicate check
   - Check for duplicate email within business (SELECT id WHERE business_id AND email)
   - Return fieldErrors.email if duplicate found
   - Insert with business_id, lowercase email
   - revalidatePath('/dashboard/contacts')
   - Return { success: true, data: { id } }

2. **updateContact(_prevState, formData):**
   - Auth validation
   - Extract contactId from formData
   - Parse with contactSchema.safeParse
   - Check duplicate email (excluding current contact id)
   - Update contact (RLS handles ownership)
   - revalidatePath('/dashboard/contacts')

3. **archiveContact(contactId: string):**
   - Auth validation
   - Update status to 'archived'
   - revalidatePath('/dashboard/contacts')

4. **restoreContact(contactId: string):**
   - Auth validation
   - Update status to 'active'
   - revalidatePath('/dashboard/contacts')

5. **deleteContact(contactId: string):**
   - Auth validation
   - Delete contact (RLS handles ownership)
   - revalidatePath('/dashboard/contacts')

**Bulk Actions:**

6. **bulkArchiveContacts(contactIds: string[]):**
   - Auth validation
   - Update all contacts in array to status 'archived'
   - Use .in('id', contactIds)
   - revalidatePath('/dashboard/contacts')

7. **bulkDeleteContacts(contactIds: string[]):**
   - Auth validation
   - Delete all contacts in array
   - Use .in('id', contactIds)
   - revalidatePath('/dashboard/contacts')

8. **bulkCreateContacts(contacts: Array<{name, email, phone?}>):**
   - Auth validation
   - Get business
   - Lowercase all emails
   - Fetch existing emails for this business
   - Filter out duplicates (keep track of skipped)
   - Insert remaining contacts
   - Return { success: true, data: { created: N, skipped: M, duplicates: [...] } }
   - revalidatePath('/dashboard/contacts')

**Data Fetching (collocate with actions per Phase 2 pattern):**

9. **getContacts():**
   - For Server Components
   - Get user's business, then fetch contacts
   - Order by last_sent_at DESC NULLS LAST, then created_at DESC
   - Return empty array if no business

10. **searchContacts(query, filters):**
    - query: string for name/email search
    - filters: { status?: string, dateFrom?: Date, dateTo?: Date }
    - Use .or(`name.ilike.%${query}%,email.ilike.%${query}%`)
    - Apply status filter if provided
    - Apply date range filters if provided
    - Return Contact[]
  </action>
  <verify>`npx tsc --noEmit` passes, all exports accessible</verify>
  <done>All 10 Server Actions created with proper auth, validation, and revalidation</done>
</task>

<task type="auto">
  <name>Task 2: Add bulk create return type</name>
  <files>lib/actions/contact.ts</files>
  <action>
Add specialized return type for bulkCreateContacts at top of file:

```typescript
export type BulkCreateResult = {
  error?: string
  success?: boolean
  data?: {
    created: number
    skipped: number
    duplicates: string[]  // List of duplicate emails that were skipped
  }
}
```

Update bulkCreateContacts to return this type instead of ContactActionState.

This supports CSV import preview showing which contacts were imported vs skipped.
  </action>
  <verify>`npx tsc --noEmit` passes, BulkCreateResult exported</verify>
  <done>Bulk create has proper return type for import feedback</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - TypeScript compiles
2. `npm run lint` - No lint errors
3. All 10+ functions exported
4. Pattern matches business.ts (getUser, safeParse, revalidatePath)
</verification>

<success_criteria>
- [ ] All CRUD actions authenticate with getUser()
- [ ] All actions fetch business_id (not relying on client-provided ID)
- [ ] createContact/updateContact check for duplicate emails
- [ ] Emails are lowercased before storage
- [ ] Bulk operations use .in() for efficiency
- [ ] bulkCreateContacts returns created/skipped counts
- [ ] All mutations call revalidatePath
- [ ] searchContacts supports name/email search and status filter
</success_criteria>

<output>
After completion, create `.planning/phases/03-contact-management/03-02-SUMMARY.md`
</output>
