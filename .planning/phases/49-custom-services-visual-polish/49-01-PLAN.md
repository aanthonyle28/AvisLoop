---
phase: 49-custom-services-visual-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - components/providers/business-settings-provider.tsx
  - app/(dashboard)/layout.tsx
  - components/jobs/service-type-select.tsx
  - components/jobs/add-job-sheet.tsx
  - components/jobs/edit-job-sheet.tsx
autonomous: true

must_haves:
  truths:
    - "BusinessSettingsProvider exposes customServiceNames string[] alongside enabledServiceTypes"
    - "ServiceTypeSelect renders custom service names as options with value='other' when 'other' is enabled and customServiceNames is non-empty"
    - "When customServiceNames is empty but 'other' is enabled, ServiceTypeSelect falls back to the standard 'Other' label"
    - "AddJobSheet and EditJobSheet pass customServiceNames from context to ServiceTypeSelect"
  artifacts:
    - "components/providers/business-settings-provider.tsx with customServiceNames in context"
    - "app/(dashboard)/layout.tsx passing customServiceNames to provider"
    - "components/jobs/service-type-select.tsx with customServiceNames prop"
    - "components/jobs/add-job-sheet.tsx destructuring customServiceNames"
    - "components/jobs/edit-job-sheet.tsx destructuring customServiceNames"
  key_links:
    - "getServiceTypeSettings() already returns customServiceNames — layout must destructure and pass it"
    - "ServiceTypeSelect custom name options MUST use value='other' — DB only stores 'other'"
    - "Empty customServiceNames array must NOT hide the 'Other' option when 'other' is in enabledTypes"
---

<objective>
Extend BusinessSettingsProvider to expose customServiceNames and propagate custom service names through ServiceTypeSelect to the Add Job and Edit Job sheets.

Purpose: Custom service names (e.g., "Pest Control", "Pool Cleaning") entered in onboarding or settings currently persist to the DB but don't appear in job creation/editing service type dropdowns. This plan threads the data from the existing provider through to the selector UI.

Output: ServiceTypeSelect renders custom names instead of generic "Other" label when custom names are configured.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/49-custom-services-visual-polish/49-RESEARCH.md

Key files:
@components/providers/business-settings-provider.tsx
@app/(dashboard)/layout.tsx
@components/jobs/service-type-select.tsx
@components/jobs/add-job-sheet.tsx
@components/jobs/edit-job-sheet.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend BusinessSettingsProvider and dashboard layout</name>
  <files>
    components/providers/business-settings-provider.tsx
    app/(dashboard)/layout.tsx
  </files>
  <action>
**business-settings-provider.tsx:**

1. Add `customServiceNames: string[]` to the `BusinessSettingsContextValue` interface
2. Add `customServiceNames: string[]` to the `BusinessSettingsProviderProps` interface
3. Update the Provider JSX to include `customServiceNames` in the value object

The updated interfaces should be:
```typescript
interface BusinessSettingsContextValue {
  enabledServiceTypes: ServiceType[]
  customServiceNames: string[]
}

interface BusinessSettingsProviderProps {
  enabledServiceTypes: ServiceType[]
  customServiceNames: string[]
  children: React.ReactNode
}
```

And the provider component should pass both values:
```typescript
<BusinessSettingsContext.Provider value={{ enabledServiceTypes, customServiceNames }}>
```

**layout.tsx:**

1. After the existing `const enabledServiceTypes = ...` line, add:
   ```typescript
   const customServiceNames = serviceSettings?.customServiceNames || []
   ```
2. Pass `customServiceNames` to the provider:
   ```tsx
   <BusinessSettingsProvider enabledServiceTypes={enabledServiceTypes} customServiceNames={customServiceNames}>
   ```

No new DB queries needed — `getServiceTypeSettings()` already returns `customServiceNames`.
  </action>
  <verify>
Run `pnpm typecheck` — must pass with no errors related to BusinessSettingsProvider props or context value.
  </verify>
  <done>
BusinessSettingsProvider exposes `customServiceNames: string[]` in context and the dashboard layout passes the value from `getServiceTypeSettings()`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update ServiceTypeSelect and job sheet consumers</name>
  <files>
    components/jobs/service-type-select.tsx
    components/jobs/add-job-sheet.tsx
    components/jobs/edit-job-sheet.tsx
  </files>
  <action>
**service-type-select.tsx:**

1. Add `customServiceNames?: string[]` to the `ServiceTypeSelectProps` interface
2. Destructure `customServiceNames` in the component function
3. Replace the mapping inside `<select>` to handle the "other" type specially:

When iterating over `availableTypes`, for the `'other'` type:
- If `customServiceNames` exists AND has length > 0, render each custom name as a separate `<option>` with `value="other"`. Use key `other-{name}` to keep React happy.
- If `customServiceNames` is empty or undefined, render the standard `SERVICE_TYPE_LABELS['other']` option (fallback to "Other").

The render logic for each type should be:
```tsx
{availableTypes.map(type => {
  // For 'other' with custom names, render each custom name
  if (type === 'other' && customServiceNames && customServiceNames.length > 0) {
    return customServiceNames.map(name => (
      <option key={`other-${name}`} value="other">
        {name}
      </option>
    ))
  }
  return (
    <option key={type} value={type}>
      {SERVICE_TYPE_LABELS[type]}
    </option>
  )
})}
```

Use `.flatMap()` or wrap in a Fragment if needed to avoid nested arrays. The simplest approach: change `.map()` to `.flatMap()` on the outer `availableTypes` iteration, and return an array for the custom names case.

**CRITICAL:** All custom name options MUST have `value="other"`. The DB only stores `service_type = 'other'`. Custom names are display-only.

**add-job-sheet.tsx:**

1. Change the destructuring from `const { enabledServiceTypes } = useBusinessSettings()` to:
   ```typescript
   const { enabledServiceTypes, customServiceNames } = useBusinessSettings()
   ```
2. Pass `customServiceNames` to the `ServiceTypeSelect`:
   ```tsx
   <ServiceTypeSelect
     value={serviceType}
     onChange={setServiceType}
     error={state?.fieldErrors?.serviceType?.[0]}
     enabledTypes={enabledServiceTypes}
     customServiceNames={customServiceNames}
   />
   ```

**edit-job-sheet.tsx:**

1. Same change: destructure `customServiceNames` from `useBusinessSettings()`
2. Pass `customServiceNames` to the `ServiceTypeSelect`:
   ```tsx
   <ServiceTypeSelect
     value={serviceType}
     onChange={setServiceType}
     error={state?.fieldErrors?.serviceType?.[0]}
     enabledTypes={enabledServiceTypes}
     customServiceNames={customServiceNames}
   />
   ```
  </action>
  <verify>
1. `pnpm typecheck` passes
2. `pnpm lint` passes
3. Grep for `customServiceNames` in service-type-select.tsx, add-job-sheet.tsx, edit-job-sheet.tsx confirms the prop is threaded through
  </verify>
  <done>
ServiceTypeSelect renders custom service names as `<option value="other">{customName}</option>` entries. AddJobSheet and EditJobSheet both pass customServiceNames from context to the selector. When no custom names exist, the standard "Other" label renders as before.
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` — zero errors
2. `pnpm lint` — zero errors or warnings
3. Grep `customServiceNames` across modified files — present in all 5 files
4. Grep `value="other"` or `value={'other'}` in service-type-select.tsx — custom name options use 'other' value
</verification>

<success_criteria>
- BusinessSettingsProvider context includes `customServiceNames: string[]`
- Dashboard layout passes `customServiceNames` from existing `getServiceTypeSettings()` data
- ServiceTypeSelect renders custom names when provided, falls back to "Other" when empty
- AddJobSheet and EditJobSheet both pass customServiceNames to ServiceTypeSelect
- No TypeScript errors, no lint errors
</success_criteria>

<output>
After completion, create `.planning/phases/49-custom-services-visual-polish/49-01-SUMMARY.md`
</output>
