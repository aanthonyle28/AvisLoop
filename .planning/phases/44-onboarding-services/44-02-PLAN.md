---
phase: 44-onboarding-services
plan: 02
type: execute
wave: 2
depends_on: ["44-01"]
files_modified:
  - lib/types/database.ts
  - lib/types/onboarding.ts
  - lib/validations/onboarding.ts
  - lib/actions/onboarding.ts
  - lib/actions/business.ts
  - lib/data/onboarding.ts
  - lib/data/business.ts
  - components/onboarding/steps/business-setup-step.tsx
  - components/settings/service-types-section.tsx
  - components/settings/settings-tabs.tsx
  - app/onboarding/page.tsx
autonomous: true

must_haves:
  truths:
    - "When 'Other' is selected in the onboarding services step, users can type and add multiple custom service names as tags"
    - "Custom service names appear as removable tag badges below the input"
    - "Pressing Enter in the custom service input adds the tag and does NOT submit the parent form"
    - "Custom service names are saved to a custom_service_names TEXT[] column on businesses"
    - "Settings services section has the same multi-tag input when 'Other' is enabled"
    - "The custom_service_names column exists in the database (migration applied)"
    - "Custom service names are loaded from the database and pre-populated in both onboarding and settings"
  artifacts:
    - path: "components/onboarding/steps/business-setup-step.tsx"
      provides: "Multi-tag custom service input when Other is selected"
      contains: "TagBadge"
    - path: "components/settings/service-types-section.tsx"
      provides: "Multi-tag custom service input in settings"
      contains: "TagBadge"
    - path: "lib/actions/onboarding.ts"
      provides: "saveServicesOffered with custom service names support"
      contains: "custom_service_names"
    - path: "lib/actions/business.ts"
      provides: "updateServiceTypeSettings with custom service names support"
      contains: "custom_service_names"
    - path: "lib/data/business.ts"
      provides: "getServiceTypeSettings fetches custom_service_names"
      contains: "customServiceNames"
    - path: "components/settings/settings-tabs.tsx"
      provides: "Threads customServiceNames from serviceTypeSettings to ServiceTypesSection"
      contains: "initialCustomServiceNames"
  key_links:
    - from: "components/onboarding/steps/business-setup-step.tsx"
      to: "lib/actions/onboarding.ts"
      via: "saveServicesOffered({ serviceTypes, customServiceNames })"
      pattern: "customServiceNames"
    - from: "components/settings/service-types-section.tsx"
      to: "lib/actions/business.ts"
      via: "updateServiceTypeSettings({ serviceTypesEnabled, serviceTypeTiming, customServiceNames })"
      pattern: "customServiceNames"
    - from: "lib/data/business.ts"
      to: "components/settings/settings-tabs.tsx"
      via: "getServiceTypeSettings() returns customServiceNames"
      pattern: "customServiceNames"
    - from: "components/settings/settings-tabs.tsx"
      to: "components/settings/service-types-section.tsx"
      via: "initialCustomServiceNames={serviceTypeSettings?.customServiceNames || []}"
      pattern: "initialCustomServiceNames"
---

<objective>
Enable multiple custom service names when "Other" is selected in both the onboarding services step and the settings services section. Replace the single text input with a tag-style multi-input using the existing TagBadge component. Custom service names are stored in a new `custom_service_names TEXT[]` column on the businesses table, separate from the fixed service types used for campaign matching.

Purpose: Businesses often offer multiple niche services beyond the 8 fixed types. This lets them describe all their services without polluting the campaign-matching service type system.

Output: Tag-style multi-input for custom services in onboarding and settings. Database migration adds `custom_service_names` column. Data flows from UI through server actions to database and back.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key source files:
@components/onboarding/steps/business-setup-step.tsx — Onboarding services step (has single text input for Other)
@components/settings/service-types-section.tsx — Settings services section (no custom service input yet)
@components/ui/tag-badge.tsx — TagBadge and TagList components
@lib/validations/onboarding.ts — servicesOfferedSchema
@lib/validations/job.ts — SERVICE_TYPES constant
@lib/actions/onboarding.ts — saveServicesOffered action
@lib/actions/business.ts — updateServiceTypeSettings action
@lib/types/database.ts — Business interface
@lib/types/onboarding.ts — OnboardingBusiness type
@lib/data/onboarding.ts — getOnboardingStatus query (fetches business data)
@app/onboarding/page.tsx — Maps business to OnboardingBusiness
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database migration and type updates for custom_service_names</name>
  <files>
    lib/types/database.ts
    lib/types/onboarding.ts
    lib/validations/onboarding.ts
    lib/data/onboarding.ts
    lib/data/business.ts
    app/onboarding/page.tsx
  </files>
  <action>
    **1. Apply database migration via Supabase MCP:**

    Use the `mcp__supabase__apply_migration` tool to apply:
    ```sql
    ALTER TABLE public.businesses
      ADD COLUMN IF NOT EXISTS custom_service_names TEXT[] DEFAULT '{}';

    COMMENT ON COLUMN businesses.custom_service_names IS 'Array of custom service names when Other service type is enabled. Display-only, not used for campaign matching.';
    ```
    Migration name: `add_custom_service_names`

    **2. Update `lib/types/database.ts`:**

    Add `custom_service_names` to the `Business` interface, after `review_cooldown_days`:
    ```tsx
    custom_service_names: string[]
    ```

    **3. Update `lib/types/onboarding.ts`:**

    Add `custom_service_names` to the `OnboardingBusiness` type:
    ```tsx
    export type OnboardingBusiness = {
      name: string
      phone: string | null
      google_review_link: string | null
      software_used: string | null
      service_types_enabled: string[] | null
      custom_service_names: string[] | null   // <-- ADD THIS
      sms_consent_acknowledged: boolean
    } | null
    ```

    **4. Update `lib/validations/onboarding.ts`:**

    Extend `servicesOfferedSchema` to accept custom service names:
    ```tsx
    export const servicesOfferedSchema = z.object({
      serviceTypes: z.array(z.enum(SERVICE_TYPES)).min(1, 'Select at least one service type'),
      customServiceNames: z.array(
        z.string().min(1).max(50).trim()
      ).max(10).optional().default([]),
    })
    ```
    This keeps the existing `serviceTypes` validation strict (only the 8 fixed types) while allowing up to 10 custom names of max 50 chars each.

    **5. Update `lib/data/onboarding.ts`:**

    In `getOnboardingStatus()`, add `custom_service_names` to the select query on line 52:
    ```tsx
    .select('id, onboarding_completed_at, google_review_link, phone, software_used, service_types_enabled, custom_service_names, sms_consent_acknowledged')
    ```

    **6. Update `app/onboarding/page.tsx`:**

    In the `onboardingBusiness` mapping object, add:
    ```tsx
    custom_service_names: business.custom_service_names || null,
    ```

    **7. Update `lib/data/business.ts` — `getServiceTypeSettings`:**

    The function currently selects only `service_types_enabled, service_type_timing`. Add `custom_service_names` to the select and return value.

    Update the return type:
    ```tsx
    export async function getServiceTypeSettings(): Promise<{
      serviceTypesEnabled: string[]
      serviceTypeTiming: Record<string, number>
      customServiceNames: string[]
    } | null> {
    ```

    Update the select query on line 90:
    ```tsx
    .select('service_types_enabled, service_type_timing, custom_service_names')
    ```

    Update the return object (around line 96):
    ```tsx
    return {
      serviceTypesEnabled: business.service_types_enabled || [],
      serviceTypeTiming: business.service_type_timing || {
        hvac: 24, plumbing: 48, electrical: 24, cleaning: 4,
        roofing: 72, painting: 48, handyman: 24, other: 24
      },
      customServiceNames: business.custom_service_names || [],
    }
    ```
  </action>
  <verify>
    1. `pnpm typecheck` passes (Business interface has custom_service_names, OnboardingBusiness has it, servicesOfferedSchema accepts it)
    2. `pnpm lint` passes
    3. Migration applied successfully (check via mcp__supabase__list_migrations or mcp__supabase__execute_sql)
    4. `getServiceTypeSettings()` in `lib/data/business.ts` selects `custom_service_names` and returns `customServiceNames: string[]`
  </verify>
  <done>Database has custom_service_names column. All TypeScript types and validation schemas updated. Onboarding data query includes the new field.</done>
</task>

<task type="auto">
  <name>Task 2: Multi-tag custom service input in onboarding and settings</name>
  <files>
    components/onboarding/steps/business-setup-step.tsx
    components/settings/service-types-section.tsx
    components/settings/settings-tabs.tsx
    lib/actions/onboarding.ts
    lib/actions/business.ts
  </files>
  <action>
    **1. Update `lib/actions/onboarding.ts` — `saveServicesOffered`:**

    Update the function to accept and save custom service names:

    After extracting `serviceTypes` from parsed data, also extract `customServiceNames`:
    ```tsx
    const { serviceTypes, customServiceNames } = parsed.data
    ```

    In the `supabase.update()` call, add `custom_service_names`:
    ```tsx
    const { error } = await supabase
      .from('businesses')
      .update({
        service_types_enabled: serviceTypes,
        service_type_timing: timingMap,
        custom_service_names: customServiceNames || [],
      })
      .eq('id', business.id)
    ```

    **2. Update `lib/actions/business.ts` — `updateServiceTypeSettings`:**

    Expand the function signature to accept custom service names:
    ```tsx
    export async function updateServiceTypeSettings(settings: {
      serviceTypesEnabled: string[]
      serviceTypeTiming: Record<string, number>
      customServiceNames?: string[]  // <-- ADD
    }): Promise<{ error?: string; success?: boolean }> {
    ```

    Validate custom service names (sanitize, max 10, max 50 chars each):
    ```tsx
    const validatedCustomNames = (settings.customServiceNames || [])
      .map(n => n.trim())
      .filter(n => n.length > 0 && n.length <= 50)
      .slice(0, 10)
    ```

    Add to the update call:
    ```tsx
    const { error } = await supabase
      .from('businesses')
      .update({
        service_types_enabled: filteredEnabled,
        service_type_timing: finalTiming,
        custom_service_names: validatedCustomNames,
      })
      .eq('user_id', user.id)
    ```

    **3. Update `components/onboarding/steps/business-setup-step.tsx`:**

    Add import for TagBadge:
    ```tsx
    import { TagBadge } from '@/components/ui/tag-badge'
    ```

    Update props interface to accept default custom names:
    ```tsx
    interface BusinessSetupStepProps {
      onComplete: () => void
      defaultValues?: {
        name?: string
        phone?: string
        google_review_link?: string
      }
      defaultEnabled?: string[]
      defaultCustomServiceNames?: string[]  // <-- ADD
    }
    ```

    Replace single `customServiceLabel` state with multi-tag state:
    ```tsx
    const [customServiceNames, setCustomServiceNames] = useState<string[]>(
      defaultCustomServiceNames || []
    )
    const [customServiceInput, setCustomServiceInput] = useState('')
    ```

    Add tag management functions:
    ```tsx
    const addCustomService = () => {
      const trimmed = customServiceInput.trim()
      if (trimmed && !customServiceNames.includes(trimmed) && customServiceNames.length < 10) {
        setCustomServiceNames(prev => [...prev, trimmed])
        setCustomServiceInput('')
      }
    }

    const removeCustomService = (name: string) => {
      setCustomServiceNames(prev => prev.filter(n => n !== name))
    }
    ```

    Replace the "Other" custom service section (currently lines 186-197) with:
    ```tsx
    {selected.includes('other') && (
      <div className="space-y-2">
        <Label htmlFor="custom-service">What type of service?</Label>
        <div className="flex gap-2">
          <Input
            id="custom-service"
            value={customServiceInput}
            onChange={(e) => setCustomServiceInput(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === 'Enter') {
                e.preventDefault()
                addCustomService()
              }
            }}
            placeholder="e.g. Pest Control, Pool Cleaning..."
            disabled={isPending}
            maxLength={50}
          />
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={addCustomService}
            disabled={isPending || !customServiceInput.trim() || customServiceNames.length >= 10}
            className="shrink-0"
          >
            Add
          </Button>
        </div>
        {customServiceNames.length > 0 && (
          <div className="flex flex-wrap gap-1.5 pt-1">
            {customServiceNames.map((name) => (
              <TagBadge
                key={name}
                tag={name}
                onRemove={() => removeCustomService(name)}
              />
            ))}
          </div>
        )}
        {customServiceNames.length >= 10 && (
          <p className="text-xs text-muted-foreground">Maximum 10 custom services</p>
        )}
      </div>
    )}
    ```

    CRITICAL: The `onKeyDown` handler on the Input MUST call `e.preventDefault()` on Enter to prevent the parent form from submitting.

    Update the `handleSubmit` to pass custom service names:
    ```tsx
    const servicesResult = await saveServicesOffered({
      serviceTypes: selected as ServiceTypeValue[],
      customServiceNames: selected.includes('other') ? customServiceNames : [],
    })
    ```

    Update the `OnboardingSteps` component to pass `defaultCustomServiceNames` prop. In `onboarding-steps.tsx` case 1:
    ```tsx
    case 1:
      return (
        <BusinessSetupStep
          onComplete={onGoToNext}
          defaultValues={{
            name: business?.name || '',
            phone: business?.phone || '',
            google_review_link: business?.google_review_link || '',
          }}
          defaultEnabled={business?.service_types_enabled || []}
          defaultCustomServiceNames={business?.custom_service_names || []}
        />
      )
    ```

    **4. Update `components/settings/service-types-section.tsx`:**

    Add import for TagBadge and Input (Input already imported):
    ```tsx
    import { TagBadge } from '@/components/ui/tag-badge'
    ```

    Add props for custom service names:
    ```tsx
    interface ServiceTypesSectionProps {
      initialEnabled: string[]
      initialTiming: Record<string, number>
      initialCooldownDays?: number
      initialCustomServiceNames?: string[]  // <-- ADD
    }
    ```

    Add state for custom service names inside the component:
    ```tsx
    const [customServiceNames, setCustomServiceNames] = useState<string[]>(
      initialCustomServiceNames || []
    )
    const [customServiceInput, setCustomServiceInput] = useState('')
    ```

    Add tag management functions (same as onboarding):
    ```tsx
    const addCustomService = () => {
      const trimmed = customServiceInput.trim()
      if (trimmed && !customServiceNames.includes(trimmed) && customServiceNames.length < 10) {
        setCustomServiceNames(prev => [...prev, trimmed])
        setCustomServiceInput('')
        setHasChanges(true)
      }
    }

    const removeCustomService = (name: string) => {
      setCustomServiceNames(prev => prev.filter(n => n !== name))
      setHasChanges(true)
    }
    ```

    After the service type grid (after the `</div>` closing `grid gap-3 sm:grid-cols-2`), add a conditional section for when "other" is enabled:
    ```tsx
    {enabled.has('other') && (
      <div className="rounded-lg border p-4 space-y-3">
        <div>
          <h4 className="font-medium">Custom service names</h4>
          <p className="text-sm text-muted-foreground mt-1">
            Add names for your other services (up to 10).
          </p>
        </div>
        <div className="flex gap-2">
          <Input
            value={customServiceInput}
            onChange={(e) => setCustomServiceInput(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === 'Enter') {
                e.preventDefault()
                addCustomService()
              }
            }}
            placeholder="e.g. Pest Control, Pool Cleaning..."
            maxLength={50}
          />
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={addCustomService}
            disabled={!customServiceInput.trim() || customServiceNames.length >= 10}
            className="shrink-0"
          >
            Add
          </Button>
        </div>
        {customServiceNames.length > 0 && (
          <div className="flex flex-wrap gap-1.5">
            {customServiceNames.map((name) => (
              <TagBadge
                key={name}
                tag={name}
                onRemove={() => removeCustomService(name)}
              />
            ))}
          </div>
        )}
        {customServiceNames.length >= 10 && (
          <p className="text-xs text-muted-foreground">Maximum 10 custom services</p>
        )}
      </div>
    )}
    ```

    Update `handleSave` to pass custom service names:
    ```tsx
    const result = await updateServiceTypeSettings({
      serviceTypesEnabled: Array.from(enabled),
      serviceTypeTiming: timing,
      customServiceNames: enabled.has('other') ? customServiceNames : [],
    })
    ```

    Update `handleReset` to reset custom service names:
    ```tsx
    const handleReset = () => {
      setEnabled(new Set(initialEnabled))
      setTiming(initialTiming)
      setCustomServiceNames(initialCustomServiceNames || [])
      setCustomServiceInput('')
      setHasChanges(false)
    }
    ```

    **5. Thread `initialCustomServiceNames` to `ServiceTypesSection` via `components/settings/settings-tabs.tsx`:**

    The parent component is `components/settings/settings-tabs.tsx`. It renders `<ServiceTypesSection>` at line 92.

    Step 5a: Update the `SettingsTabsProps` interface (around line 15) to add `customServiceNames` to the `serviceTypeSettings` type:
    ```tsx
    serviceTypeSettings: {
      serviceTypesEnabled: string[]
      serviceTypeTiming: Record<string, number>
      customServiceNames: string[]
    } | null
    ```

    Step 5b: Add the `initialCustomServiceNames` prop to the `<ServiceTypesSection>` call at line 92:
    ```tsx
    <ServiceTypesSection
      initialEnabled={serviceTypeSettings?.serviceTypesEnabled || []}
      initialTiming={serviceTypeSettings?.serviceTypeTiming || {
        hvac: 24, plumbing: 48, electrical: 24, cleaning: 4,
        roofing: 72, painting: 48, handyman: 24, other: 24
      }}
      initialCooldownDays={business?.review_cooldown_days ?? 30}
      initialCustomServiceNames={serviceTypeSettings?.customServiceNames || []}
    />
    ```

    This works because `getServiceTypeSettings()` (updated in Task 1 step 7) now returns `customServiceNames` in its result, and the settings page passes it through as `serviceTypeSettings`.
  </action>
  <verify>
    1. `pnpm typecheck` passes
    2. `pnpm lint` passes
    3. In business-setup-step.tsx: TagBadge is imported and used
    4. In business-setup-step.tsx: Input onKeyDown prevents Enter from submitting form
    5. In service-types-section.tsx: TagBadge is imported and used when "other" is enabled
    6. In service-types-section.tsx: Input onKeyDown prevents Enter
    7. saveServicesOffered accepts and saves customServiceNames
    8. updateServiceTypeSettings accepts and saves customServiceNames
    9. In settings-tabs.tsx: `SettingsTabsProps.serviceTypeSettings` type includes `customServiceNames: string[]`
    10. In settings-tabs.tsx: `<ServiceTypesSection>` receives `initialCustomServiceNames={serviceTypeSettings?.customServiceNames || []}`
    11. Full data path verified: `getServiceTypeSettings()` fetches `custom_service_names` -> `settings-tabs.tsx` passes it -> `ServiceTypesSection` receives it as `initialCustomServiceNames`
  </verify>
  <done>Both onboarding and settings show a multi-tag input for custom service names when "Other" is selected. Tags can be added via Enter key or Add button, removed via X button. Custom names are saved to custom_service_names column and loaded on page/step render.</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` — all TypeScript types resolve
2. `pnpm lint` — no lint errors
3. Database has `custom_service_names` column on businesses table
4. Business interface has `custom_service_names: string[]`
5. OnboardingBusiness type has `custom_service_names: string[] | null`
6. Onboarding step 1: selecting "Other" shows multi-tag input, tags persist after save
7. Settings services section: enabling "Other" shows multi-tag input, tags persist after save
8. Enter key in custom service input does NOT submit parent form
9. Maximum 10 custom services enforced in UI and server actions
10. `getServiceTypeSettings()` in `lib/data/business.ts` selects and returns `customServiceNames`
11. `settings-tabs.tsx` threads `customServiceNames` from `serviceTypeSettings` to `ServiceTypesSection` as `initialCustomServiceNames`
</verification>

<success_criteria>
- Selecting "Other" in onboarding services reveals a tag-style multi-input
- Users can add up to 10 custom service names as tags
- Tags show with X remove buttons
- Enter key adds a tag (does not submit form)
- Custom names save to database and reload correctly
- Settings services section has matching tag-style input for "Other"
- `pnpm typecheck` and `pnpm lint` both pass clean
</success_criteria>

<output>
After completion, create `.planning/phases/44-onboarding-services/44-02-SUMMARY.md`
</output>
