---
phase: 06-billing-limits
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - app/api/webhooks/stripe/route.ts
autonomous: true

must_haves:
  truths:
    - "Webhook receives and validates Stripe events with signature verification"
    - "checkout.session.completed creates subscription record and updates tier"
    - "customer.subscription.updated syncs subscription status changes"
    - "customer.subscription.deleted reverts business to trial tier"
  artifacts:
    - path: "app/api/webhooks/stripe/route.ts"
      provides: "Stripe webhook handler"
      exports: ["POST"]
  key_links:
    - from: "app/api/webhooks/stripe/route.ts"
      to: "lib/stripe/client.ts"
      via: "import stripe"
      pattern: "import.*stripe.*from.*@/lib/stripe/client"
    - from: "app/api/webhooks/stripe/route.ts"
      to: "STRIPE_WEBHOOK_SECRET"
      via: "environment variable"
      pattern: "process\\.env\\.STRIPE_WEBHOOK_SECRET"
    - from: "app/api/webhooks/stripe/route.ts"
      to: "supabase (service role)"
      via: "direct Supabase client"
      pattern: "createClient.*SUPABASE_SERVICE_ROLE_KEY"
---

<objective>
Create Stripe webhook handler for subscription lifecycle events.

Purpose: Sync Stripe subscription status with database. Update tier on subscribe, handle payment failures, revert on cancel.
Output: Webhook endpoint that handles all subscription lifecycle events.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-billing-limits/06-RESEARCH.md
@.planning/phases/06-billing-limits/06-CONTEXT.md

# Existing webhook pattern
@app/api/webhooks/resend/route.ts

# From Plan 01
@lib/stripe/client.ts
@lib/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Stripe webhook route handler</name>
  <files>app/api/webhooks/stripe/route.ts</files>
  <action>
    Create app/api/webhooks/stripe/route.ts:

    ```typescript
    import { headers } from 'next/headers'
    import { NextResponse } from 'next/server'
    import { stripe } from '@/lib/stripe/client'
    import { createClient } from '@supabase/supabase-js'
    import type Stripe from 'stripe'

    // Use service role for webhook (no user context)
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    )

    // Map price IDs to tiers
    const PRICE_TO_TIER: Record<string, 'basic' | 'pro'> = {
      [process.env.STRIPE_BASIC_PRICE_ID!]: 'basic',
      [process.env.STRIPE_PRO_PRICE_ID!]: 'pro',
    }

    export async function POST(request: Request) {
      // CRITICAL: Use text(), not json() for signature verification
      const body = await request.text()
      const headersList = await headers()
      const signature = headersList.get('stripe-signature')

      if (!signature) {
        return NextResponse.json({ error: 'Missing signature' }, { status: 400 })
      }

      let event: Stripe.Event
      try {
        event = stripe.webhooks.constructEvent(
          body,
          signature,
          process.env.STRIPE_WEBHOOK_SECRET!
        )
      } catch (err) {
        console.error('Webhook signature verification failed:', err)
        return NextResponse.json({ error: 'Invalid signature' }, { status: 400 })
      }

      // Handle events
      try {
        switch (event.type) {
          case 'checkout.session.completed':
            await handleCheckoutCompleted(event.data.object as Stripe.Checkout.Session)
            break

          case 'customer.subscription.updated':
            await handleSubscriptionUpdated(event.data.object as Stripe.Subscription)
            break

          case 'customer.subscription.deleted':
            await handleSubscriptionDeleted(event.data.object as Stripe.Subscription)
            break

          case 'invoice.payment_failed':
            // Log but don't immediately revoke access
            // Stripe will update subscription status to past_due
            const invoice = event.data.object as Stripe.Invoice
            console.log(`Payment failed for invoice ${invoice.id}`)
            break

          default:
            console.log(`Unhandled event type: ${event.type}`)
        }
      } catch (err) {
        console.error(`Error handling ${event.type}:`, err)
        // Still return 200 to prevent retry storms
      }

      // Always return 200 to acknowledge receipt
      return NextResponse.json({ received: true })
    }
    ```

    CRITICAL:
    - Use request.text() not request.json() before signature verification
    - Always return 200 even on handler errors (prevent retry storms)
    - Use service role Supabase client (no user context in webhooks)
  </action>
  <verify>`pnpm typecheck` passes</verify>
  <done>Webhook endpoint with signature verification</done>
</task>

<task type="auto">
  <name>Task 2: Implement subscription event handlers</name>
  <files>app/api/webhooks/stripe/route.ts</files>
  <action>
    Add handler functions to route.ts:

    ```typescript
    async function handleCheckoutCompleted(session: Stripe.Checkout.Session) {
      if (!session.subscription) return

      // Get business_id from session metadata
      const businessId = session.metadata?.business_id
        || (session.subscription_data as unknown as { metadata?: { business_id?: string } })?.metadata?.business_id

      if (!businessId) {
        console.error('No business_id in checkout session metadata')
        return
      }

      // Fetch full subscription details
      const subscription = await stripe.subscriptions.retrieve(session.subscription as string)
      const priceId = subscription.items.data[0].price.id
      const tier = PRICE_TO_TIER[priceId] || 'basic'

      // Update business tier
      await supabase
        .from('businesses')
        .update({ tier })
        .eq('id', businessId)

      // Create/update subscription record
      await supabase
        .from('subscriptions')
        .upsert({
          id: subscription.id,
          business_id: businessId,
          status: subscription.status,
          price_id: priceId,
          current_period_start: new Date(subscription.current_period_start * 1000).toISOString(),
          current_period_end: new Date(subscription.current_period_end * 1000).toISOString(),
          cancel_at_period_end: subscription.cancel_at_period_end,
        })

      console.log(`Subscription ${subscription.id} created for business ${businessId}, tier: ${tier}`)
    }

    async function handleSubscriptionUpdated(subscription: Stripe.Subscription) {
      const businessId = subscription.metadata.business_id
      if (!businessId) {
        console.error('No business_id in subscription metadata')
        return
      }

      const priceId = subscription.items.data[0].price.id
      const tier = PRICE_TO_TIER[priceId] || 'basic'

      // Update subscription record
      await supabase
        .from('subscriptions')
        .update({
          status: subscription.status,
          price_id: priceId,
          current_period_end: new Date(subscription.current_period_end * 1000).toISOString(),
          cancel_at_period_end: subscription.cancel_at_period_end,
        })
        .eq('id', subscription.id)

      // Update tier only if subscription is active-ish
      // Per CONTEXT.md: 7-day grace period for past_due
      if (['active', 'trialing', 'past_due'].includes(subscription.status)) {
        await supabase
          .from('businesses')
          .update({ tier })
          .eq('id', businessId)
      }

      console.log(`Subscription ${subscription.id} updated: ${subscription.status}`)
    }

    async function handleSubscriptionDeleted(subscription: Stripe.Subscription) {
      const businessId = subscription.metadata.business_id
      if (!businessId) {
        console.error('No business_id in subscription metadata')
        return
      }

      // Mark subscription as canceled
      await supabase
        .from('subscriptions')
        .update({
          status: 'canceled',
          canceled_at: new Date().toISOString(),
        })
        .eq('id', subscription.id)

      // Revert business to trial tier
      // Per CONTEXT.md: Access continues until end of billing period
      // The subscription already ended, so revert now
      await supabase
        .from('businesses')
        .update({ tier: 'trial' })
        .eq('id', businessId)

      console.log(`Subscription ${subscription.id} deleted, business ${businessId} reverted to trial`)
    }
    ```

    NOTE: business_id comes from subscription.metadata (set during checkout).
    The subscription_data.metadata in checkout becomes subscription.metadata.
  </action>
  <verify>`pnpm typecheck` passes</verify>
  <done>Subscription lifecycle events update database correctly</done>
</task>

</tasks>

<verification>
- [ ] `pnpm typecheck` passes
- [ ] app/api/webhooks/stripe/route.ts exists
- [ ] Webhook uses request.text() for raw body
- [ ] Webhook verifies signature with stripe.webhooks.constructEvent
- [ ] checkout.session.completed updates tier and creates subscription record
- [ ] customer.subscription.updated syncs status changes
- [ ] customer.subscription.deleted reverts to trial tier
- [ ] Webhook always returns 200 (even on handler errors)
</verification>

<success_criteria>
- Stripe webhooks validated with signature verification
- New subscriptions create database record and update tier
- Subscription updates (upgrades, downgrades, payment issues) sync to database
- Cancellations revert business to trial tier
- No 5xx errors that would cause Stripe retry storms
</success_criteria>

<output>
After completion, create `.planning/phases/06-billing-limits/06-03-SUMMARY.md`
</output>
