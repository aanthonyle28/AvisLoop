---
phase: 06-billing-limits
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - lib/actions/billing.ts
  - lib/data/subscription.ts
autonomous: true

must_haves:
  truths:
    - "User can initiate Stripe checkout for Basic or Pro plan"
    - "User can access Stripe Customer Portal for subscription management"
    - "Checkout creates Stripe customer if none exists"
  artifacts:
    - path: "lib/actions/billing.ts"
      provides: "Checkout and portal server actions"
      exports: ["createCheckoutSession", "createPortalSession"]
    - path: "lib/data/subscription.ts"
      provides: "Subscription data fetching"
      exports: ["getSubscription", "getBusinessBillingInfo"]
  key_links:
    - from: "lib/actions/billing.ts"
      to: "lib/stripe/client.ts"
      via: "import stripe"
      pattern: "import.*stripe.*from.*@/lib/stripe/client"
    - from: "lib/actions/billing.ts"
      to: "STRIPE_BASIC_PRICE_ID"
      via: "environment variable"
      pattern: "process\\.env\\.STRIPE_(BASIC|PRO)_PRICE_ID"
---

<objective>
Create server actions for Stripe checkout and customer portal sessions.

Purpose: Enable users to subscribe to plans and manage their subscriptions via Stripe-hosted pages.
Output: Server actions that redirect users to Stripe Checkout and Customer Portal.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-billing-limits/06-RESEARCH.md
@.planning/phases/06-billing-limits/06-CONTEXT.md

# From Plan 01
@lib/stripe/client.ts
@lib/types/database.ts

# Existing usage function to reuse
@lib/data/send-logs.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create subscription data fetching functions</name>
  <files>lib/data/subscription.ts</files>
  <action>
    Create lib/data/subscription.ts with:

    1. getSubscription() - Fetch active subscription for current user's business:
       ```typescript
       export async function getSubscription(): Promise<Subscription | null>
       ```
       - Create Supabase client, get user, get business
       - Query subscriptions table for business_id
       - Return most recent subscription (order by created_at DESC, limit 1)
       - Return null if no subscription found

    2. getBusinessBillingInfo() - Get combined billing info:
       ```typescript
       import { getMonthlyUsage } from '@/lib/data/send-logs'

       export async function getBusinessBillingInfo(): Promise<{
         business: { id: string; tier: string; stripe_customer_id: string | null } | null
         subscription: Subscription | null
         usage: { count: number; limit: number }
       }>
       ```
       - Fetch business with tier and stripe_customer_id
       - Fetch subscription
       - Fetch monthly usage by calling `getMonthlyUsage()` from '@/lib/data/send-logs'
       - Return combined object for billing page

    IMPORTANT: Import getMonthlyUsage explicitly:
    ```typescript
    import { getMonthlyUsage } from '@/lib/data/send-logs'
    ```

    Pattern: Follow existing lib/data/send-logs.ts structure.
  </action>
  <verify>`pnpm typecheck` passes</verify>
  <done>Subscription data functions available for billing page</done>
</task>

<task type="auto">
  <name>Task 2: Create checkout session server action</name>
  <files>lib/actions/billing.ts</files>
  <action>
    Create lib/actions/billing.ts with createCheckoutSession:

    ```typescript
    'use server'

    import { stripe } from '@/lib/stripe/client'
    import { createClient } from '@/lib/supabase/server'
    import { redirect } from 'next/navigation'

    export async function createCheckoutSession(priceId: string): Promise<never> {
      const supabase = await createClient()
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) throw new Error('Not authenticated')

      // Get business, create Stripe customer if needed
      const { data: business } = await supabase
        .from('businesses')
        .select('id, stripe_customer_id')
        .eq('user_id', user.id)
        .single()

      if (!business) throw new Error('No business found')

      let customerId = business.stripe_customer_id
      if (!customerId) {
        const customer = await stripe.customers.create({
          email: user.email,
          metadata: {
            business_id: business.id,
            user_id: user.id,
          }
        })
        customerId = customer.id

        // Save customer ID (race condition handled by UNIQUE constraint)
        await supabase
          .from('businesses')
          .update({ stripe_customer_id: customerId })
          .eq('id', business.id)
      }

      const session = await stripe.checkout.sessions.create({
        customer: customerId,
        mode: 'subscription',
        line_items: [{ price: priceId, quantity: 1 }],
        success_url: `${process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000'}/billing?success=1`,
        cancel_url: `${process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000'}/billing?canceled=1`,
        subscription_data: {
          metadata: { business_id: business.id }
        }
      })

      redirect(session.url!)
    }
    ```

    IMPORTANT:
    - Include business_id in subscription_data.metadata for webhook correlation
    - Use NEXT_PUBLIC_SITE_URL for redirects (fallback to localhost for dev)
    - redirect() returns never (always redirects)
  </action>
  <verify>`pnpm typecheck` passes</verify>
  <done>Users can initiate Stripe checkout via server action</done>
</task>

<task type="auto">
  <name>Task 3: Create portal session server action</name>
  <files>lib/actions/billing.ts</files>
  <action>
    Add createPortalSession to lib/actions/billing.ts:

    ```typescript
    export async function createPortalSession(): Promise<never> {
      const supabase = await createClient()
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) throw new Error('Not authenticated')

      const { data: business } = await supabase
        .from('businesses')
        .select('stripe_customer_id')
        .eq('user_id', user.id)
        .single()

      if (!business?.stripe_customer_id) {
        throw new Error('No billing account found. Please subscribe first.')
      }

      const session = await stripe.billingPortal.sessions.create({
        customer: business.stripe_customer_id,
        return_url: `${process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000'}/billing`
      })

      redirect(session.url)
    }
    ```

    NOTE: Portal requires stripe_customer_id to exist. If user has never subscribed, show error or different UI.
  </action>
  <verify>`pnpm typecheck` passes</verify>
  <done>Users can access Stripe Customer Portal for subscription management</done>
</task>

</tasks>

<verification>
- [ ] `pnpm typecheck` passes
- [ ] lib/data/subscription.ts exports getSubscription, getBusinessBillingInfo
- [ ] lib/data/subscription.ts imports getMonthlyUsage from '@/lib/data/send-logs'
- [ ] lib/actions/billing.ts exports createCheckoutSession, createPortalSession
- [ ] createCheckoutSession creates Stripe customer if needed
- [ ] createCheckoutSession includes business_id in subscription metadata
- [ ] createPortalSession requires existing stripe_customer_id
</verification>

<success_criteria>
- createCheckoutSession redirects to Stripe Checkout with correct price
- createPortalSession redirects to Stripe Customer Portal
- Stripe customer created on first checkout attempt
- business_id stored in subscription metadata for webhook correlation
</success_criteria>

<output>
After completion, create `.planning/phases/06-billing-limits/06-02-SUMMARY.md`
</output>
