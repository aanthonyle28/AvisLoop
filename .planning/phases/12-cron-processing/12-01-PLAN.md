---
phase: 12-cron-processing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/api/cron/process-scheduled-sends/route.ts
  - vercel.json
autonomous: true

must_haves:
  truths:
    - "Cron endpoint fetches due scheduled sends (scheduled_for <= now, status = pending) and sends emails"
    - "System re-validates opt-out, cooldown, quota, and archived status at send time"
    - "Service role client bypasses RLS so cron operates without user session"
    - "Each cron run returns structured JSON with processed/sent/failed/skipped counts"
    - "Concurrent cron invocations cannot double-process the same scheduled send (FOR UPDATE SKIP LOCKED)"
  artifacts:
    - path: "app/api/cron/process-scheduled-sends/route.ts"
      provides: "GET handler for cron processing"
      exports: ["GET"]
    - path: "vercel.json"
      provides: "Vercel cron schedule configuration"
      contains: "crons"
  key_links:
    - from: "app/api/cron/process-scheduled-sends/route.ts"
      to: "lib/supabase/service-role.ts"
      via: "createServiceRoleClient import"
      pattern: "createServiceRoleClient"
    - from: "app/api/cron/process-scheduled-sends/route.ts"
      to: "lib/email/resend.ts"
      via: "resend.emails.send"
      pattern: "resend\\.emails\\.send"
    - from: "app/api/cron/process-scheduled-sends/route.ts"
      to: "lib/email/templates/review-request.tsx"
      via: "ReviewRequestEmail render"
      pattern: "ReviewRequestEmail"
    - from: "app/api/cron/process-scheduled-sends/route.ts"
      to: "lib/constants/billing.ts"
      via: "COOLDOWN_DAYS, MONTHLY_SEND_LIMITS imports"
      pattern: "COOLDOWN_DAYS|MONTHLY_SEND_LIMITS"
---

<objective>
Create the cron route handler that processes scheduled sends in the background every minute.

Purpose: This is the backend engine for scheduled sending. Without it, scheduled sends sit in the database forever. The cron claims due sends atomically, re-validates all business rules at send time, sends emails via Resend, updates scheduled_send records, and returns structured JSON logs.

Output: Working cron endpoint at /api/cron/process-scheduled-sends + vercel.json cron config
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key source files to reference (read these before implementing):
@lib/actions/send.ts (validation logic to replicate: cooldown, opt-out, archived, quota checks)
@lib/supabase/service-role.ts (service role client to import)
@lib/email/resend.ts (resend client + RESEND_FROM_EMAIL)
@lib/email/templates/review-request.tsx (ReviewRequestEmail component)
@lib/types/database.ts (ScheduledSend type)
@lib/constants/billing.ts (COOLDOWN_DAYS, MONTHLY_SEND_LIMITS)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cron route handler with atomic claim, validation, and send logic</name>
  <files>app/api/cron/process-scheduled-sends/route.ts</files>
  <action>
Create a Next.js Route Handler (GET) at `app/api/cron/process-scheduled-sends/route.ts`.

**Authentication:**
- Read `CRON_SECRET` from `process.env`
- Compare against `Authorization: Bearer <token>` header
- If missing or mismatch, return 401 JSON `{ error: "Unauthorized" }`
- If `CRON_SECRET` env var is not set, log a warning and return 500

**Claim due sends (atomic, race-safe):**
- Use `createServiceRoleClient()` from `@/lib/supabase/service-role`
- Execute a raw SQL query (via `.rpc()` or raw SQL) to atomically claim pending sends:
  ```sql
  UPDATE scheduled_sends
  SET status = 'processing'
  WHERE id IN (
    SELECT id FROM scheduled_sends
    WHERE status = 'pending'
      AND scheduled_for <= now()
    ORDER BY scheduled_for ASC
    LIMIT 50
    FOR UPDATE SKIP LOCKED
  )
  RETURNING *
  ```
- IMPORTANT: The service role client uses `@supabase/supabase-js` (not `@supabase/ssr`), so use `supabase.rpc('claim_scheduled_sends')` if an RPC exists, OR use the Supabase client's `.from('scheduled_sends')` approach in two steps:
  1. First, fetch pending sends: `.from('scheduled_sends').select('*').eq('status', 'pending').lte('scheduled_for', new Date().toISOString()).order('scheduled_for', { ascending: true }).limit(50)`
  2. Then update each to 'processing' status before processing

  However, the two-step approach has a race condition. The PREFERRED approach is to create a Postgres function `claim_due_scheduled_sends()` that runs the atomic UPDATE...RETURNING query above, and call it via `supabase.rpc('claim_due_scheduled_sends')`. But since we may not have migration access at runtime, use the pragmatic alternative:

  Use the Supabase client two-step approach but immediately update status to 'processing' for each claimed row before doing any work. This is acceptable because Vercel Cron runs at most once per minute and the window for races is very small. Document this as a known tradeoff with a TODO comment suggesting the RPC approach for production hardening.

**Process each claimed scheduled send:**
For each claimed `ScheduledSend`:

1. **Fetch business data** using service role client:
   ```
   .from('businesses').select('id, name, google_review_link, default_sender_name, tier').eq('id', scheduledSend.business_id).single()
   ```
   If business not found or missing google_review_link, mark as 'failed' with error message.

2. **Check monthly quota** (reuse logic from send.ts):
   - Get monthly send count: query `send_logs` where `business_id` matches, `created_at >= start of current month`, status in `['sent', 'delivered', 'opened']`, count exact.
   - Compare against `MONTHLY_SEND_LIMITS[business.tier]`
   - If quota exceeded, mark scheduled_send as 'failed' with quota error.

3. **Fetch all contacts** in one query:
   ```
   .from('contacts').select('id, name, email, status, opted_out, last_sent_at, send_count').in('id', scheduledSend.contact_ids).eq('business_id', scheduledSend.business_id)
   ```

4. **Re-validate each contact** (mirrors batchSendReviewRequest logic):
   - Skip if `status === 'archived'` (reason: 'archived')
   - Skip if `opted_out === true` (reason: 'opted_out')
   - Skip if cooldown active: `last_sent_at` exists and `new Date(last_sent_at) > new Date(Date.now() - COOLDOWN_DAYS * 24 * 60 * 60 * 1000)` (reason: 'cooldown')
   - Skip if contact not found in query results (reason: 'not_found')
   - Collect eligible contacts and skipped contacts with reasons

5. **Fetch template** if `scheduledSend.template_id` is set:
   ```
   .from('email_templates').select('name, subject, body').eq('id', scheduledSend.template_id).eq('business_id', scheduledSend.business_id).single()
   ```

6. **Send emails to eligible contacts** (mirrors batchSendReviewRequest loop):
   - Determine subject: `scheduledSend.custom_subject || template?.subject || "${business.name} would love your feedback!"`
   - Determine senderName: `business.default_sender_name || business.name`
   - For each eligible contact:
     a. Create send_log with status 'pending' via service role client
     b. Render `ReviewRequestEmail` with `{ customerName, businessName, reviewLink, senderName }`
     c. Send via `resend.emails.send()` with from, to, subject, html, tags (send_log_id, business_id), idempotencyKey
     d. Update send_log status to 'sent' or 'failed'
     e. If sent, update contact `last_sent_at` and `send_count`
     f. Track result (sent/failed) and collect send_log_ids

7. **Update scheduled_send record:**
   - If all contacts were processed (even if some skipped/failed):
     - status: any sent > 0 ? 'completed' : 'failed'
     - executed_at: new Date().toISOString()
     - send_log_ids: array of created send log IDs (or null if none)
     - error_message: if all failed, concatenate reasons; if partial, note "X sent, Y skipped, Z failed"

**Return structured JSON response (always 200):**
```json
{
  "ok": true,
  "timestamp": "2026-01-29T...",
  "claimed": 5,
  "results": {
    "processed": 5,
    "sent": 12,
    "failed": 1,
    "skipped": 3
  }
}
```
Return 200 even for partial failures (Vercel Cron expects 200 for success). Only return non-200 for auth failures or catastrophic errors.

**Error handling:**
- Wrap the entire handler in try/catch
- If the outer try/catch fires, return 500 with `{ ok: false, error: message }`
- Each individual scheduled send should be wrapped in its own try/catch so one failure does not block others
- If a scheduled send fails catastrophically, update its status to 'failed' with the error message

**Imports needed:**
- `createServiceRoleClient` from `@/lib/supabase/service-role`
- `resend, RESEND_FROM_EMAIL` from `@/lib/email/resend`
- `ReviewRequestEmail` from `@/lib/email/templates/review-request`
- `render` from `@react-email/render`
- `COOLDOWN_DAYS, MONTHLY_SEND_LIMITS` from `@/lib/constants/billing`
- `NextResponse` from `next/server` (for type, but use `Response` or `NextResponse.json()`)
- Do NOT use `'use server'` directive (this is a Route Handler, not a Server Action)
- Do NOT import `createClient` from `@/lib/supabase/server` (that's the SSR client with user sessions)

**Export:** `export const dynamic = 'force-dynamic'` to prevent caching.
  </action>
  <verify>
Run `pnpm typecheck` to confirm no type errors. Manually verify the file exists and has the correct structure by reading it back.
  </verify>
  <done>
Route handler exists at app/api/cron/process-scheduled-sends/route.ts. It exports GET and dynamic. It uses createServiceRoleClient (not createClient). It validates CRON_SECRET. It claims pending scheduled sends, re-validates each contact (cooldown, opt-out, archived, quota), sends via Resend, updates scheduled_send and send_log records, and returns structured JSON with counts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create vercel.json with cron schedule configuration</name>
  <files>vercel.json</files>
  <action>
Create `vercel.json` at project root with cron configuration:

```json
{
  "crons": [
    {
      "path": "/api/cron/process-scheduled-sends",
      "schedule": "* * * * *"
    }
  ]
}
```

This runs the cron every minute. Vercel automatically adds the `Authorization: Bearer <CRON_SECRET>` header when invoking cron jobs.

Note: `CRON_SECRET` must be set as an environment variable in Vercel project settings. Vercel auto-generates this if not set, but it must match what the route handler checks.
  </action>
  <verify>
Verify the file is valid JSON: `node -e "require('./vercel.json')"` (or `node -e "JSON.parse(require('fs').readFileSync('vercel.json','utf8'))"`) should not throw.
  </verify>
  <done>
vercel.json exists at project root with crons array containing the process-scheduled-sends path with "* * * * *" schedule.
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes with no errors
2. `pnpm lint` passes
3. `app/api/cron/process-scheduled-sends/route.ts` exports GET function and `dynamic = 'force-dynamic'`
4. Route handler imports `createServiceRoleClient` (NOT `createClient` from server)
5. Route handler validates CRON_SECRET from Authorization header
6. Route handler re-validates contacts (cooldown, opt-out, archived status, quota)
7. Route handler uses `resend.emails.send()` with ReviewRequestEmail template
8. Route handler updates scheduled_send status to 'completed' or 'failed' with executed_at
9. Route handler returns 200 with structured JSON counts
10. `vercel.json` is valid JSON with crons array
</verification>

<success_criteria>
- Cron endpoint at /api/cron/process-scheduled-sends handles GET requests
- CRON_SECRET authentication prevents unauthorized access
- Due scheduled sends (pending + scheduled_for <= now) are claimed and processed
- Each contact is re-validated at send time (not trusting schedule-time validation)
- Emails are sent via existing Resend infrastructure with ReviewRequestEmail template
- scheduled_sends records are updated with final status, executed_at, send_log_ids
- Structured JSON response includes processed/sent/failed/skipped counts
- vercel.json configures every-minute cron schedule
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-cron-processing/12-01-SUMMARY.md`
</output>
