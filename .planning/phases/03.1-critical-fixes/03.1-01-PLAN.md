---
phase: 03.1-critical-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/actions/contact.ts
  - supabase/migrations/00004_add_business_unique_constraint.sql
autonomous: true

must_haves:
  truths:
    - "searchContacts properly escapes special SQL characters (%, _, \\) in query parameter"
    - "getContacts returns paginated results with limit and offset support"
    - "Bulk operations reject arrays larger than 100 items with clear error message"
    - "Database enforces one business per user via unique constraint"
  artifacts:
    - path: "lib/actions/contact.ts"
      provides: "Fixed contact actions with SQL injection fix, pagination, and bulk limits"
      contains: "escapeLikePattern"
    - path: "supabase/migrations/00004_add_business_unique_constraint.sql"
      provides: "Migration adding UNIQUE constraint on businesses.user_id"
      contains: "ADD CONSTRAINT"
  key_links:
    - from: "lib/actions/contact.ts"
      to: "searchContacts"
      via: "escapeLikePattern function"
      pattern: "escapeLikePattern\\(query\\)"
    - from: "lib/actions/contact.ts"
      to: "getContacts"
      via: "pagination parameters"
      pattern: "\\.range\\("
---

<objective>
Fix critical security vulnerabilities and medium-priority issues in contact management before continuing to Phase 4.

Purpose: Address security vulnerabilities (SQL injection) and scalability issues (no pagination, unlimited bulk ops) identified in code review. These must be fixed before adding more functionality.

Output: Hardened contact.ts with SQL injection fix, pagination support, bulk operation limits, and database constraint migration.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@lib/actions/contact.ts
@supabase/migrations/00002_create_business.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix SQL injection and add bulk operation limits</name>
  <files>lib/actions/contact.ts</files>
  <action>
1. Add an `escapeLikePattern` helper function at the top of the file (after imports):
   ```typescript
   /**
    * Escape special characters for LIKE/ILIKE patterns.
    * Prevents SQL injection via pattern characters.
    */
   function escapeLikePattern(str: string): string {
     return str
       .replace(/\\/g, '\\\\')  // Escape backslash first
       .replace(/%/g, '\\%')    // Escape percent
       .replace(/_/g, '\\_')    // Escape underscore
   }
   ```

2. Update `searchContacts` function (around line 496) to escape the query:
   - Change: `queryBuilder = queryBuilder.or(\`name.ilike.%${query}%,email.ilike.%${query}%\`)`
   - To: `const escapedQuery = escapeLikePattern(query)`
         `queryBuilder = queryBuilder.or(\`name.ilike.%${escapedQuery}%,email.ilike.%${escapedQuery}%\`)`

3. Add size limit validation to `bulkArchiveContacts` (after the empty array check):
   ```typescript
   if (contactIds.length > 100) {
     return { error: 'Cannot archive more than 100 contacts at once' }
   }
   ```

4. Add size limit validation to `bulkDeleteContacts` (after the empty array check):
   ```typescript
   if (contactIds.length > 100) {
     return { error: 'Cannot delete more than 100 contacts at once' }
   }
   ```

5. Add size limit validation to `bulkCreateContacts` (after the empty array check):
   ```typescript
   if (contacts.length > 100) {
     return { error: 'Cannot import more than 100 contacts at once' }
   }
   ```
  </action>
  <verify>
Run `pnpm typecheck` - no TypeScript errors.
Verify escapeLikePattern function exists by grepping: `grep "escapeLikePattern" lib/actions/contact.ts`
Verify bulk limits exist: `grep -n "more than 100" lib/actions/contact.ts` should show 3 matches.
  </verify>
  <done>
- searchContacts escapes special characters before interpolation
- All three bulk operations (archive, delete, create) reject arrays > 100 items
- No TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add pagination to getContacts</name>
  <files>lib/actions/contact.ts</files>
  <action>
1. Update the `getContacts` function signature to accept pagination options:
   ```typescript
   export async function getContacts(options?: {
     limit?: number
     offset?: number
   }): Promise<{ contacts: Contact[]; total: number }> {
   ```

2. Add default pagination values inside the function:
   ```typescript
   const limit = options?.limit ?? 50
   const offset = options?.offset ?? 0
   ```

3. After building the query, add count query and pagination:
   ```typescript
   // Get total count first
   const { count } = await supabase
     .from('contacts')
     .select('*', { count: 'exact', head: true })
     .eq('business_id', business.id)

   // Fetch paginated contacts
   const { data: contacts } = await supabase
     .from('contacts')
     .select('*')
     .eq('business_id', business.id)
     .order('last_sent_at', { ascending: false, nullsFirst: false })
     .order('created_at', { ascending: false })
     .range(offset, offset + limit - 1)

   return { contacts: contacts || [], total: count || 0 }
   ```

4. Update the early return cases to match new signature:
   - Change `return []` to `return { contacts: [], total: 0 }`

NOTE: The searchContacts function does NOT need pagination added in this phase. It's client-side filtered and can be addressed later if needed. Focus on getContacts which is the main data fetching function.
  </action>
  <verify>
Run `pnpm typecheck` - no TypeScript errors.
Verify function signature: `grep "getContacts" lib/actions/contact.ts | head -5`
Verify range usage: `grep -n "\.range(" lib/actions/contact.ts`
  </verify>
  <done>
- getContacts accepts optional { limit, offset } parameter
- Returns { contacts: Contact[], total: number } instead of Contact[]
- Default limit is 50, default offset is 0
- Uses .range() for pagination
  </done>
</task>

<task type="auto">
  <name>Task 3: Create migration for business unique constraint</name>
  <files>supabase/migrations/00004_add_business_unique_constraint.sql</files>
  <action>
Create a new migration file `supabase/migrations/00004_add_business_unique_constraint.sql`:

```sql
-- Migration: 00004_add_business_unique_constraint
-- Purpose: Enforce one business per user at the database level
--
-- Background: The application logic already enforces one business per user,
-- but there was no database constraint preventing race conditions or bypasses.
-- This constraint ensures data integrity at the DB level.

-- ============================================================================
-- Add unique constraint on user_id
-- ============================================================================
-- This ensures each auth.users can only have one business record.
-- If a user somehow has multiple businesses, this migration will fail.
-- In that case, clean up duplicate businesses first.

ALTER TABLE public.businesses
ADD CONSTRAINT businesses_user_id_unique UNIQUE (user_id);

-- Note: The existing index idx_businesses_user_id (btree) will be replaced
-- by the unique constraint's implicit index. PostgreSQL handles this efficiently.
```
  </action>
  <verify>
Verify file exists: `ls supabase/migrations/00004*.sql`
Verify constraint syntax: `grep "UNIQUE" supabase/migrations/00004*.sql`
  </verify>
  <done>
- Migration file 00004_add_business_unique_constraint.sql exists
- Contains ALTER TABLE with UNIQUE constraint on user_id
- Includes comment explaining purpose and potential failure case
  </done>
</task>

</tasks>

<verification>
1. Run `pnpm typecheck` - should pass with no errors
2. Run `pnpm lint` - should pass
3. Verify SQL injection fix:
   - Search for `escapeLikePattern` in contact.ts
   - Verify it's called in searchContacts before interpolation
4. Verify pagination:
   - getContacts returns object with contacts and total properties
   - Uses .range() method
5. Verify bulk limits:
   - All three bulk functions have 100-item limit
6. Verify migration:
   - File 00004 exists with UNIQUE constraint
</verification>

<success_criteria>
1. `pnpm typecheck` passes
2. `pnpm lint` passes
3. searchContacts escapes %, _, and \ before interpolation
4. getContacts returns paginated results with total count
5. bulkArchiveContacts, bulkDeleteContacts, bulkCreateContacts all reject > 100 items
6. Migration file ready for user to apply in Supabase SQL Editor
</success_criteria>

<output>
After completion, create `.planning/phases/03.1-critical-fixes/03.1-01-SUMMARY.md`
</output>
