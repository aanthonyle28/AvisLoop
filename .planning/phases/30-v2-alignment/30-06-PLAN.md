---
phase: 30-v2-alignment
plan: 06
type: execute
wave: 3
depends_on: ["30-03"]
files_modified:
  - components/jobs/csv-job-import-dialog.tsx
  - lib/actions/job.ts
  - lib/validations/job.ts
autonomous: true

must_haves:
  truths:
    - "CSV import accepts job-format CSV (customer_name, email, phone, service_type, completion_date)"
    - "Customers are created as side effect during job import"
    - "Imported jobs default to 'completed' status (historical data)"
    - "Duplicate customers detected by email and linked to existing records"
  artifacts:
    - path: "components/jobs/csv-job-import-dialog.tsx"
      provides: "Job CSV import dialog"
      min_lines: 200
    - path: "lib/actions/job.ts"
      provides: "bulkCreateJobsWithCustomers action"
      exports: ["bulkCreateJobsWithCustomers"]
  key_links:
    - from: "components/jobs/csv-job-import-dialog.tsx"
      to: "lib/actions/job.ts"
      via: "bulkCreateJobsWithCustomers import"
      pattern: "bulkCreateJobsWithCustomers"
---

<objective>
Create CSV job import functionality that accepts job-format CSV and creates customers as a side effect. This replaces customer-only CSV import for V2 workflow.

Purpose: V2FL-05 requirement. Historical jobs import with automatic customer creation.
Output: CSV Job Import dialog with preview, validation, and bulk create action.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-v2-alignment/30-RESEARCH.md

# Existing CSV import pattern to adapt
@components/customers/csv-import-dialog.tsx

# Depends on Plan 03 for inline customer creation logic
@.planning/phases/30-v2-alignment/30-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add job CSV validation schema</name>
  <files>lib/validations/job.ts</files>
  <action>
Add CSV job row validation schema to lib/validations/job.ts:

```typescript
// CSV Job import schema
export const csvJobRowSchema = z.object({
  customerName: z.string().min(1, 'Customer name is required'),
  customerEmail: z.string().email('Invalid email address'),
  customerPhone: z.string().optional().nullable(),
  serviceType: z.enum(SERVICE_TYPES),
  completionDate: z.string().optional(),  // YYYY-MM-DD or empty for today
  notes: z.string().optional().nullable(),
})

export type CSVJobRow = z.infer<typeof csvJobRowSchema>

// Header mappings for CSV parsing
export const JOB_CSV_HEADER_MAPPINGS: Record<string, keyof CSVJobRow> = {
  // Customer name variants
  'customer_name': 'customerName',
  'Customer Name': 'customerName',
  'name': 'customerName',
  'Name': 'customerName',
  'customer': 'customerName',
  'Customer': 'customerName',

  // Email variants
  'email': 'customerEmail',
  'Email': 'customerEmail',
  'customer_email': 'customerEmail',
  'Customer Email': 'customerEmail',

  // Phone variants
  'phone': 'customerPhone',
  'Phone': 'customerPhone',
  'customer_phone': 'customerPhone',
  'Customer Phone': 'customerPhone',
  'mobile': 'customerPhone',

  // Service type variants
  'service_type': 'serviceType',
  'Service Type': 'serviceType',
  'service': 'serviceType',
  'Service': 'serviceType',
  'type': 'serviceType',

  // Completion date variants
  'completion_date': 'completionDate',
  'Completion Date': 'completionDate',
  'completed_at': 'completionDate',
  'date': 'completionDate',
  'Date': 'completionDate',
  'completed': 'completionDate',

  // Notes variants
  'notes': 'notes',
  'Notes': 'notes',
  'description': 'notes',
  'Description': 'notes',
}
```
  </action>
  <verify>Run `pnpm typecheck` to confirm schema types are valid</verify>
  <done>CSV job row schema and header mappings added to lib/validations/job.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create bulkCreateJobsWithCustomers server action</name>
  <files>lib/actions/job.ts</files>
  <action>
Add bulkCreateJobsWithCustomers function to lib/actions/job.ts:

```typescript
export interface BulkJobCreateResult {
  success: boolean
  error?: string
  data?: {
    jobsCreated: number
    customersCreated: number
    customersLinked: number
    skipped: number
  }
}

export async function bulkCreateJobsWithCustomers(
  rows: CSVJobRow[]
): Promise<BulkJobCreateResult> {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) {
    return { success: false, error: 'Unauthorized' }
  }

  const business = await getBusiness()
  if (!business) {
    return { success: false, error: 'Business not found' }
  }

  // Fetch existing customers by email for deduplication
  const { data: existingCustomers } = await supabase
    .from('customers')
    .select('id, email')
    .eq('business_id', business.id)

  const existingEmailMap = new Map(
    (existingCustomers || []).map(c => [c.email.toLowerCase(), c.id])
  )

  let jobsCreated = 0
  let customersCreated = 0
  let customersLinked = 0
  let skipped = 0

  for (const row of rows) {
    try {
      const emailLower = row.customerEmail.toLowerCase()
      let customerId = existingEmailMap.get(emailLower)

      if (customerId) {
        // Link to existing customer
        customersLinked++
      } else {
        // Create new customer
        const phoneResult = row.customerPhone ? parseAndValidatePhone(row.customerPhone) : null

        const { data: newCustomer, error: customerError } = await supabase
          .from('customers')
          .insert({
            business_id: business.id,
            name: row.customerName.trim(),
            email: emailLower.trim(),
            phone: phoneResult?.e164 || row.customerPhone || null,
            phone_status: phoneResult?.status || 'missing',
            status: 'active',
          })
          .select('id')
          .single()

        if (customerError || !newCustomer) {
          console.error('Error creating customer:', customerError)
          skipped++
          continue
        }

        customerId = newCustomer.id
        existingEmailMap.set(emailLower, customerId)
        customersCreated++
      }

      // Parse completion date (default to now if not provided)
      const completionDate = row.completionDate
        ? new Date(row.completionDate)
        : new Date()

      // Create job with completed status (historical import)
      const { error: jobError } = await supabase
        .from('jobs')
        .insert({
          business_id: business.id,
          customer_id: customerId,
          service_type: row.serviceType,
          status: 'completed',  // Historical jobs are completed
          completed_at: completionDate.toISOString(),
          notes: row.notes || null,
        })

      if (jobError) {
        console.error('Error creating job:', jobError)
        skipped++
        continue
      }

      jobsCreated++

      // Note: Campaign enrollment skipped for historical imports
      // Add optional enrollInCampaign parameter if needed later
    } catch (err) {
      console.error('Error processing row:', err)
      skipped++
    }
  }

  revalidatePath('/jobs')
  revalidatePath('/customers')

  return {
    success: true,
    data: {
      jobsCreated,
      customersCreated,
      customersLinked,
      skipped,
    },
  }
}
```

Import CSVJobRow from validations:
```typescript
import { csvJobRowSchema, type CSVJobRow, JOB_CSV_HEADER_MAPPINGS } from '@/lib/validations/job'
```
  </action>
  <verify>Run `pnpm typecheck` to confirm action types are correct</verify>
  <done>bulkCreateJobsWithCustomers action creates customers as side effect of job import</done>
</task>

<task type="auto">
  <name>Task 3: Create CSV Job Import Dialog component</name>
  <files>components/jobs/csv-job-import-dialog.tsx</files>
  <action>
Create components/jobs/csv-job-import-dialog.tsx based on existing csv-import-dialog.tsx pattern:

```typescript
'use client'

import { useState, useCallback } from 'react'
import Papa from 'papaparse'
import { useDropzone } from 'react-dropzone'
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
  DialogFooter,
} from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { Badge } from '@/components/ui/badge'
import {
  Upload,
  FileXls,
  WarningCircle,
  CheckCircle,
  CircleNotch,
} from '@phosphor-icons/react'
import {
  bulkCreateJobsWithCustomers,
  type BulkJobCreateResult,
} from '@/lib/actions/job'
import {
  csvJobRowSchema,
  JOB_CSV_HEADER_MAPPINGS,
  SERVICE_TYPES,
  SERVICE_TYPE_LABELS,
  type CSVJobRow,
} from '@/lib/validations/job'
import { cn } from '@/lib/utils'

interface ParsedJobRow extends CSVJobRow {
  isValid: boolean
  errors: string[]
}

type Step = 'upload' | 'preview' | 'importing' | 'complete'

export function CSVJobImportDialog() {
  const [open, setOpen] = useState(false)
  const [step, setStep] = useState<Step>('upload')
  const [file, setFile] = useState<File | null>(null)
  const [parsedRows, setParsedRows] = useState<ParsedJobRow[]>([])
  const [importResult, setImportResult] = useState<BulkJobCreateResult | null>(null)

  const resetDialog = useCallback(() => {
    setStep('upload')
    setFile(null)
    setParsedRows([])
    setImportResult(null)
  }, [])

  const onDrop = useCallback(async (acceptedFiles: File[]) => {
    if (acceptedFiles.length === 0) return

    const uploadedFile = acceptedFiles[0]
    setFile(uploadedFile)

    Papa.parse(uploadedFile, {
      header: true,
      skipEmptyLines: true,
      complete: (results) => {
        const rows: ParsedJobRow[] = (results.data as Record<string, string>[]).map((row) => {
          // Map headers
          const mappedRow: Record<string, string> = {}
          for (const [key, value] of Object.entries(row)) {
            const mappedKey = JOB_CSV_HEADER_MAPPINGS[key] || key.toLowerCase()
            mappedRow[mappedKey] = value
          }

          // Normalize service type (case-insensitive)
          let serviceType = mappedRow.serviceType?.toLowerCase() || ''
          if (!SERVICE_TYPES.includes(serviceType as any)) {
            serviceType = 'other'
          }

          const parsed = csvJobRowSchema.safeParse({
            customerName: mappedRow.customerName || '',
            customerEmail: mappedRow.customerEmail || '',
            customerPhone: mappedRow.customerPhone || null,
            serviceType: serviceType || 'other',
            completionDate: mappedRow.completionDate || null,
            notes: mappedRow.notes || null,
          })

          if (parsed.success) {
            return {
              ...parsed.data,
              isValid: true,
              errors: [],
            }
          } else {
            return {
              customerName: mappedRow.customerName || '',
              customerEmail: mappedRow.customerEmail || '',
              customerPhone: mappedRow.customerPhone || null,
              serviceType: (serviceType || 'other') as any,
              completionDate: mappedRow.completionDate || null,
              notes: mappedRow.notes || null,
              isValid: false,
              errors: Object.values(parsed.error.flatten().fieldErrors).flat(),
            }
          }
        })

        setParsedRows(rows)
        setStep('preview')
      },
      error: () => {
        alert('Failed to parse CSV file.')
      },
    })
  }, [])

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: { 'text/csv': ['.csv'] },
    multiple: false,
  })

  const handleImport = async () => {
    setStep('importing')

    const validRows = parsedRows.filter(r => r.isValid)
    const result = await bulkCreateJobsWithCustomers(validRows)

    setImportResult(result)
    setStep('complete')
  }

  const validCount = parsedRows.filter(r => r.isValid).length
  const invalidCount = parsedRows.filter(r => !r.isValid).length

  return (
    <Dialog open={open} onOpenChange={(isOpen) => {
      setOpen(isOpen)
      if (!isOpen) resetDialog()
    }}>
      <DialogTrigger asChild>
        <Button variant="outline">
          <Upload size={16} weight="regular" className="mr-2" />
          Import Jobs CSV
        </Button>
      </DialogTrigger>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Import Jobs from CSV</DialogTitle>
        </DialogHeader>

        {/* Step 1: Upload */}
        {step === 'upload' && (
          <div className="space-y-4">
            <div
              {...getRootProps()}
              className={cn(
                'border-2 border-dashed rounded-lg p-12 text-center cursor-pointer transition-colors',
                isDragActive ? 'border-primary bg-primary/5' : 'border-muted-foreground/25 hover:border-primary/50'
              )}
            >
              <input {...getInputProps()} />
              <FileXls size={48} weight="regular" className="mx-auto mb-4 text-muted-foreground" />
              {isDragActive ? (
                <p className="text-lg font-medium">Drop CSV file here...</p>
              ) : (
                <>
                  <p className="text-lg font-medium mb-2">Drop CSV file here or click to upload</p>
                  <p className="text-sm text-muted-foreground">
                    Required columns: customer_name, email, service_type
                  </p>
                  <p className="text-sm text-muted-foreground">
                    Optional: phone, completion_date, notes
                  </p>
                </>
              )}
            </div>
          </div>
        )}

        {/* Step 2: Preview */}
        {step === 'preview' && (
          <div className="space-y-4">
            <div className="flex items-center gap-4 text-sm">
              <Badge variant="outline" className="text-green-600">
                {validCount} valid
              </Badge>
              {invalidCount > 0 && (
                <Badge variant="outline" className="text-red-600">
                  {invalidCount} invalid
                </Badge>
              )}
            </div>

            <div className="border rounded-lg overflow-x-auto max-h-64">
              <table className="min-w-full text-sm">
                <thead className="bg-muted">
                  <tr>
                    <th className="px-3 py-2 text-left">Customer</th>
                    <th className="px-3 py-2 text-left">Email</th>
                    <th className="px-3 py-2 text-left">Service</th>
                    <th className="px-3 py-2 text-left">Date</th>
                    <th className="px-3 py-2 text-left">Status</th>
                  </tr>
                </thead>
                <tbody>
                  {parsedRows.slice(0, 20).map((row, i) => (
                    <tr key={i} className={cn(!row.isValid && 'bg-red-50 dark:bg-red-950/20')}>
                      <td className="px-3 py-2">{row.customerName}</td>
                      <td className="px-3 py-2">{row.customerEmail}</td>
                      <td className="px-3 py-2">{SERVICE_TYPE_LABELS[row.serviceType] || row.serviceType}</td>
                      <td className="px-3 py-2">{row.completionDate || 'Today'}</td>
                      <td className="px-3 py-2">
                        {row.isValid ? (
                          <CheckCircle size={16} className="text-green-600" />
                        ) : (
                          <span className="text-red-600 text-xs">{row.errors.join(', ')}</span>
                        )}
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
              {parsedRows.length > 20 && (
                <p className="px-3 py-2 text-sm text-muted-foreground">
                  ...and {parsedRows.length - 20} more rows
                </p>
              )}
            </div>

            <div className="bg-muted/50 rounded-lg p-3 text-sm">
              <p className="font-medium">Note:</p>
              <p className="text-muted-foreground">
                Customers will be created automatically. Existing customers (by email) will be linked.
                Jobs will be imported as "completed" status.
              </p>
            </div>

            <DialogFooter>
              <Button variant="outline" onClick={() => setStep('upload')}>Back</Button>
              <Button onClick={handleImport} disabled={validCount === 0}>
                Import {validCount} job{validCount !== 1 ? 's' : ''}
              </Button>
            </DialogFooter>
          </div>
        )}

        {/* Step 3: Importing */}
        {step === 'importing' && (
          <div className="flex flex-col items-center justify-center py-12 space-y-4">
            <CircleNotch size={48} weight="regular" className="animate-spin text-primary" />
            <p className="text-lg font-medium">Importing jobs...</p>
          </div>
        )}

        {/* Step 4: Complete */}
        {step === 'complete' && (
          <div className="space-y-4">
            {importResult?.success ? (
              <div className="flex flex-col items-center justify-center py-8 space-y-4">
                <CheckCircle size={64} weight="regular" className="text-green-600" />
                <div className="text-center space-y-2">
                  <h3 className="text-lg font-semibold">Import Complete</h3>
                  <div className="text-sm text-muted-foreground space-y-1">
                    <p>Jobs created: <span className="font-medium text-green-600">{importResult.data?.jobsCreated || 0}</span></p>
                    <p>New customers: <span className="font-medium text-blue-600">{importResult.data?.customersCreated || 0}</span></p>
                    <p>Linked to existing: <span className="font-medium">{importResult.data?.customersLinked || 0}</span></p>
                    {(importResult.data?.skipped || 0) > 0 && (
                      <p>Skipped: <span className="font-medium text-amber-600">{importResult.data?.skipped}</span></p>
                    )}
                  </div>
                </div>
              </div>
            ) : (
              <div className="flex flex-col items-center justify-center py-8 space-y-4">
                <WarningCircle size={64} weight="regular" className="text-destructive" />
                <div className="text-center space-y-2">
                  <h3 className="text-lg font-semibold">Import Failed</h3>
                  <p className="text-sm text-destructive">{importResult?.error || 'Unknown error'}</p>
                </div>
              </div>
            )}
            <DialogFooter>
              <Button onClick={() => { setOpen(false); resetDialog(); }}>Close</Button>
            </DialogFooter>
          </div>
        )}
      </DialogContent>
    </Dialog>
  )
}
```
  </action>
  <verify>Run `pnpm typecheck` to confirm component compiles</verify>
  <done>CSV Job Import Dialog created with V2 job format and automatic customer creation</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes
2. `pnpm lint` passes
3. CSV Job Import dialog accepts job-format CSV
4. Preview shows customer name, email, service type, date
5. Import creates customers as side effect
6. Duplicate customers linked by email
</verification>

<success_criteria>
- CSV import accepts job format (V2FL-05)
- Customers created as side effect
- Duplicate customers detected and linked
- Jobs default to 'completed' status for historical import
</success_criteria>

<output>
After completion, create `.planning/phases/30-v2-alignment/30-06-SUMMARY.md`
</output>
