---
phase: 30-v2-alignment
plan: 03
type: execute
wave: 2
depends_on: ["30-01", "30-02"]
files_modified:
  - components/jobs/add-job-sheet.tsx
  - lib/actions/job.ts
autonomous: true

must_haves:
  truths:
    - "Add Job form shows customer autocomplete, not dropdown selector"
    - "User can create new customer inline by typing name and filling email/phone"
    - "New jobs default to 'scheduled' status"
    - "Customer is created as side effect when job is created with new customer"
  artifacts:
    - path: "components/jobs/add-job-sheet.tsx"
      provides: "Redesigned Add Job form with inline customer creation"
      min_lines: 150
    - path: "lib/actions/job.ts"
      provides: "createJob with inline customer creation"
      exports: ["createJob"]
  key_links:
    - from: "components/jobs/add-job-sheet.tsx"
      to: "components/jobs/customer-autocomplete.tsx"
      via: "CustomerAutocomplete import"
      pattern: "CustomerAutocomplete"
    - from: "lib/actions/job.ts"
      to: "lib/actions/customer.ts"
      via: "createCustomer call"
      pattern: "createCustomer"
---

<objective>
Redesign the Add Job form with inline customer creation. Replace the customer dropdown selector with the smart autocomplete component. Enable creating new customers as a side effect of job creation.

Purpose: V2FL-01/V2FL-02 core requirement. This is THE V2 transformation - customers are created through jobs, not independently.
Output: Fully redesigned Add Job sheet with autocomplete and inline customer creation.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-v2-alignment/30-RESEARCH.md

# Depends on Plan 01 and 02
@.planning/phases/30-v2-alignment/30-01-SUMMARY.md
@.planning/phases/30-v2-alignment/30-02-SUMMARY.md

# Existing patterns
@components/jobs/add-job-sheet.tsx
@components/customers/add-customer-sheet.tsx
@lib/actions/job.ts
@lib/actions/customer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update createJob action to support inline customer creation</name>
  <files>lib/actions/job.ts</files>
  <action>
Modify the createJob server action in lib/actions/job.ts to support two modes:
1. Existing customer (customerId provided)
2. New customer (customerName, customerEmail, customerPhone provided)

Update the function signature and logic:

```typescript
export async function createJob(
  prevState: JobActionState | null,
  formData: FormData
): Promise<JobActionState> {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) {
    return { success: false, error: 'Unauthorized' }
  }

  const business = await getBusiness()
  if (!business) {
    return { success: false, error: 'Business not found' }
  }

  // Extract form data
  const customerId = formData.get('customerId') as string | null
  const customerName = formData.get('customerName') as string | null
  const customerEmail = formData.get('customerEmail') as string | null
  const customerPhone = formData.get('customerPhone') as string | null
  const serviceType = formData.get('serviceType') as string
  const status = formData.get('status') as string || 'scheduled'
  const notes = formData.get('notes') as string
  const enrollInCampaign = formData.get('enrollInCampaign') === 'true'

  // Determine customer ID - either existing or create new
  let finalCustomerId = customerId

  if (!customerId && customerName && customerEmail) {
    // Create new customer as side effect
    const { data: existingCustomer } = await supabase
      .from('customers')
      .select('id')
      .eq('business_id', business.id)
      .eq('email', customerEmail.toLowerCase())
      .single()

    if (existingCustomer) {
      // Customer already exists with this email - use existing
      finalCustomerId = existingCustomer.id
    } else {
      // Create new customer
      const phoneResult = customerPhone ? parseAndValidatePhone(customerPhone) : null

      const { data: newCustomer, error: customerError } = await supabase
        .from('customers')
        .insert({
          business_id: business.id,
          name: customerName.trim(),
          email: customerEmail.toLowerCase().trim(),
          phone: phoneResult?.e164 || customerPhone || null,
          phone_status: phoneResult?.status || 'missing',
          status: 'active',
        })
        .select('id')
        .single()

      if (customerError || !newCustomer) {
        console.error('Error creating customer:', customerError)
        return { success: false, error: 'Failed to create customer' }
      }

      finalCustomerId = newCustomer.id
    }
  }

  if (!finalCustomerId) {
    return {
      success: false,
      error: 'Customer is required',
      fieldErrors: { customerId: ['Please select or create a customer'] }
    }
  }

  // Validate job fields
  const parsed = jobSchema.safeParse({
    customerId: finalCustomerId,
    serviceType,
    status,
    notes,
    enrollInCampaign,
  })

  if (!parsed.success) {
    return {
      success: false,
      error: 'Validation failed',
      fieldErrors: parsed.error.flatten().fieldErrors,
    }
  }

  // Create job
  const { data: job, error: jobError } = await supabase
    .from('jobs')
    .insert({
      business_id: business.id,
      customer_id: finalCustomerId,
      service_type: parsed.data.serviceType,
      status: parsed.data.status,
      notes: parsed.data.notes || null,
      completed_at: parsed.data.status === 'completed' ? new Date().toISOString() : null,
    })
    .select('id, service_type')
    .single()

  if (jobError || !job) {
    console.error('Error creating job:', jobError)
    return { success: false, error: 'Failed to create job' }
  }

  // Campaign enrollment for completed jobs (non-blocking)
  if (parsed.data.status === 'completed' && parsed.data.enrollInCampaign) {
    try {
      await enrollJobInCampaign(job.id, finalCustomerId, job.service_type as ServiceType, business.id)
    } catch (err) {
      console.error('Failed to enroll in campaign:', err)
    }
  }

  revalidatePath('/jobs')
  revalidatePath('/customers')
  revalidatePath('/dashboard')

  return { success: true }
}
```

Ensure parseAndValidatePhone is imported from '@/lib/utils/phone'.
  </action>
  <verify>Run `pnpm typecheck` to confirm createJob handles both modes</verify>
  <done>createJob supports existing customer OR inline creation via customerName/customerEmail/customerPhone</done>
</task>

<task type="auto">
  <name>Task 2: Redesign Add Job Sheet with inline customer creation</name>
  <files>components/jobs/add-job-sheet.tsx</files>
  <action>
Rewrite components/jobs/add-job-sheet.tsx to use CustomerAutocomplete and support inline creation:

```typescript
'use client'

import { useActionState, useEffect, useState } from 'react'
import { toast } from 'sonner'
import { CircleNotch } from '@phosphor-icons/react'
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from '@/components/ui/sheet'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Textarea } from '@/components/ui/textarea'
import { Checkbox } from '@/components/ui/checkbox'
import { CustomerAutocomplete } from './customer-autocomplete'
import { ServiceTypeSelect } from './service-type-select'
import { createJob, type JobActionState } from '@/lib/actions/job'
import { JOB_STATUSES, JOB_STATUS_LABELS, JOB_STATUS_DESCRIPTIONS } from '@/lib/validations/job'
import type { Customer, ServiceType, JobStatus } from '@/lib/types/database'

interface AddJobSheetProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  customers: Customer[]
}

export function AddJobSheet({ open, onOpenChange, customers }: AddJobSheetProps) {
  const [state, formAction, isPending] = useActionState<JobActionState | null, FormData>(
    createJob,
    null
  )

  // Mode: 'search' for autocomplete, 'create' for inline customer creation
  const [mode, setMode] = useState<'search' | 'create'>('search')

  // Selected existing customer (null if creating new)
  const [selectedCustomer, setSelectedCustomer] = useState<Customer | null>(null)

  // New customer fields (used in 'create' mode)
  const [customerName, setCustomerName] = useState('')
  const [customerEmail, setCustomerEmail] = useState('')
  const [customerPhone, setCustomerPhone] = useState('')

  // Job fields
  const [serviceType, setServiceType] = useState<ServiceType | ''>('')
  const [status, setStatus] = useState<JobStatus>('scheduled')
  const [notes, setNotes] = useState('')
  const [enrollInCampaign, setEnrollInCampaign] = useState(true)

  // Reset form when sheet closes
  useEffect(() => {
    if (!open) {
      setMode('search')
      setSelectedCustomer(null)
      setCustomerName('')
      setCustomerEmail('')
      setCustomerPhone('')
      setServiceType('')
      setStatus('scheduled')
      setNotes('')
      setEnrollInCampaign(true)
    }
  }, [open])

  // Handle success/error
  useEffect(() => {
    if (state?.success) {
      toast.success('Job created successfully')
      onOpenChange(false)
    } else if (state?.error) {
      toast.error(state.error)
    }
  }, [state, onOpenChange])

  const handleSelectCustomer = (customer: Customer | null) => {
    setSelectedCustomer(customer)
    if (customer) {
      setMode('search')
    }
  }

  const handleCreateNew = (name: string) => {
    setMode('create')
    setCustomerName(name)
    setSelectedCustomer(null)
  }

  const handleBackToSearch = () => {
    setMode('search')
    setCustomerName('')
    setCustomerEmail('')
    setCustomerPhone('')
  }

  const handleSubmit = (formData: FormData) => {
    // Add form values to FormData
    if (selectedCustomer) {
      formData.set('customerId', selectedCustomer.id)
    } else if (mode === 'create') {
      formData.set('customerName', customerName)
      formData.set('customerEmail', customerEmail)
      formData.set('customerPhone', customerPhone)
    }

    formData.set('serviceType', serviceType)
    formData.set('status', status)
    formData.set('notes', notes)

    if (status === 'completed') {
      formData.set('enrollInCampaign', enrollInCampaign.toString())
    }

    formAction(formData)
  }

  const isCustomerValid = selectedCustomer || (mode === 'create' && customerName && customerEmail)

  return (
    <Sheet open={open} onOpenChange={onOpenChange}>
      <SheetContent className="overflow-y-auto">
        <SheetHeader>
          <SheetTitle>Add Job</SheetTitle>
          <SheetDescription>
            Create a new job. {status === 'scheduled' ? 'Mark complete later when work is done.' : 'Completed jobs are enrolled in campaigns.'}
          </SheetDescription>
        </SheetHeader>

        <form action={handleSubmit} className="mt-6 space-y-4">
          {/* Customer Section - Autocomplete or Inline Create */}
          <div className="space-y-2">
            <Label>Customer *</Label>

            {mode === 'search' ? (
              <CustomerAutocomplete
                customers={customers}
                value={selectedCustomer}
                onChange={handleSelectCustomer}
                onCreateNew={handleCreateNew}
                error={state?.fieldErrors?.customerId?.[0]}
              />
            ) : (
              <div className="space-y-3 p-4 border rounded-lg bg-muted/30">
                <p className="text-sm font-medium">New Customer</p>

                <div className="space-y-2">
                  <Label htmlFor="customerName">Name *</Label>
                  <Input
                    id="customerName"
                    value={customerName}
                    onChange={(e) => setCustomerName(e.target.value)}
                    placeholder="Customer name"
                    required
                  />
                </div>

                <div className="space-y-2">
                  <Label htmlFor="customerEmail">Email *</Label>
                  <Input
                    id="customerEmail"
                    type="email"
                    value={customerEmail}
                    onChange={(e) => setCustomerEmail(e.target.value)}
                    placeholder="customer@email.com"
                    required
                  />
                </div>

                <div className="space-y-2">
                  <Label htmlFor="customerPhone">Phone (optional)</Label>
                  <Input
                    id="customerPhone"
                    type="tel"
                    value={customerPhone}
                    onChange={(e) => setCustomerPhone(e.target.value)}
                    placeholder="+1 (555) 123-4567"
                  />
                  <p className="text-xs text-muted-foreground">
                    Required for SMS review requests
                  </p>
                </div>

                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={handleBackToSearch}
                  className="mt-2"
                >
                  Or select existing customer
                </Button>
              </div>
            )}
          </div>

          {/* Service Type */}
          <div className="space-y-2">
            <Label>Service Type *</Label>
            <ServiceTypeSelect
              value={serviceType}
              onChange={setServiceType}
              error={state?.fieldErrors?.serviceType?.[0]}
            />
          </div>

          {/* Status */}
          <div className="space-y-2">
            <Label>Status</Label>
            <select
              value={status}
              onChange={(e) => setStatus(e.target.value as JobStatus)}
              className="w-full rounded-md border border-input bg-background px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-ring"
            >
              {JOB_STATUSES.map(s => (
                <option key={s} value={s}>
                  {JOB_STATUS_LABELS[s]}
                </option>
              ))}
            </select>
            <p className="text-xs text-muted-foreground">
              {JOB_STATUS_DESCRIPTIONS[status]}
            </p>
          </div>

          {/* Campaign enrollment checkbox - only for completed status */}
          {status === 'completed' && (
            <div className="space-y-2 rounded-lg border bg-muted/50 p-4">
              <div className="flex items-center space-x-2">
                <Checkbox
                  id="enrollInCampaign"
                  checked={enrollInCampaign}
                  onCheckedChange={(checked) => setEnrollInCampaign(!!checked)}
                />
                <Label htmlFor="enrollInCampaign" className="font-normal cursor-pointer">
                  Enroll in review campaign
                </Label>
              </div>
              <p className="text-xs text-muted-foreground ml-6">
                Automatically send review requests based on your active campaign
              </p>
            </div>
          )}

          {/* Notes */}
          <div className="space-y-2">
            <Label>Notes (optional)</Label>
            <Textarea
              value={notes}
              onChange={(e) => setNotes(e.target.value)}
              placeholder="Add any notes about this job..."
              rows={3}
            />
            {state?.fieldErrors?.notes?.[0] && (
              <p className="text-sm text-destructive">{state.fieldErrors.notes[0]}</p>
            )}
          </div>

          {/* Submit */}
          <div className="flex justify-end gap-2 pt-4">
            <Button
              type="button"
              variant="outline"
              onClick={() => onOpenChange(false)}
            >
              Cancel
            </Button>
            <Button type="submit" disabled={isPending || !isCustomerValid || !serviceType}>
              {isPending && <CircleNotch className="mr-2 h-4 w-4 animate-spin" />}
              Create Job
            </Button>
          </div>
        </form>
      </SheetContent>
    </Sheet>
  )
}
```

Key changes from original:
1. Replaced CustomerSelector dropdown with CustomerAutocomplete
2. Added inline customer creation form (mode='create')
3. Default status is now 'scheduled' (V2 dispatch workflow)
4. Uses Phosphor icon (CircleNotch) instead of Lucide (Loader2)
5. JOB_STATUS_DESCRIPTIONS shown under status selector
6. Customer fields passed to createJob action
  </action>
  <verify>Run `pnpm typecheck` to confirm no type errors</verify>
  <done>Add Job Sheet uses autocomplete and supports inline customer creation</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes
2. `pnpm lint` passes
3. Add Job form shows autocomplete for customer selection
4. "Create new" option appears when no matches found
5. Inline customer form shows when "Create new" clicked
6. Default status is 'scheduled'
</verification>

<success_criteria>
- Add Job form no longer requires pre-existing customer selection (V2FL-02)
- Inline customer creation works (V2FL-01)
- New jobs default to 'scheduled' status (V2FL-10)
- Customer created as side effect when job submitted with new customer info
</success_criteria>

<output>
After completion, create `.planning/phases/30-v2-alignment/30-03-SUMMARY.md`
</output>
