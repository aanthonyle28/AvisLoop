---
phase: 30-v2-alignment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - components/jobs/customer-autocomplete.tsx
  - lib/data/customer.ts
autonomous: true

must_haves:
  truths:
    - "User can type in Add Job form and see autocomplete suggestions for existing customers"
    - "Autocomplete matches on customer name AND email"
    - "Autocomplete triggers at 2+ characters"
    - "Autocomplete limits suggestions to 6 items"
  artifacts:
    - path: "components/jobs/customer-autocomplete.tsx"
      provides: "Smart autocomplete component"
      min_lines: 80
    - path: "lib/data/customer.ts"
      provides: "getCustomersForAutocomplete query"
      exports: ["getCustomersForAutocomplete"]
  key_links:
    - from: "components/jobs/customer-autocomplete.tsx"
      to: "lib/data/customer.ts"
      via: "getCustomersForAutocomplete import"
      pattern: "getCustomersForAutocomplete"
---

<objective>
Create a smart customer autocomplete component for the Add Job form. This component enables the V2 pattern where users type a customer name and either select an existing customer OR create a new one inline.

Purpose: Foundation for V2FL-01/V2FL-02 (inline customer creation in jobs). Must be built before Add Job form redesign.
Output: Reusable CustomerAutocomplete component with search, keyboard nav, and "Create new" option.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-v2-alignment/30-RESEARCH.md

# Existing patterns
@components/jobs/customer-selector.tsx
@components/send/quick-send-tab.tsx (has autocomplete pattern at lines 74-84)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create getCustomersForAutocomplete data function</name>
  <files>lib/data/customer.ts</files>
  <action>
Add a new function to lib/data/customer.ts:

```typescript
export async function getCustomersForAutocomplete(): Promise<Pick<Customer, 'id' | 'name' | 'email' | 'phone'>[]> {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return []

  const business = await getBusiness()
  if (!business) return []

  const { data, error } = await supabase
    .from('customers')
    .select('id, name, email, phone')
    .eq('business_id', business.id)
    .eq('status', 'active')
    .order('name')

  if (error) {
    console.error('Error fetching customers:', error)
    return []
  }

  return data ?? []
}
```

This function returns minimal customer data (id, name, email, phone) for autocomplete. Returns empty array on error to support graceful degradation.
  </action>
  <verify>Run `pnpm typecheck` to confirm no type errors</verify>
  <done>getCustomersForAutocomplete function exists in lib/data/customer.ts, returns minimal customer data</done>
</task>

<task type="auto">
  <name>Task 2: Create CustomerAutocomplete component</name>
  <files>components/jobs/customer-autocomplete.tsx</files>
  <action>
Create new component at components/jobs/customer-autocomplete.tsx based on research Pattern 1:

```typescript
'use client'

import { useState, useMemo, useRef, useEffect } from 'react'
import { Input } from '@/components/ui/input'
import { Button } from '@/components/ui/button'
import { cn } from '@/lib/utils'

interface Customer {
  id: string
  name: string
  email: string
  phone?: string | null
}

interface CustomerAutocompleteProps {
  customers: Customer[]
  value: Customer | null
  onChange: (customer: Customer | null) => void
  onCreateNew: (name: string) => void
  placeholder?: string
  error?: string
}

export function CustomerAutocomplete({
  customers,
  value,
  onChange,
  onCreateNew,
  placeholder = 'Type customer name or email...',
  error,
}: CustomerAutocompleteProps) {
  const [query, setQuery] = useState(value?.name ?? '')
  const [isOpen, setIsOpen] = useState(false)
  const [highlightedIndex, setHighlightedIndex] = useState(-1)
  const inputRef = useRef<HTMLInputElement>(null)
  const listRef = useRef<HTMLDivElement>(null)

  // Filter customers based on query (minimum 2 chars)
  const filtered = useMemo(() => {
    if (query.length < 2) return []
    const lowerQuery = query.toLowerCase()
    return customers
      .filter(c =>
        c.name.toLowerCase().includes(lowerQuery) ||
        c.email.toLowerCase().includes(lowerQuery)
      )
      .slice(0, 6)  // Limit to 6 suggestions
  }, [query, customers])

  const showCreateNew = query.length >= 2 && filtered.length === 0

  // Reset highlighted index when filtered changes
  useEffect(() => {
    setHighlightedIndex(-1)
  }, [filtered])

  // Sync query with selected value
  useEffect(() => {
    if (value) {
      setQuery(value.name)
    }
  }, [value])

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newQuery = e.target.value
    setQuery(newQuery)
    setIsOpen(true)
    // Clear selection if query changes from selected value
    if (value && newQuery !== value.name) {
      onChange(null)
    }
  }

  const handleSelect = (customer: Customer) => {
    onChange(customer)
    setQuery(customer.name)
    setIsOpen(false)
    inputRef.current?.blur()
  }

  const handleCreateNewClick = () => {
    onCreateNew(query)
    setIsOpen(false)
  }

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (!isOpen) return

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault()
        setHighlightedIndex(prev =>
          prev < filtered.length - 1 ? prev + 1 : prev
        )
        break
      case 'ArrowUp':
        e.preventDefault()
        setHighlightedIndex(prev => (prev > 0 ? prev - 1 : prev))
        break
      case 'Enter':
        e.preventDefault()
        if (highlightedIndex >= 0 && filtered[highlightedIndex]) {
          handleSelect(filtered[highlightedIndex])
        } else if (showCreateNew) {
          handleCreateNewClick()
        }
        break
      case 'Escape':
        setIsOpen(false)
        break
    }
  }

  const handleBlur = () => {
    // Delay to allow click events on dropdown items
    setTimeout(() => setIsOpen(false), 200)
  }

  return (
    <div className="relative">
      <Input
        ref={inputRef}
        value={query}
        onChange={handleInputChange}
        onFocus={() => setIsOpen(true)}
        onBlur={handleBlur}
        onKeyDown={handleKeyDown}
        placeholder={placeholder}
        aria-expanded={isOpen}
        aria-haspopup="listbox"
        aria-controls="customer-autocomplete-list"
        aria-activedescendant={highlightedIndex >= 0 ? `customer-option-${highlightedIndex}` : undefined}
        className={cn(error && 'border-destructive')}
      />

      {/* Dropdown */}
      {isOpen && (filtered.length > 0 || showCreateNew) && (
        <div
          ref={listRef}
          id="customer-autocomplete-list"
          role="listbox"
          className="absolute z-50 w-full mt-1 bg-popover border rounded-md shadow-md max-h-60 overflow-auto"
        >
          {/* Existing customers */}
          {filtered.map((customer, index) => (
            <button
              key={customer.id}
              id={`customer-option-${index}`}
              role="option"
              aria-selected={highlightedIndex === index}
              type="button"
              onClick={() => handleSelect(customer)}
              className={cn(
                'w-full px-3 py-2 text-left hover:bg-accent',
                highlightedIndex === index && 'bg-accent'
              )}
            >
              <div className="font-medium">{customer.name}</div>
              <div className="text-sm text-muted-foreground">{customer.email}</div>
            </button>
          ))}

          {/* Create new option */}
          {showCreateNew && (
            <button
              type="button"
              onClick={handleCreateNewClick}
              className="w-full px-3 py-2 text-left border-t hover:bg-accent"
            >
              <div className="font-medium text-primary">
                + Create new customer "{query}"
              </div>
              <div className="text-sm text-muted-foreground">
                Add email and phone in the form below
              </div>
            </button>
          )}
        </div>
      )}

      {/* Error message */}
      {error && (
        <p className="mt-1 text-sm text-destructive">{error}</p>
      )}
    </div>
  )
}
```

Key features:
1. Matches on name AND email
2. Triggers at 2+ characters
3. Limits to 6 suggestions
4. Full keyboard navigation (arrows, Enter, Escape)
5. "Create new" option when no matches
6. ARIA attributes for accessibility
7. Error state support
  </action>
  <verify>Run `pnpm typecheck` to confirm no type errors</verify>
  <done>CustomerAutocomplete component exists with search, keyboard nav, and create-new option</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes
2. `pnpm lint` passes
3. Component exports: CustomerAutocomplete from components/jobs/customer-autocomplete.tsx
4. Data function exports: getCustomersForAutocomplete from lib/data/customer.ts
</verification>

<success_criteria>
- CustomerAutocomplete component handles search, selection, and create-new flow
- Keyboard navigation works (ArrowUp, ArrowDown, Enter, Escape)
- ARIA attributes present for accessibility
- Error state supported via error prop
</success_criteria>

<output>
After completion, create `.planning/phases/30-v2-alignment/30-01-SUMMARY.md`
</output>
