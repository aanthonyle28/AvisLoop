---
phase: 47-dashboard-right-panel-campaign-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/types/dashboard.ts
  - lib/data/dashboard.ts
autonomous: true

must_haves:
  truths:
    - "getDashboardKPIs() returns a history array (14 daily buckets) for each of the 3 outcome KPI metrics (reviewsThisMonth, averageRating, conversionRate)"
    - "Each history bucket contains a date string (YYYY-MM-DD) and a numeric value representing the count or average for that day"
    - "When fewer than 2 data points exist in the 14-day window, the history array still contains 14 entries (with zero values for empty days)"
    - "The KPIMetric type includes an optional history field typed as DayBucket[]"
  artifacts:
    - path: "lib/types/dashboard.ts"
      provides: "DayBucket interface and KPIMetric.history field"
      contains: "DayBucket"
    - path: "lib/data/dashboard.ts"
      provides: "14-day history queries and bucketByDay utility"
      contains: "bucketByDay"
  key_links:
    - from: "lib/data/dashboard.ts"
      to: "lib/types/dashboard.ts"
      via: "import DayBucket type"
      pattern: "DayBucket"
---

<objective>
Extend the dashboard KPI data pipeline to include 14-day daily history for sparkline rendering.

Purpose: The right panel KPI cards need sparkline trend graphs (Plan 47-02). This plan adds the data layer — extending the KPIMetric type with a `history` field and adding parallel Supabase queries that bucket timestamps into daily counts over the last 14 days.

Output: Updated `lib/types/dashboard.ts` with `DayBucket` interface and `KPIMetric.history` field. Updated `lib/data/dashboard.ts` with `bucketByDay()` utility and 3 new parallel queries in `getDashboardKPIs()` for reviews, ratings, and sends history.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/47-dashboard-right-panel-campaign-polish/47-CONTEXT.md
@.planning/phases/47-dashboard-right-panel-campaign-polish/47-RESEARCH.md

@lib/types/dashboard.ts
@lib/data/dashboard.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DayBucket type and extend KPIMetric with history field</name>
  <files>lib/types/dashboard.ts</files>
  <action>
Add a `DayBucket` interface with `date: string` (YYYY-MM-DD) and `value: number` fields. Export it.

Add an optional `history?: DayBucket[]` field to the existing `KPIMetric` interface. This field will hold 14 daily data points, oldest first.

Do NOT change any other types. The history field is optional so existing consumers don't break.
  </action>
  <verify>pnpm typecheck passes with no new errors</verify>
  <done>KPIMetric has an optional `history?: DayBucket[]` field and DayBucket is exported from lib/types/dashboard.ts</done>
</task>

<task type="auto">
  <name>Task 2: Add bucketByDay utility and 14-day history queries to getDashboardKPIs</name>
  <files>lib/data/dashboard.ts</files>
  <action>
**Step 1:** Add a `bucketByDay` helper function (not exported, module-internal) that takes an array of ISO timestamp strings and a number of days, and returns `DayBucket[]`. The function:
1. Creates a map of the last N days (today back to N-1 days ago) with 0 values
2. Iterates the timestamps, incrementing the matching day bucket
3. Returns entries sorted by date ascending (oldest first)

```typescript
function bucketByDay(timestamps: string[], days: number): DayBucket[] {
  const now = new Date()
  const buckets: Record<string, number> = {}
  for (let i = days - 1; i >= 0; i--) {
    const d = new Date(now)
    d.setDate(d.getDate() - i)
    buckets[d.toISOString().slice(0, 10)] = 0
  }
  for (const ts of timestamps) {
    const day = new Date(ts).toISOString().slice(0, 10)
    if (day in buckets) buckets[day]++
  }
  return Object.entries(buckets)
    .sort(([a], [b]) => a.localeCompare(b))
    .map(([date, value]) => ({ date, value }))
}
```

**Step 2:** In `getDashboardKPIs()`, compute `fourteenDaysAgo` from `now`:
```typescript
const fourteenDaysAgo = new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000)
```

**Step 3:** Add 3 new parallel queries to the existing `Promise.all` call:

1. **Reviews history (14 days):**
   ```typescript
   supabase
     .from('send_logs')
     .select('reviewed_at')
     .eq('business_id', businessId)
     .not('reviewed_at', 'is', null)
     .gte('reviewed_at', fourteenDaysAgo.toISOString())
   ```

2. **Ratings history (14 days):**
   ```typescript
   supabase
     .from('customer_feedback')
     .select('rating, submitted_at')
     .eq('business_id', businessId)
     .gte('submitted_at', fourteenDaysAgo.toISOString())
   ```

3. **Sends history (14 days) — for conversion rate sparkline:**
   ```typescript
   supabase
     .from('send_logs')
     .select('created_at, reviewed_at')
     .eq('business_id', businessId)
     .in('status', ['sent', 'delivered', 'opened'])
     .gte('created_at', fourteenDaysAgo.toISOString())
   ```

Destructure these 3 new results alongside the existing 11 results. Name them:
- `reviewsHistoryResult`
- `ratingsHistoryResult`
- `sendsHistoryResult`

**Step 4:** After the existing metric calculations, compute history arrays:

```typescript
// Reviews history — daily review counts
const reviewsHistory = bucketByDay(
  (reviewsHistoryResult.data || []).map(r => r.reviewed_at!),
  14
)

// Average rating history — daily average rating (not count)
// For this metric, compute daily averages instead of counts
const ratingsHistoryRaw = ratingsHistoryResult.data || []
const ratingsByDay: Record<string, number[]> = {}
for (let i = 13; i >= 0; i--) {
  const d = new Date(now)
  d.setDate(d.getDate() - i)
  ratingsByDay[d.toISOString().slice(0, 10)] = []
}
for (const r of ratingsHistoryRaw) {
  const day = new Date(r.submitted_at).toISOString().slice(0, 10)
  if (day in ratingsByDay) ratingsByDay[day].push(r.rating)
}
const ratingsHistory: DayBucket[] = Object.entries(ratingsByDay)
  .sort(([a], [b]) => a.localeCompare(b))
  .map(([date, ratings]) => ({
    date,
    value: ratings.length > 0
      ? Math.round((ratings.reduce((s, r) => s + r, 0) / ratings.length) * 10) / 10
      : 0,
  }))

// Conversion rate history — daily conversion % (reviews / sends * 100)
const sendsHistoryRaw = sendsHistoryResult.data || []
const sendsByDay = bucketByDay(
  sendsHistoryRaw.map(r => r.created_at),
  14
)
const reviewsByDay = bucketByDay(
  sendsHistoryRaw.filter(r => r.reviewed_at != null).map(r => r.created_at),
  14
)
const conversionHistory: DayBucket[] = sendsByDay.map((dayBucket, i) => ({
  date: dayBucket.date,
  value: dayBucket.value > 0
    ? Math.round((reviewsByDay[i].value / dayBucket.value) * 100)
    : 0,
}))
```

**Step 5:** Add `history` to each of the 3 outcome KPIMetric return objects:

```typescript
reviewsThisMonth: {
  ...existing,
  history: reviewsHistory,
},
averageRating: {
  ...existing,
  history: ratingsHistory,
},
conversionRate: {
  ...existing,
  history: conversionHistory,
},
```

The pipeline metrics (requestsSentThisWeek, activeSequences, pendingQueued) do NOT get history — they stay unchanged.

**Step 6:** In the zero-state error catch block, add `history: []` to the 3 outcome metric fallbacks.

Import `DayBucket` from `@/lib/types/dashboard` at the top of the file.

**Important:** Do NOT remove or rewrite any existing query logic. Only ADD to the Promise.all array and ADD computation after it.
  </action>
  <verify>
1. pnpm typecheck passes
2. pnpm lint passes
3. Verify the Promise.all destructuring has 14 elements (11 existing + 3 new)
4. Verify the return object has `history` on reviewsThisMonth, averageRating, conversionRate but NOT on pipeline metrics
  </verify>
  <done>getDashboardKPIs() returns history arrays for the 3 outcome KPIs. bucketByDay() utility correctly generates 14 daily data points. TypeScript types are clean with no errors.</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` — passes with no errors
2. `pnpm lint` — passes with no errors
3. `lib/types/dashboard.ts` exports `DayBucket` and `KPIMetric` has optional `history` field
4. `lib/data/dashboard.ts` has `bucketByDay` function and 3 new history queries
5. Return type includes `history` on outcome metrics but NOT on pipeline metrics
</verification>

<success_criteria>
- KPIMetric type extended with `history?: DayBucket[]`
- getDashboardKPIs() returns 14-day daily history for reviews, ratings, and conversion rate
- No regressions — existing KPI values still computed identically
- TypeScript and lint clean
</success_criteria>

<output>
After completion, create `.planning/phases/47-dashboard-right-panel-campaign-polish/47-01-SUMMARY.md`
</output>
