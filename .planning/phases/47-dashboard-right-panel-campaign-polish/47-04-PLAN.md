---
phase: 47-dashboard-right-panel-campaign-polish
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - components/jobs/service-type-select.tsx
  - components/jobs/add-job-sheet.tsx
  - components/jobs/edit-job-sheet.tsx
autonomous: true

must_haves:
  truths:
    - "ServiceTypeSelect uses Radix Select component from components/ui/select.tsx instead of a native HTML <select>"
    - "Add Job form status field uses Radix Select with onValueChange instead of native <select> with onChange"
    - "Edit Job form status field uses Radix Select with onValueChange instead of native <select> with onChange"
    - "Empty/placeholder state works correctly — unselected service type shows 'Select service type...' placeholder"
    - "Form submission end-to-end works — values are correctly captured and sent to server actions"
    - "Custom service names for 'other' type continue to render correctly in the ServiceTypeSelect dropdown"
  artifacts:
    - path: "components/jobs/service-type-select.tsx"
      provides: "ServiceTypeSelect using Radix Select primitives"
      contains: "SelectTrigger"
    - path: "components/jobs/add-job-sheet.tsx"
      provides: "Status field using Radix Select"
      contains: "onValueChange"
    - path: "components/jobs/edit-job-sheet.tsx"
      provides: "Status field using Radix Select"
      contains: "onValueChange"
  key_links:
    - from: "components/jobs/service-type-select.tsx"
      to: "components/ui/select.tsx"
      via: "import Select components"
      pattern: "import.*Select.*from.*@/components/ui/select"
    - from: "components/jobs/add-job-sheet.tsx"
      to: "components/ui/select.tsx"
      via: "import Select components for status field"
      pattern: "import.*Select.*from.*@/components/ui/select"
---

<objective>
Migrate native HTML `<select>` elements in job forms to Radix Select components for consistent UI and accessibility.

Purpose: The Add Job, Edit Job, and ServiceTypeSelect components use native `<select>` elements which look inconsistent with the rest of the app (which uses Radix/Shadcn Select). Migrating to Radix Select brings visual consistency, keyboard accessibility, and proper dark mode support.

Output: Updated `service-type-select.tsx`, `add-job-sheet.tsx`, and `edit-job-sheet.tsx` using Radix Select with `onValueChange` instead of native `<select>` with `onChange`.
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/47-dashboard-right-panel-campaign-polish/47-CONTEXT.md
@.planning/phases/47-dashboard-right-panel-campaign-polish/47-RESEARCH.md

@components/jobs/service-type-select.tsx
@components/jobs/add-job-sheet.tsx
@components/jobs/edit-job-sheet.tsx
@components/ui/select.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate ServiceTypeSelect to Radix Select</name>
  <files>components/jobs/service-type-select.tsx</files>
  <action>
Replace the entire native `<select>` implementation with Radix Select from `@/components/ui/select`.

**Imports to add:**
```typescript
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
```

**Keep the existing interface unchanged** — `ServiceTypeSelectProps` stays the same with `value`, `onChange`, `error`, `enabledTypes`, `customServiceNames`.

**Key Radix Select gotcha:** When `value` is `''` (empty string), Radix Select does NOT show the placeholder. You must use `value || undefined` to trigger placeholder display.

**Replace the `<select>` block with:**
```tsx
<Select
  value={value || undefined}
  onValueChange={(val) => onChange(val as ServiceType)}
>
  <SelectTrigger className={error ? 'border-destructive' : ''}>
    <SelectValue placeholder="Select service type..." />
  </SelectTrigger>
  <SelectContent>
    {availableTypes.flatMap(type => {
      // For 'other' with custom names, render each custom name as a separate option
      // All use value="other" since the DB only stores 'other'
      if (type === 'other' && customServiceNames && customServiceNames.length > 0) {
        return customServiceNames.map(name => (
          <SelectItem key={`other-${name}`} value="other">
            {name}
          </SelectItem>
        ))
      }
      return (
        <SelectItem key={type} value={type}>
          {SERVICE_TYPE_LABELS[type]}
        </SelectItem>
      )
    })}
  </SelectContent>
</Select>
```

**Keep the error message display** below the Select (the `{error && <p>...` block stays).

**Remove:** The inline className string on the old `<select>` (the Radix Select handles its own styling via the design system).

**CRITICAL EDGE CASE with custom service names:** When there are multiple custom names for 'other', Radix Select does NOT allow duplicate `value` props on `SelectItem`. All custom "other" items have `value="other"`. This will cause only the first to be selectable. To handle this:
- Use the FIRST custom name as the display if there's only one custom name
- If there are multiple custom names, they all map to `value="other"` — Radix Select allows this but only the LAST rendered item with that value will be highlighted. This is acceptable because the DB only stores 'other' regardless of which custom name is shown.
- Actually, Radix Select does NOT support duplicate values. If multiple items share `value="other"`, only one appears selectable. The workaround: render a SINGLE `SelectItem` for 'other' that shows the custom name(s). If there's one custom name, show it. If there are multiple, show the first one (the user already chose this service type — the distinction is cosmetic).

**Revised approach for 'other' with custom names:**
```typescript
if (type === 'other' && customServiceNames && customServiceNames.length > 0) {
  // Show first custom name as label; all map to 'other' in DB
  return [
    <SelectItem key="other" value="other">
      {customServiceNames[0]}
    </SelectItem>
  ]
}
```

Wait — check current behavior more carefully. Read the current component: it renders EACH custom name as a separate `<option value="other">`. This works with native select because native selects allow duplicate values. But Radix Select doesn't.

**Final approach:** Since all custom names map to the same `value="other"`, render ONE SelectItem with `value="other"` whose label is the joined custom names or just the type label if multiple exist:
```typescript
if (type === 'other' && customServiceNames && customServiceNames.length > 0) {
  if (customServiceNames.length === 1) {
    return [<SelectItem key="other" value="other">{customServiceNames[0]}</SelectItem>]
  }
  // Multiple custom names — show them joined
  return [<SelectItem key="other" value="other">{customServiceNames.join(', ')}</SelectItem>]
}
```

This preserves the user experience (they see their custom name(s)) while being compatible with Radix Select's unique-value requirement.
  </action>
  <verify>
1. pnpm typecheck passes
2. pnpm lint passes
3. No native `<select>` or `<option>` elements remain in the file
4. Placeholder "Select service type..." shows when value is empty
5. Custom service names render correctly for 'other' type
  </verify>
  <done>ServiceTypeSelect uses Radix Select with proper placeholder handling and custom service name support</done>
</task>

<task type="auto">
  <name>Task 2: Migrate status selects in AddJobSheet and EditJobSheet to Radix Select</name>
  <files>components/jobs/add-job-sheet.tsx, components/jobs/edit-job-sheet.tsx</files>
  <action>
In BOTH files, replace the native `<select>` for the job status field with Radix Select.

**Imports to add to each file:**
```typescript
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
```

**In `add-job-sheet.tsx`** (around line 282):

Replace:
```tsx
<select
  value={status}
  onChange={(e) => setStatus(e.target.value as JobStatus)}
  className="w-full rounded-md border border-input bg-background px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-ring"
>
  {ADD_JOB_STATUSES.map(s => (
    <option key={s} value={s}>
      {JOB_STATUS_LABELS[s]}
    </option>
  ))}
</select>
```

With:
```tsx
<Select value={status} onValueChange={(val) => setStatus(val as JobStatus)}>
  <SelectTrigger>
    <SelectValue />
  </SelectTrigger>
  <SelectContent>
    {ADD_JOB_STATUSES.map(s => (
      <SelectItem key={s} value={s}>
        {JOB_STATUS_LABELS[s]}
      </SelectItem>
    ))}
  </SelectContent>
</Select>
```

Note: Status always has a default value (never empty), so no placeholder needed and no `value || undefined` workaround needed.

**In `edit-job-sheet.tsx`** (around line 202):

Apply the exact same replacement pattern but using `EDIT_JOB_STATUSES` instead of `ADD_JOB_STATUSES`.

Replace:
```tsx
<select
  value={status}
  onChange={(e) => setStatus(e.target.value as JobStatus)}
  className="w-full rounded-md border border-input bg-background px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-ring"
>
  {EDIT_JOB_STATUSES.map(s => (
    <option key={s} value={s}>
      {JOB_STATUS_LABELS[s]}
    </option>
  ))}
</select>
```

With:
```tsx
<Select value={status} onValueChange={(val) => setStatus(val as JobStatus)}>
  <SelectTrigger>
    <SelectValue />
  </SelectTrigger>
  <SelectContent>
    {EDIT_JOB_STATUSES.map(s => (
      <SelectItem key={s} value={s}>
        {JOB_STATUS_LABELS[s]}
      </SelectItem>
    ))}
  </SelectContent>
</Select>
```

**Verify form submission still works:**
After making these changes, the form submission logic should be unaffected because:
- The `status` state variable is updated via `setStatus()` in both approaches
- The server action receives status from the form data or state, not from the select element directly
- `onValueChange` calls `setStatus(val as JobStatus)` which is functionally identical to `onChange={(e) => setStatus(e.target.value as JobStatus)}`

**Clean up:** Remove any unused imports after the migration. If the files were importing HTML select-related types, remove those.
  </action>
  <verify>
1. pnpm typecheck passes
2. pnpm lint passes
3. No native `<select>` or `<option>` elements remain in either file
4. Both files import Select components from @/components/ui/select
5. Both files use onValueChange (not onChange) for the status select
6. Status default values display correctly (not showing placeholder)
  </verify>
  <done>Add Job and Edit Job forms use Radix Select for status fields with onValueChange. No native <select> elements remain. Form submission logic is preserved.</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` — passes with no errors
2. `pnpm lint` — passes with no errors
3. Zero native `<select>` elements remain in service-type-select.tsx, add-job-sheet.tsx, edit-job-sheet.tsx
4. All three files import from `@/components/ui/select`
5. All three files use `onValueChange` (not `onChange`)
6. ServiceTypeSelect placeholder shows "Select service type..." when value is empty
7. Status fields show correct default values (not placeholder)
8. Custom service names render correctly for 'other' service type
</verification>

<success_criteria>
- All job form selects use Radix Select components
- onValueChange used everywhere (not onChange)
- Placeholder state works for ServiceTypeSelect (empty value shows "Select service type...")
- Status selects show current value (always have a default)
- Custom service names display correctly
- Form submission end-to-end works (values captured correctly)
- TypeScript and lint clean
</success_criteria>

<output>
After completion, create `.planning/phases/47-dashboard-right-panel-campaign-polish/47-04-SUMMARY.md`
</output>
