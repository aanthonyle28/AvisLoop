# Plan 08.1-01: Security and Performance Fixes

## Goal
Fix critical security issues and performance optimization identified in code review.

## Requirements Covered
- SEC-01: Stripe webhook rate limiting
- SEC-02: Service role client scope
- SEC-03: Env var validation
- SEC-04: localStorage validation
- PERF-01: Parallel DB queries

## Tasks

### Task 1: Add rate limiting to Stripe webhook (SEC-01)
**File:** `app/api/webhooks/stripe/route.ts`

Add in-memory rate limiting for failed signature verification attempts (same pattern as Resend webhook).

```typescript
// At top of file, after imports
const failedAttempts = new Map<string, { count: number; firstAttempt: number }>()
const RATE_LIMIT_WINDOW = 60 * 1000 // 1 minute
const MAX_FAILED_ATTEMPTS = 10

function checkRateLimit(ip: string): boolean {
  const now = Date.now()
  const record = failedAttempts.get(ip)

  if (!record || now - record.firstAttempt > RATE_LIMIT_WINDOW) {
    return true // Allow
  }

  return record.count < MAX_FAILED_ATTEMPTS
}

function recordFailedAttempt(ip: string): void {
  const now = Date.now()
  const record = failedAttempts.get(ip)

  if (!record || now - record.firstAttempt > RATE_LIMIT_WINDOW) {
    failedAttempts.set(ip, { count: 1, firstAttempt: now })
  } else {
    record.count++
  }
}
```

In POST handler, check rate limit before signature verification:
```typescript
const ip = headersList.get('x-forwarded-for')?.split(',')[0] || 'unknown'
if (!checkRateLimit(ip)) {
  return NextResponse.json({ error: 'Too many requests' }, { status: 429 })
}

// After signature verification fails:
recordFailedAttempt(ip)
```

### Task 2: Move service role client inside handler (SEC-02)
**File:** `app/api/webhooks/stripe/route.ts`

Move Supabase client creation inside POST handler to limit scope:

```typescript
// Remove module-level client (lines 8-11)

// Inside POST handler, after signature verification succeeds:
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
)
```

Pass `supabase` to handler functions as parameter.

### Task 3: Add env var validation for price IDs (SEC-03)
**File:** `app/(dashboard)/billing/page.tsx`

Add validation at top of component:

```typescript
// Before PLANS array
const basicPriceId = process.env.STRIPE_BASIC_PRICE_ID
const proPriceId = process.env.STRIPE_PRO_PRICE_ID

if (!basicPriceId || !proPriceId) {
  console.error('Missing Stripe price IDs in environment variables')
}

const PLANS = [
  {
    name: 'Basic',
    price: '$49',
    priceId: basicPriceId || '',
    // ...
  },
  // ...
]
```

### Task 4: Add Zod validation for localStorage data (SEC-04)
**File:** `components/onboarding/onboarding-wizard.tsx`

Add schema and validation:

```typescript
import { z } from 'zod'

const draftDataSchema = z.record(z.unknown()).catch({})

// In useEffect for loading:
const saved = localStorage.getItem(STORAGE_KEY)
if (saved) {
  try {
    const parsed = JSON.parse(saved)
    const validated = draftDataSchema.parse(parsed)
    setDraftDataState(validated)
  } catch (e) {
    console.error('Failed to parse onboarding draft:', e)
    localStorage.removeItem(STORAGE_KEY)
  }
}
```

### Task 5: Parallelize DB queries (PERF-01)
**File:** `lib/data/subscription.ts`

Refactor `getBusinessBillingInfo()` to use Promise.all:

```typescript
export async function getBusinessBillingInfo(): Promise<{...}> {
  const supabase = await createClient()

  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return { business: null, subscription: null, usage: { count: 0, limit: 0 }, contactCount: 0 }
  }

  // Fetch business first (needed for other queries)
  const { data: business } = await supabase
    .from('businesses')
    .select('id, tier, stripe_customer_id')
    .eq('user_id', user.id)
    .single()

  if (!business) {
    return { business: null, subscription: null, usage: { count: 0, limit: 0 }, contactCount: 0 }
  }

  // Run remaining queries in parallel
  const [subscriptionResult, usageData, contactCountResult] = await Promise.all([
    supabase
      .from('subscriptions')
      .select('*')
      .eq('business_id', business.id)
      .order('created_at', { ascending: false })
      .limit(1)
      .single(),
    getMonthlyUsage(),
    supabase
      .from('contacts')
      .select('*', { count: 'exact', head: true })
      .eq('business_id', business.id)
      .eq('status', 'active'),
  ])

  return {
    business: { id: business.id, tier: business.tier, stripe_customer_id: business.stripe_customer_id },
    subscription: subscriptionResult.data as Subscription | null,
    usage: { count: usageData.count, limit: usageData.limit },
    contactCount: contactCountResult.count ?? 0,
  }
}
```

## Verification

After implementation:
1. `pnpm lint` passes
2. `pnpm typecheck` passes
3. Stripe webhook still processes events correctly
4. Billing page loads without errors
5. Onboarding wizard draft persistence still works

## Files Modified

1. `app/api/webhooks/stripe/route.ts` - Rate limiting + client scope
2. `app/(dashboard)/billing/page.tsx` - Env var validation
3. `components/onboarding/onboarding-wizard.tsx` - Zod validation
4. `lib/data/subscription.ts` - Parallel queries
