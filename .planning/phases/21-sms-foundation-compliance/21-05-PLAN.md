---
phase: 21-sms-foundation-compliance
plan: 05
type: execute
wave: 4
depends_on: ["21-02", "21-04"]
files_modified:
  - lib/actions/send.ts
  - lib/actions/send-sms.action.ts
  - components/send/channel-selector.tsx
  - components/send/sms-character-counter.tsx
  - app/dashboard/send/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can toggle between email and SMS channel on /send page"
    - "SMS message preview shows character count with 160/320 thresholds"
    - "SMS sending only enabled for customers with sms_consent_status = 'opted_in'"
    - "SMS message includes review link from business.google_review_link"
    - "SMS fallback to email when customer has no phone or consent"
  artifacts:
    - path: "lib/actions/send-sms.action.ts"
      provides: "SMS send action with consent/quiet hours checks"
      exports: ["sendSmsRequest"]
    - path: "components/send/channel-selector.tsx"
      provides: "Email/SMS channel toggle component"
      exports: ["ChannelSelector"]
    - path: "components/send/sms-character-counter.tsx"
      provides: "SMS character counter with segment estimation"
      exports: ["SmsCharacterCounter"]
  key_links:
    - from: "lib/actions/send-sms.action.ts"
      to: "lib/sms/send-sms.ts"
      via: "sendSms import"
      pattern: "sendSms\\("
    - from: "lib/actions/send-sms.action.ts"
      to: "lib/sms/quiet-hours.ts"
      via: "checkQuietHours import"
      pattern: "checkQuietHours\\("
    - from: "app/dashboard/send/page.tsx"
      to: "components/send/channel-selector.tsx"
      via: "ChannelSelector import"
      pattern: "ChannelSelector"
---

<objective>
Implement SMS sending action and UI components for channel selection.

Purpose: Enable users to send SMS review requests from the /send page with channel toggle, character counter, consent validation, and quiet hours enforcement. Implement graceful fallback to email when customer lacks phone number.

Output:
- SMS send action with full validation (consent, quiet hours, phone presence)
- Channel selector component (email/SMS toggle)
- SMS character counter with segment estimation
- Updated /send page with SMS support
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-sms-foundation-compliance/21-RESEARCH.md
@.planning/phases/21-sms-foundation-compliance/21-02-SUMMARY.md
@.planning/phases/21-sms-foundation-compliance/21-04-SUMMARY.md
@lib/actions/send.ts
@lib/sms/send-sms.ts
@lib/sms/quiet-hours.ts
@lib/validations/sms.ts
@app/dashboard/send/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SMS send action with consent and quiet hours checks</name>
  <files>lib/actions/send-sms.action.ts</files>
  <action>
Create lib/actions/send-sms.action.ts for SMS-specific sending:

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import { sendSms } from '@/lib/sms/send-sms'
import { checkQuietHours } from '@/lib/sms/quiet-hours'
import { queueSmsRetry } from '@/lib/actions/sms-retry'
import { smsMessageSchema } from '@/lib/validations/sms'
import { checkSendRateLimit } from '@/lib/rate-limit'
import { MONTHLY_SEND_LIMITS } from '@/lib/constants/billing'

export type SmsActionState = {
  error?: string
  fieldErrors?: Record<string, string[]>
  success?: boolean
  queued?: boolean      // True if queued for quiet hours
  queuedFor?: string    // ISO timestamp when it will be sent
  data?: { sendLogId: string }
}

/**
 * Send an SMS review request to a customer.
 * Implements all business rules: auth, rate limit, consent, quiet hours, monthly limit.
 *
 * Flow:
 * 1. Authenticate user
 * 2. Rate limit check (per-user)
 * 3. Get business + customer + template
 * 4. Check customer has phone number (fallback info if not)
 * 5. Check SMS consent (must be 'opted_in')
 * 6. Check quiet hours (queue if outside 8am-9pm local)
 * 7. Check monthly limit
 * 8. Create send_log (channel: 'sms', status: 'pending')
 * 9. Send via Twilio (or queue for retry)
 * 10. Update send_log with result
 */
export async function sendSmsRequest(
  _prevState: SmsActionState | null,
  formData: FormData
): Promise<SmsActionState> {
  const supabase = await createClient()

  // === 1. Authenticate user ===
  const { data: { user }, error: authError } = await supabase.auth.getUser()
  if (authError || !user) {
    return { error: 'You must be logged in to send review requests' }
  }

  // === 2. Rate limit check ===
  const rateLimitResult = await checkSendRateLimit(user.id)
  if (!rateLimitResult.success) {
    return { error: 'Rate limit exceeded. Please wait before sending more messages.' }
  }

  // === Parse and validate input ===
  const parsed = smsMessageSchema.safeParse({
    body: formData.get('body'),
    customerId: formData.get('customerId'),
    templateId: formData.get('templateId') || undefined,
  })

  if (!parsed.success) {
    return { fieldErrors: parsed.error.flatten().fieldErrors }
  }

  const { body, customerId, templateId } = parsed.data

  // === 3. Get business ===
  const { data: business, error: businessError } = await supabase
    .from('businesses')
    .select('id, name, google_review_link, default_sender_name, tier')
    .eq('user_id', user.id)
    .single()

  if (businessError || !business) {
    return { error: 'Please create a business profile first' }
  }

  // === Get customer ===
  const { data: customer, error: customerError } = await supabase
    .from('customers')
    .select('id, name, email, phone, phone_status, status, sms_consent_status, timezone')
    .eq('id', customerId)
    .eq('business_id', business.id)
    .single()

  if (customerError || !customer) {
    return { error: 'Customer not found' }
  }

  // === 4. Check phone number ===
  if (!customer.phone || customer.phone_status !== 'valid') {
    return {
      error: `${customer.name} does not have a valid phone number. Use email instead.`
    }
  }

  // === 5. Check SMS consent (TCPA requirement) ===
  // Only customers with sms_consent_status = 'opted_in' can receive SMS
  if (customer.sms_consent_status !== 'opted_in') {
    return {
      error: `${customer.name} has not opted in to SMS messages. Update their consent status first.`
    }
  }

  if (customer.status === 'archived') {
    return { error: 'Cannot send to archived customers' }
  }

  // === 6. Check quiet hours ===
  const timezone = customer.timezone || 'America/New_York'
  const quietHoursCheck = checkQuietHours(timezone)

  // === 7. Check monthly limit ===
  const monthlyLimit = MONTHLY_SEND_LIMITS[business.tier] || MONTHLY_SEND_LIMITS.basic
  const { count: monthlyCount } = await getMonthlyCount(supabase, business.id)

  if (monthlyCount >= monthlyLimit) {
    return {
      error: `Monthly send limit reached (${monthlyLimit}). Upgrade your plan for more sends.`
    }
  }

  // === 8. Create send_log ===
  const { data: sendLog, error: logError } = await supabase
    .from('send_logs')
    .insert({
      business_id: business.id,
      contact_id: customerId,  // Legacy field
      customer_id: customerId,
      template_id: templateId || null,
      channel: 'sms',
      status: 'pending',
      subject: body,  // SMS body stored in subject field
    })
    .select('id')
    .single()

  if (logError || !sendLog) {
    return { error: 'Failed to create send log' }
  }

  // === Handle quiet hours - queue for later ===
  if (!quietHoursCheck.canSend) {
    await queueSmsRetry({
      sendLogId: sendLog.id,
      reason: 'quiet_hours',
      scheduledFor: quietHoursCheck.nextSendTime!,
    })

    revalidatePath('/dashboard')
    revalidatePath('/dashboard/send')

    return {
      success: true,
      queued: true,
      queuedFor: quietHoursCheck.nextSendTime!.toISOString(),
      data: { sendLogId: sendLog.id },
    }
  }

  // === 9. Send via Twilio ===
  // Body should include review link - caller must provide it in the message body
  // (typically interpolated from template or manually entered with business.google_review_link)
  const result = await sendSms({
    to: customer.phone,
    body,  // Must include review link from business.google_review_link
    businessId: business.id,
    customerId: customer.id,
    sendLogId: sendLog.id,
  })

  // === 10. Update send_log with result ===
  if (result.success) {
    await supabase
      .from('send_logs')
      .update({
        status: 'sent',
        provider_message_id: { twilio_sid: result.messageSid },
      })
      .eq('id', sendLog.id)

    // Update customer tracking fields
    await supabase
      .from('customers')
      .update({
        last_sent_at: new Date().toISOString(),
        send_count: (customer as any).send_count ? (customer as any).send_count + 1 : 1,
      })
      .eq('id', customerId)

    revalidatePath('/dashboard')
    revalidatePath('/dashboard/send')

    return { success: true, data: { sendLogId: sendLog.id } }
  }

  // === Handle failure - queue for retry if retryable ===
  await queueSmsRetry({
    sendLogId: sendLog.id,
    reason: 'twilio_error',
    error: result.error,
  })

  revalidatePath('/dashboard')
  revalidatePath('/dashboard/send')

  return {
    error: `Failed to send SMS: ${result.error}. Message queued for retry.`,
    data: { sendLogId: sendLog.id },
  }
}

async function getMonthlyCount(
  supabase: Awaited<ReturnType<typeof createClient>>,
  businessId: string
): Promise<{ count: number }> {
  const startOfMonth = new Date()
  startOfMonth.setDate(1)
  startOfMonth.setHours(0, 0, 0, 0)

  const { count } = await supabase
    .from('send_logs')
    .select('*', { count: 'exact', head: true })
    .eq('business_id', businessId)
    .gte('created_at', startOfMonth.toISOString())
    .in('status', ['sent', 'delivered', 'opened'])

  return { count: count || 0 }
}
```

Key compliance points:
- MUST check sms_consent_status === 'opted_in' before sending
- Queue for quiet hours instead of rejecting
- Queue for retry on transient failures
- Track channel: 'sms' in send_log
  </action>
  <verify>
Run `pnpm typecheck` - no errors
Export test: sendSmsRequest accessible from '@/lib/actions/send-sms.action'
  </verify>
  <done>
SMS send action with consent checking, quiet hours queueing, retry on failure, and monthly quota enforcement.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SMS character counter component</name>
  <files>components/send/sms-character-counter.tsx</files>
  <action>
Create components/send/sms-character-counter.tsx:

```typescript
'use client'

import { GSM7_LIMIT, SMS_SOFT_LIMIT, estimateSegments } from '@/lib/validations/sms'
import { cn } from '@/lib/utils'

interface SmsCharacterCounterProps {
  text: string
  className?: string
}

/**
 * SMS character counter with segment estimation.
 * Shows character count and estimated SMS segments.
 *
 * Thresholds:
 * - 0-160: Green (single segment)
 * - 161-320: Yellow warning (2 segments)
 * - 320+: Red warning (3+ segments, may be blocked)
 */
export function SmsCharacterCounter({ text, className }: SmsCharacterCounterProps) {
  const length = text.length
  const segments = estimateSegments(text)
  const remaining = GSM7_LIMIT - length

  const isOverSingle = length > GSM7_LIMIT
  const isOverSoft = length > SMS_SOFT_LIMIT

  return (
    <div className={cn('flex items-center gap-2 text-sm', className)}>
      <span
        className={cn(
          'tabular-nums',
          isOverSoft
            ? 'text-red-600 dark:text-red-400 font-medium'
            : isOverSingle
              ? 'text-amber-600 dark:text-amber-400'
              : 'text-muted-foreground'
        )}
      >
        {length}/{GSM7_LIMIT}
      </span>

      {isOverSingle && (
        <>
          <span className="text-muted-foreground">â€¢</span>
          <span
            className={cn(
              isOverSoft
                ? 'text-red-600 dark:text-red-400'
                : 'text-amber-600 dark:text-amber-400'
            )}
          >
            {segments} segment{segments > 1 ? 's' : ''}
          </span>
        </>
      )}

      {!isOverSingle && remaining >= 0 && (
        <span className="text-muted-foreground">
          ({remaining} remaining)
        </span>
      )}
    </div>
  )
}

/**
 * SMS character limit notice shown below textarea.
 */
export function SmsCharacterNotice({ length }: { length: number }) {
  const isOverSingle = length > GSM7_LIMIT
  const isOverSoft = length > SMS_SOFT_LIMIT

  if (!isOverSingle) return null

  return (
    <p
      className={cn(
        'text-sm mt-1',
        isOverSoft ? 'text-red-600 dark:text-red-400' : 'text-amber-600 dark:text-amber-400'
      )}
    >
      {isOverSoft
        ? 'Message exceeds recommended limit. Consider shortening to avoid delivery issues.'
        : 'Message will be split into multiple SMS (higher cost).'}
    </p>
  )
}
```

Design decisions:
- Simple length-based counting (not GSM-7 encoding detection - deferred)
- Color coding: green (single), yellow (2 segments), red (3+)
- Clear feedback on cost implications
  </action>
  <verify>
Run `pnpm typecheck` - no errors
Run `pnpm lint` - no errors
  </verify>
  <done>
SMS character counter with segment estimation, color-coded thresholds, and cost warning notices.
  </done>
</task>

<task type="auto">
  <name>Task 3a: Create ChannelSelector component</name>
  <files>components/send/channel-selector.tsx</files>
  <action>
Create components/send/channel-selector.tsx:

```typescript
'use client'

import { Tabs, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { Envelope, ChatCircle } from '@phosphor-icons/react'

interface ChannelSelectorProps {
  value: 'email' | 'sms'
  onChange: (channel: 'email' | 'sms') => void
  disabled?: boolean
  smsDisabled?: boolean
  smsDisabledReason?: string
}

/**
 * Channel selector toggle for email/SMS.
 * Shows SMS as disabled with reason when customer lacks phone or consent.
 * SMS is disabled when:
 * - Customer has no valid phone number
 * - Customer sms_consent_status !== 'opted_in'
 */
export function ChannelSelector({
  value,
  onChange,
  disabled,
  smsDisabled,
  smsDisabledReason,
}: ChannelSelectorProps) {
  return (
    <div className="space-y-1">
      <Tabs
        value={value}
        onValueChange={(v) => onChange(v as 'email' | 'sms')}
      >
        <TabsList className="grid w-full grid-cols-2">
          <TabsTrigger value="email" disabled={disabled} className="gap-2">
            <Envelope className="h-4 w-4" />
            Email
          </TabsTrigger>
          <TabsTrigger
            value="sms"
            disabled={disabled || smsDisabled}
            className="gap-2"
          >
            <ChatCircle className="h-4 w-4" />
            SMS
          </TabsTrigger>
        </TabsList>
      </Tabs>

      {smsDisabled && smsDisabledReason && (
        <p className="text-sm text-muted-foreground">{smsDisabledReason}</p>
      )}
    </div>
  )
}
```
  </action>
  <verify>
Run `pnpm typecheck` - no errors
Run `pnpm lint` - no errors
  </verify>
  <done>
ChannelSelector component created with email/SMS toggle, disabled state support, and reason text display.
  </done>
</task>

<task type="auto">
  <name>Task 3b: Integrate channel selection into send page</name>
  <files>app/dashboard/send/page.tsx</files>
  <action>
Update app/dashboard/send/page.tsx (or the relevant send form component):

1. Add channel state (default: 'email')
2. Show ChannelSelector when a customer is selected
3. Determine if SMS is available for selected customer:
   - Has valid phone number (phone_status === 'valid')
   - Has sms_consent_status === 'opted_in'
4. Show SmsCharacterCounter when channel is 'sms'
5. Use sendSmsRequest action when channel is 'sms'
6. Handle queued response (show toast with scheduled time)
7. Ensure SMS body includes review link (business.google_review_link)

Integration points (7 total):
1. Import ChannelSelector and SmsCharacterCounter components
2. Add channel state: `const [channel, setChannel] = useState<'email' | 'sms'>('email')`
3. Compute SMS availability when customer selected:
   ```typescript
   const canSendSms = customer?.phone_status === 'valid' && customer?.sms_consent_status === 'opted_in'
   const smsDisabledReason = !customer?.phone ? 'Customer has no phone number' :
     customer?.phone_status !== 'valid' ? 'Phone number is invalid' :
     customer?.sms_consent_status !== 'opted_in' ? 'Customer has not opted in to SMS' : undefined
   ```
4. Add ChannelSelector above message input, passing computed props
5. Conditionally show SmsCharacterCounter when channel === 'sms'
6. Switch action based on channel: `channel === 'sms' ? sendSmsRequest : sendReviewRequest`
7. Handle queued response: `if (result.queued) { toast(`SMS queued for ${new Date(result.queuedFor).toLocaleTimeString()}`) }`

For SMS messages, ensure the message body includes the review link (either via template interpolation or explicit inclusion from business.google_review_link).
  </action>
  <verify>
Run `pnpm typecheck` - no errors
Run `pnpm lint` - no errors
Navigate to /dashboard/send - channel selector visible
Select customer with phone AND sms_consent_status='opted_in' - SMS tab enabled
Select customer without phone - SMS tab disabled with reason "Customer has no phone number"
Select customer with phone but sms_consent_status !== 'opted_in' - SMS tab disabled with reason "Customer has not opted in to SMS"
Switch to SMS channel - character counter appears
  </verify>
  <done>
Send page integrates channel selection with:
- ChannelSelector showing disabled states based on phone/consent
- SmsCharacterCounter for SMS messages
- Action switching between email and SMS
- Queued response handling with toast notification
  </done>
</task>

</tasks>

<verification>
1. Run `pnpm typecheck` - all files pass
2. Run `pnpm lint` - no lint errors
3. Navigate to /dashboard/send
4. Select customer with valid phone and SMS consent - SMS tab enabled
5. Select customer without phone - SMS tab disabled with reason
6. Switch to SMS channel - character counter appears
7. Type message - character count updates with color feedback
</verification>

<success_criteria>
- Channel selector toggles between email and SMS
- SMS disabled when customer lacks phone or consent
- Character counter shows count, remaining, and segment estimate
- Color feedback: green (single), yellow (2 segments), red (3+)
- SMS send action checks consent and queues for quiet hours
- Fallback to email clearly communicated when SMS unavailable
- All lint and typecheck passing
</success_criteria>

<output>
After completion, create `.planning/phases/21-sms-foundation-compliance/21-05-SUMMARY.md`
</output>
