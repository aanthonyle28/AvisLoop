---
phase: 21-sms-foundation-compliance
plan: 03
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - app/api/webhooks/twilio/inbound/route.ts
  - app/api/webhooks/twilio/status/route.ts
  - lib/sms/webhook-validation.ts
autonomous: true

must_haves:
  truths:
    - "STOP/STOPALL/UNSUBSCRIBE/CANCEL/END/QUIT replies update customer sms_consent_status to opted_out"
    - "Invalid webhook signatures are rejected with 403 status"
    - "Delivery status updates (delivered/failed) update send_logs status"
  artifacts:
    - path: "app/api/webhooks/twilio/inbound/route.ts"
      provides: "STOP keyword handling webhook"
      exports: ["POST"]
    - path: "app/api/webhooks/twilio/status/route.ts"
      provides: "Delivery status webhook"
      exports: ["POST"]
    - path: "lib/sms/webhook-validation.ts"
      provides: "Twilio signature validation helper"
      exports: ["validateTwilioRequest"]
  key_links:
    - from: "app/api/webhooks/twilio/inbound/route.ts"
      to: "lib/sms/webhook-validation.ts"
      via: "validateTwilioRequest import"
      pattern: "validateTwilioRequest"
    - from: "lib/sms/webhook-validation.ts"
      to: "twilio SDK"
      via: "twilio.validateRequest"
      pattern: "twilio\\.validateRequest"
---

<objective>
Implement Twilio webhook endpoints for STOP keyword handling and delivery status updates.

Purpose: Handle inbound SMS replies (STOP keywords for opt-out) and delivery status callbacks (delivered/failed). Both endpoints verify Twilio signatures to prevent forgery.

Output:
- Inbound webhook that handles STOP keywords and updates customer consent
- Status webhook that updates send_logs with delivery status
- Shared validation helper using twilio.validateRequest
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-sms-foundation-compliance/21-RESEARCH.md
@.planning/phases/21-sms-foundation-compliance/21-01-SUMMARY.md
@lib/sms/twilio.ts
@lib/supabase/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Twilio webhook signature validation helper</name>
  <files>lib/sms/webhook-validation.ts</files>
  <action>
Create lib/sms/webhook-validation.ts for shared signature validation:

```typescript
import twilio from 'twilio'

const authToken = process.env.TWILIO_AUTH_TOKEN

/**
 * Validate Twilio webhook request signature.
 * CRITICAL: Always validate to prevent forgery attacks.
 *
 * @param signature - X-Twilio-Signature header value
 * @param url - Full webhook URL (must match exactly what Twilio sees)
 * @param params - Parsed URL-encoded body parameters
 * @returns true if signature is valid
 */
export function validateTwilioRequest(
  signature: string,
  url: string,
  params: Record<string, string>
): boolean {
  if (!authToken) {
    console.error('TWILIO_AUTH_TOKEN not configured')
    return false
  }

  return twilio.validateRequest(authToken, signature, url, params)
}

/**
 * Parse URL-encoded form body into params object.
 * Twilio sends webhooks as application/x-www-form-urlencoded.
 */
export function parseWebhookBody(body: string): Record<string, string> {
  const params: Record<string, string> = {}
  const searchParams = new URLSearchParams(body)
  searchParams.forEach((value, key) => {
    params[key] = value
  })
  return params
}

/**
 * Build webhook URL from request for signature validation.
 * Uses NEXT_PUBLIC_SITE_URL to ensure URL matches what Twilio sees.
 *
 * IMPORTANT: URL must match exactly (protocol, host, path, no trailing slash)
 */
export function buildWebhookUrl(pathname: string): string {
  const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000'
  return `${baseUrl}${pathname}`
}
```

Key points from research:
- Signature validation MUST use the exact URL Twilio sees (NEXT_PUBLIC_SITE_URL)
- Behind proxy/CDN, internal URL won't match - use public URL
- URL encoding edge cases are handled by twilio.validateRequest
  </action>
  <verify>
Run `pnpm typecheck` - no errors
Export test: validateTwilioRequest, parseWebhookBody, buildWebhookUrl all accessible
  </verify>
  <done>
Webhook validation helper created with signature verification, body parsing, and URL construction. Uses twilio.validateRequest for secure signature checking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create inbound webhook for STOP keyword handling</name>
  <files>app/api/webhooks/twilio/inbound/route.ts</files>
  <action>
Create app/api/webhooks/twilio/inbound/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import {
  validateTwilioRequest,
  parseWebhookBody,
  buildWebhookUrl,
} from '@/lib/sms/webhook-validation'

// STOP keywords per TCPA requirements
const STOP_KEYWORDS = [
  'STOP',
  'STOPALL',
  'UNSUBSCRIBE',
  'CANCEL',
  'END',
  'QUIT',
]

export async function POST(request: NextRequest) {
  // 1. Get raw body and signature
  const body = await request.text()
  const signature = request.headers.get('X-Twilio-Signature')

  if (!signature) {
    console.error('Missing Twilio signature header')
    return NextResponse.json({ error: 'Missing signature' }, { status: 403 })
  }

  // 2. Parse body and validate signature
  const params = parseWebhookBody(body)
  const url = buildWebhookUrl('/api/webhooks/twilio/inbound')
  const isValid = validateTwilioRequest(signature, url, params)

  if (!isValid) {
    console.error('Invalid Twilio webhook signature')
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
  }

  // 3. Extract message details
  const { Body, From, OptOutType } = params

  // 4. Handle STOP keywords
  // Twilio may send OptOutType='STOP' for standard keywords
  // We also check message body for informal variants
  const normalizedBody = (Body || '').trim().toUpperCase()
  const isStop =
    OptOutType === 'STOP' ||
    STOP_KEYWORDS.includes(normalizedBody) ||
    normalizedBody.includes('STOP') ||
    normalizedBody.includes('UNSUBSCRIBE')

  if (isStop && From) {
    await handleOptOut(From)
    console.log(`Opt-out processed for phone: ${From.slice(-4)}`)
  }

  // Twilio expects 200 response (even for non-STOP messages)
  return NextResponse.json({ success: true })
}

/**
 * Update customer SMS consent status to opted_out.
 * TCPA requires immediate processing (within 5 minutes).
 *
 * NOTE: Updates ALL customers with matching phone number.
 * This is intentional - if dad and son share a phone, both should opt out.
 */
async function handleOptOut(phoneNumber: string) {
  const supabase = await createClient()

  const { error, count } = await supabase
    .from('customers')
    .update({
      sms_consent_status: 'opted_out',
      sms_consent_at: new Date().toISOString(),
      sms_consent_source: 'sms_reply_stop',
      sms_consent_method: 'phone_call', // Reply via phone
    })
    .eq('phone', phoneNumber)

  if (error) {
    console.error('Failed to update opt-out status:', error)
  } else {
    console.log(`Updated ${count || 'unknown'} customer(s) to opted_out`)
  }
}
```

Key compliance points:
- Handles all TCPA-required STOP keywords
- Also handles informal variants (message contains STOP/UNSUBSCRIBE)
- Updates ALL matching phone numbers (phone collision safety)
- Logs opt-out but masks phone number (last 4 digits only)
  </action>
  <verify>
Run `pnpm typecheck` - no errors
Run `pnpm lint` - no errors
Verify route exists: app/api/webhooks/twilio/inbound/route.ts
  </verify>
  <done>
Inbound webhook handles STOP keywords, validates Twilio signature, updates customer sms_consent_status to opted_out with audit trail.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create status webhook for delivery updates</name>
  <files>app/api/webhooks/twilio/status/route.ts</files>
  <action>
Create app/api/webhooks/twilio/status/route.ts:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import {
  validateTwilioRequest,
  parseWebhookBody,
  buildWebhookUrl,
} from '@/lib/sms/webhook-validation'

// Twilio status values mapped to our send_logs status
// Reference: https://www.twilio.com/docs/messaging/guides/outbound-message-logging
const STATUS_MAP: Record<string, string> = {
  queued: 'pending',      // Message queued
  sending: 'pending',     // Message being sent
  sent: 'sent',           // Message sent to carrier
  delivered: 'delivered', // Delivery confirmed
  undelivered: 'failed',  // Message failed to deliver
  failed: 'failed',       // Message failed
  read: 'opened',         // Message read (WhatsApp only, not SMS)
}

// Valid status transitions (prevent out-of-order webhooks from corrupting state)
// e.g., if we already have 'delivered', don't downgrade to 'sent'
const STATUS_PRIORITY: Record<string, number> = {
  pending: 0,
  sent: 1,
  delivered: 2,
  opened: 3,
  failed: 99, // Terminal state
}

export async function POST(request: NextRequest) {
  // 1. Get raw body and signature
  const body = await request.text()
  const signature = request.headers.get('X-Twilio-Signature')

  if (!signature) {
    console.error('Missing Twilio signature header')
    return NextResponse.json({ error: 'Missing signature' }, { status: 403 })
  }

  // 2. Parse body and validate signature
  const params = parseWebhookBody(body)
  const url = buildWebhookUrl('/api/webhooks/twilio/status')
  const isValid = validateTwilioRequest(signature, url, params)

  if (!isValid) {
    console.error('Invalid Twilio webhook signature')
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
  }

  // 3. Extract status details
  const {
    MessageSid,
    MessageStatus,
    ErrorCode,
    ErrorMessage,
  } = params

  if (!MessageSid || !MessageStatus) {
    console.error('Missing MessageSid or MessageStatus')
    return NextResponse.json({ error: 'Missing required fields' }, { status: 400 })
  }

  // 4. Map Twilio status to our status
  const newStatus = STATUS_MAP[MessageStatus.toLowerCase()] || 'pending'

  // 5. Update send_log
  await updateSendLog(MessageSid, newStatus, ErrorCode, ErrorMessage)

  return NextResponse.json({ success: true })
}

/**
 * Update send_log status from Twilio webhook.
 * Uses provider_message_id JSONB to find the record.
 * Respects status priority to handle out-of-order webhooks.
 */
async function updateSendLog(
  messageSid: string,
  newStatus: string,
  errorCode?: string,
  errorMessage?: string
) {
  const supabase = await createClient()

  // Find send_log by Twilio message SID in provider_message_id JSONB
  const { data: sendLog, error: findError } = await supabase
    .from('send_logs')
    .select('id, status')
    .eq('provider_message_id->>twilio_sid', messageSid)
    .single()

  if (findError || !sendLog) {
    // Try legacy provider_id column (during migration window)
    console.warn(`Send log not found for SID: ${messageSid}, checking legacy column`)
    return
  }

  // Check status priority (don't downgrade)
  const currentPriority = STATUS_PRIORITY[sendLog.status] ?? 0
  const newPriority = STATUS_PRIORITY[newStatus] ?? 0

  if (newPriority <= currentPriority && newStatus !== 'failed') {
    console.log(`Skipping status update: ${sendLog.status} -> ${newStatus} (priority check)`)
    return
  }

  // Update send_log
  const updateData: Record<string, unknown> = {
    status: newStatus,
  }

  if (errorCode || errorMessage) {
    updateData.error_message = errorMessage || `Error code: ${errorCode}`
  }

  const { error: updateError } = await supabase
    .from('send_logs')
    .update(updateData)
    .eq('id', sendLog.id)

  if (updateError) {
    console.error('Failed to update send_log status:', updateError)
  } else {
    console.log(`Updated send_log ${sendLog.id} status: ${sendLog.status} -> ${newStatus}`)
  }
}
```

Key design decisions:
- Maps Twilio statuses to our send_logs status values
- Uses status priority to handle out-of-order webhooks
- Queries by provider_message_id->>'twilio_sid' (new JSONB field)
- Includes error handling for migration window (legacy provider_id)
  </action>
  <verify>
Run `pnpm typecheck` - no errors
Run `pnpm lint` - no errors
Verify route exists: app/api/webhooks/twilio/status/route.ts
  </verify>
  <done>
Status webhook updates send_logs with delivery status, validates Twilio signature, handles out-of-order webhooks with status priority checks.
  </done>
</task>

</tasks>

<verification>
1. Run `pnpm typecheck` - all files pass
2. Run `pnpm lint` - no lint errors
3. Verify directory structure: app/api/webhooks/twilio/inbound/route.ts and app/api/webhooks/twilio/status/route.ts exist
4. Verify helper: lib/sms/webhook-validation.ts exists with exports
</verification>

<success_criteria>
- Inbound webhook validates signature and rejects invalid requests with 403
- Inbound webhook handles STOP/STOPALL/UNSUBSCRIBE/CANCEL/END/QUIT keywords
- Inbound webhook updates customer sms_consent_status to opted_out
- Status webhook validates signature and rejects invalid requests with 403
- Status webhook updates send_logs status (delivered/failed)
- Status webhook respects status priority (no downgrades)
- All lint and typecheck passing
</success_criteria>

<output>
After completion, create `.planning/phases/21-sms-foundation-compliance/21-03-SUMMARY.md`
</output>
