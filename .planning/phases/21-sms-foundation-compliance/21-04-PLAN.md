---
phase: 21-sms-foundation-compliance
plan: 04
type: execute
wave: 3
depends_on: ["21-02", "21-03"]
files_modified:
  - lib/actions/sms-retry.ts
  - app/api/cron/process-sms-retries/route.ts
  - vercel.json
autonomous: true

must_haves:
  truths:
    - "Failed SMS sends are queued for retry with exponential backoff (1min, 5min, 15min)"
    - "Quiet hours delays queue SMS for next 8am local time"
    - "Max 3 retry attempts before marking as failed"
    - "Cron job processes retry queue using claim_due_sms_retries RPC"
  artifacts:
    - path: "lib/actions/sms-retry.ts"
      provides: "SMS retry queue management functions"
      exports: ["queueSmsRetry", "processSmsRetryItem"]
    - path: "app/api/cron/process-sms-retries/route.ts"
      provides: "Cron handler for processing SMS retry queue"
      exports: ["GET"]
  key_links:
    - from: "lib/actions/sms-retry.ts"
      to: "lib/sms/send-sms.ts"
      via: "sendSms import"
      pattern: "sendSms\\("
    - from: "app/api/cron/process-sms-retries/route.ts"
      to: "lib/actions/sms-retry.ts"
      via: "processSmsRetryItem import"
      pattern: "processSmsRetryItem"
---

<objective>
Implement SMS retry queue processing with exponential backoff.

Purpose: Handle transient failures (Twilio down, rate limits) with exponential backoff retries. Queue SMS sends delayed by quiet hours for next available window. Ensure no message is lost due to temporary failures.

Output:
- Retry queue management functions (queue, process)
- Cron endpoint for processing retry queue
- Vercel cron configuration
</objective>

<execution_context>
@C:\Users\aanth\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\aanth\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-sms-foundation-compliance/21-RESEARCH.md
@.planning/phases/21-sms-foundation-compliance/21-01-SUMMARY.md
@.planning/phases/21-sms-foundation-compliance/21-02-SUMMARY.md
@lib/sms/send-sms.ts
@lib/sms/quiet-hours.ts
@lib/sms/types.ts
@app/api/cron/process-scheduled-sends/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SMS retry queue management functions</name>
  <files>lib/actions/sms-retry.ts</files>
  <action>
Create lib/actions/sms-retry.ts with retry queue management:

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { sendSms, isRetryableError } from '@/lib/sms/send-sms'
import { checkQuietHours } from '@/lib/sms/quiet-hours'
import type { SmsRetryReason, SmsRetryQueueItem } from '@/lib/sms/types'

// Exponential backoff delays in minutes: 1, 5, 15
const RETRY_DELAYS = [1, 5, 15]
const MAX_ATTEMPTS = 3

/**
 * Queue an SMS for retry with exponential backoff.
 * Used when:
 * - Twilio API fails with retryable error
 * - Rate limit exceeded
 * - Message delayed due to quiet hours
 *
 * @param params.sendLogId - The send_log ID to retry
 * @param params.reason - Why the retry is needed
 * @param params.attemptCount - Current attempt number (0-based)
 * @param params.scheduledFor - Override schedule time (for quiet hours)
 * @param params.error - Error message from previous attempt
 */
export async function queueSmsRetry(params: {
  sendLogId: string
  reason: SmsRetryReason
  attemptCount?: number
  scheduledFor?: Date
  error?: string
}): Promise<{ success: boolean; error?: string }> {
  const supabase = await createClient()

  const attemptCount = params.attemptCount || 0

  // Check max attempts (except for quiet_hours which resets on new window)
  if (params.reason !== 'quiet_hours' && attemptCount >= MAX_ATTEMPTS) {
    // Mark send_log as failed
    await supabase
      .from('send_logs')
      .update({
        status: 'failed',
        error_message: params.error || 'Max retry attempts exceeded',
      })
      .eq('id', params.sendLogId)

    return { success: false, error: 'Max retry attempts exceeded' }
  }

  // Get send_log to extract business_id and customer_id
  const { data: sendLog, error: fetchError } = await supabase
    .from('send_logs')
    .select('business_id, customer_id')
    .eq('id', params.sendLogId)
    .single()

  if (fetchError || !sendLog) {
    console.error('Failed to fetch send_log for retry:', fetchError)
    return { success: false, error: 'Send log not found' }
  }

  // Calculate scheduled time
  let scheduledFor: Date
  if (params.scheduledFor) {
    scheduledFor = params.scheduledFor
  } else {
    // Exponential backoff: 1min, 5min, 15min
    const delayMinutes = RETRY_DELAYS[attemptCount] || RETRY_DELAYS[RETRY_DELAYS.length - 1]
    scheduledFor = new Date()
    scheduledFor.setMinutes(scheduledFor.getMinutes() + delayMinutes)
  }

  // Insert into retry queue
  const { error: insertError } = await supabase.from('sms_retry_queue').insert({
    business_id: sendLog.business_id,
    send_log_id: params.sendLogId,
    customer_id: sendLog.customer_id,
    attempt_count: attemptCount,
    max_attempts: MAX_ATTEMPTS,
    scheduled_for: scheduledFor.toISOString(),
    reason: params.reason,
    last_error: params.error || null,
  })

  if (insertError) {
    console.error('Failed to queue SMS retry:', insertError)
    return { success: false, error: 'Failed to queue retry' }
  }

  console.log(`Queued SMS retry for send_log ${params.sendLogId}, attempt ${attemptCount + 1}, scheduled for ${scheduledFor.toISOString()}`)
  return { success: true }
}

/**
 * Process a single SMS retry queue item.
 * Called by cron job after claiming with FOR UPDATE SKIP LOCKED.
 */
export async function processSmsRetryItem(
  retry: SmsRetryQueueItem
): Promise<{ success: boolean; shouldRequeue: boolean; error?: string }> {
  const supabase = await createClient()

  // Get customer for phone and timezone
  const { data: customer, error: customerError } = await supabase
    .from('customers')
    .select('phone, timezone, sms_consent_status')
    .eq('id', retry.customer_id)
    .single()

  if (customerError || !customer) {
    await markRetryFailed(supabase, retry.id, 'Customer not found')
    return { success: false, shouldRequeue: false, error: 'Customer not found' }
  }

  // Check consent (customer may have opted out since queueing)
  if (customer.sms_consent_status !== 'opted_in') {
    await markRetryFailed(supabase, retry.id, 'Customer opted out')
    await supabase
      .from('send_logs')
      .update({ status: 'failed', error_message: 'Customer opted out' })
      .eq('id', retry.send_log_id)
    return { success: false, shouldRequeue: false, error: 'Customer opted out' }
  }

  // Check quiet hours
  const quietHoursCheck = checkQuietHours(customer.timezone || 'America/New_York')
  if (!quietHoursCheck.canSend) {
    // Reschedule for next window
    await supabase
      .from('sms_retry_queue')
      .update({
        status: 'pending',
        scheduled_for: quietHoursCheck.nextSendTime!.toISOString(),
        reason: 'quiet_hours',
      })
      .eq('id', retry.id)

    return { success: false, shouldRequeue: false, error: 'Rescheduled for quiet hours' }
  }

  // Get send_log for message content
  const { data: sendLog, error: sendLogError } = await supabase
    .from('send_logs')
    .select('subject')
    .eq('id', retry.send_log_id)
    .single()

  if (sendLogError || !sendLog) {
    await markRetryFailed(supabase, retry.id, 'Send log not found')
    return { success: false, shouldRequeue: false, error: 'Send log not found' }
  }

  // Attempt to send SMS
  const result = await sendSms({
    to: customer.phone!,
    body: sendLog.subject, // Subject field used for SMS body
    businessId: retry.business_id,
    customerId: retry.customer_id,
    sendLogId: retry.send_log_id,
  })

  if (result.success) {
    // Mark retry as completed
    await supabase
      .from('sms_retry_queue')
      .update({ status: 'completed' })
      .eq('id', retry.id)

    // Update send_log
    await supabase
      .from('send_logs')
      .update({
        status: 'sent',
        provider_message_id: { twilio_sid: result.messageSid },
      })
      .eq('id', retry.send_log_id)

    return { success: true, shouldRequeue: false }
  }

  // Send failed
  const newAttemptCount = retry.attempt_count + 1

  // Check if error is retryable
  if (!isRetryableError(result.errorCode) || newAttemptCount >= MAX_ATTEMPTS) {
    // Permanent failure or max attempts
    await markRetryFailed(supabase, retry.id, result.error)
    await supabase
      .from('send_logs')
      .update({ status: 'failed', error_message: result.error })
      .eq('id', retry.send_log_id)

    return { success: false, shouldRequeue: false, error: result.error }
  }

  // Queue next retry
  await queueSmsRetry({
    sendLogId: retry.send_log_id,
    reason: 'twilio_error',
    attemptCount: newAttemptCount,
    error: result.error,
  })

  // Mark current retry as failed (new one queued)
  await markRetryFailed(supabase, retry.id, result.error)

  return { success: false, shouldRequeue: false, error: result.error }
}

async function markRetryFailed(
  supabase: Awaited<ReturnType<typeof createClient>>,
  retryId: string,
  error?: string
) {
  await supabase
    .from('sms_retry_queue')
    .update({
      status: 'failed',
      last_error: error || null,
      last_attempted_at: new Date().toISOString(),
    })
    .eq('id', retryId)
}
```

Key design decisions:
- Exponential backoff: 1min, 5min, 15min (matches research)
- Max 3 attempts before permanent failure
- Quiet hours reschedule uses next 8am window
- Checks consent before each retry (customer may have opted out)
- Uses isRetryableError to distinguish permanent vs transient failures
  </action>
  <verify>
Run `pnpm typecheck` - no errors
Export test: queueSmsRetry and processSmsRetryItem accessible
  </verify>
  <done>
SMS retry queue management with exponential backoff (1/5/15 min), quiet hours rescheduling, consent rechecking, and permanent vs transient error handling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create cron endpoint for processing SMS retries</name>
  <files>app/api/cron/process-sms-retries/route.ts</files>
  <action>
Create app/api/cron/process-sms-retries/route.ts following the scheduled_sends pattern:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { processSmsRetryItem } from '@/lib/actions/sms-retry'
import type { SmsRetryQueueItem } from '@/lib/sms/types'

// Vercel cron authorization header
const CRON_SECRET = process.env.CRON_SECRET

/**
 * Process SMS retry queue.
 * Called by Vercel cron every 1 minute.
 *
 * Uses claim_due_sms_retries() RPC with FOR UPDATE SKIP LOCKED
 * to prevent race conditions between concurrent invocations.
 */
export async function GET(request: NextRequest) {
  // Verify cron secret (if configured)
  const authHeader = request.headers.get('Authorization')
  if (CRON_SECRET && authHeader !== `Bearer ${CRON_SECRET}`) {
    console.error('Invalid cron authorization')
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const startTime = Date.now()
  const supabase = await createClient()

  try {
    // 1. Recover stuck retries (processing > 10 minutes)
    const { data: recovered } = await supabase.rpc('recover_stuck_sms_retries', {
      stale_minutes: 10,
    })

    if (recovered && recovered.length > 0) {
      console.log(`Recovered ${recovered.length} stuck SMS retries`)
    }

    // 2. Claim due retries (atomic with SKIP LOCKED)
    const { data: retries, error: claimError } = await supabase.rpc('claim_due_sms_retries', {
      limit_count: 50,
    })

    if (claimError) {
      console.error('Failed to claim SMS retries:', claimError)
      return NextResponse.json({ error: 'Claim failed' }, { status: 500 })
    }

    if (!retries || retries.length === 0) {
      return NextResponse.json({
        processed: 0,
        success: 0,
        failed: 0,
        duration: Date.now() - startTime,
      })
    }

    console.log(`Claimed ${retries.length} SMS retries for processing`)

    // 3. Process each retry
    let successCount = 0
    let failedCount = 0

    for (const retry of retries as SmsRetryQueueItem[]) {
      try {
        const result = await processSmsRetryItem(retry)
        if (result.success) {
          successCount++
        } else {
          failedCount++
        }
      } catch (error) {
        console.error(`Error processing retry ${retry.id}:`, error)
        failedCount++

        // Mark as failed to prevent infinite loop
        await supabase
          .from('sms_retry_queue')
          .update({
            status: 'failed',
            last_error: error instanceof Error ? error.message : 'Unknown error',
          })
          .eq('id', retry.id)
      }
    }

    const duration = Date.now() - startTime
    console.log(`SMS retry cron complete: ${successCount} success, ${failedCount} failed, ${duration}ms`)

    return NextResponse.json({
      processed: retries.length,
      success: successCount,
      failed: failedCount,
      duration,
    })
  } catch (error) {
    console.error('SMS retry cron error:', error)
    return NextResponse.json({ error: 'Internal error' }, { status: 500 })
  }
}
```

Key patterns from scheduled_sends cron:
- Recover stuck processing items first
- Atomic claim with FOR UPDATE SKIP LOCKED
- Process each item with error handling
- Mark failed on unhandled exception
- Return stats for monitoring
  </action>
  <verify>
Run `pnpm typecheck` - no errors
Verify route exists: app/api/cron/process-sms-retries/route.ts
Verify GET handler exported
  </verify>
  <done>
Cron endpoint processes SMS retry queue using claim_due_sms_retries RPC, recovers stuck items, handles errors gracefully, returns processing stats.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update vercel.json with SMS retry cron</name>
  <files>vercel.json</files>
  <action>
Update vercel.json to add SMS retry cron job running every minute:

Check if vercel.json exists. If not, create it.

Add crons entry (or append to existing):
```json
{
  "crons": [
    {
      "path": "/api/cron/process-scheduled-sends",
      "schedule": "* * * * *"
    },
    {
      "path": "/api/cron/process-sms-retries",
      "schedule": "* * * * *"
    }
  ]
}
```

NOTE: If vercel.json already exists with other crons, APPEND the new cron entry to the existing array. Do not overwrite.
  </action>
  <verify>
Verify vercel.json contains /api/cron/process-sms-retries cron entry
Run `pnpm lint` - no JSON syntax errors
  </verify>
  <done>
Vercel cron configured to run SMS retry processor every minute.
  </done>
</task>

</tasks>

<verification>
1. Run `pnpm typecheck` - all files pass
2. Run `pnpm lint` - no lint errors
3. Verify retry queue functions export correctly
4. Verify cron route exists and exports GET
5. Verify vercel.json has both cron entries
</verification>

<success_criteria>
- queueSmsRetry queues with exponential backoff delays (1, 5, 15 min)
- Max 3 retry attempts before permanent failure
- processSmsRetryItem checks consent and quiet hours before each retry
- Cron endpoint uses claim_due_sms_retries for atomic claiming
- Cron recovers stuck processing items older than 10 minutes
- vercel.json configured with every-minute cron schedule
- All lint and typecheck passing
</success_criteria>

<output>
After completion, create `.planning/phases/21-sms-foundation-compliance/21-04-SUMMARY.md`
</output>
